{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"多线程\" tag",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/CPP/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B(C%20API)",
            "url": "http://example.com/value/CPP/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B(C%20API)",
            "title": "多线程编程(C API)",
            "date_published": "2024-03-17T11:27:36.716Z",
            "content_html": "<h2 id=\"创建线程\"><a class=\"anchor\" href=\"#创建线程\">#</a> 创建线程</h2>\n<pre><code class=\"language-c++\">/* 查看当前线程ID */\ntypedef unsigned long int pthread_t;\npthread_t pthread_self(void);\n/* 创建进程 */\nunion pthread_attr_t\n&#123;\n  char __size[__SIZEOF_PTHREAD_ATTR_T];\n  long int __align;\n&#125;;\ntypedef union pthread_attr_t pthread_attr_t;\nint pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);\n/*\nDescription:\n\tnewthread：传出参数，创建的新线程ID\n\taddr：线程的属性，一般情况使用默认值即可，NULL\n\tstart_routine:函数指针，创建出的子进程的处理函数，也就是在子线程中需要执行的函数\n\targ:作为实参传递到start_routine指针指向的函数内部\nReturn Value:\n\t线程创建成功返回0，否则返回对于的错误码\n*/\n</code></pre>\n<h2 id=\"线程退出\"><a class=\"anchor\" href=\"#线程退出\">#</a> 线程退出</h2>\n<pre><code class=\"language-c++\">void pthread_exit(void *retval);\n/*\nDescription:\n\t只要调用该函数，当前线程立马退出，并且不影响其他线程的运行，不管是在子进程还是主进程中都可以使用\n\tretval:线程退出时携带的数据，当前子线程的主进程会得到该数据。如果不需要，指定为NULL。\n*/\n</code></pre>\n<h2 id=\"线程回收\"><a class=\"anchor\" href=\"#线程回收\">#</a> 线程回收</h2>\n<pre><code class=\"language-c++\">int pthread_join(pthread_t thread, void **retval);\n/*\nDescription:\n\t用于在子进程退出后，主进程回收子进程的内核资源。该函数为一个堵塞函数，如果子进程还在运行，调用该函数就会堵塞，子线程退出函数解除堵塞，并将线程占用的内核资源回收。\n\tthread：子进程的进程ID\n\tretval：二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了pthread_exit()传递出的数据，如果不需要这个参数，可以指定为NULL。\nReturn Value:\n\t线程回收成功返回0，回收失败返回错误码。\n*/\n</code></pre>\n<h2 id=\"线程分离\"><a class=\"anchor\" href=\"#线程分离\">#</a> 线程分离</h2>\n<p>在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 <code>pthread_join()</code> ，只要子线程不退出，主线程就会被一直堵塞，主线程的任务也就不能被执行。</p>\n<pre><code class=\"language-c++\">int pthread_detach(pthread_t thread);\n/*\nDescription:\n\t调用线程分离函数之后，指定的子线程就可以和主线程分离，当子进程退出的时候，其占用的内核资源就会被系统的其他线程接管并回收。线程分离之后，主线程中使用的pthread_join()就回收不到子线程的资源了。\n\tthread：子线程ID\n*/\n</code></pre>\n<h2 id=\"线程取消\"><a class=\"anchor\" href=\"#线程取消\">#</a> 线程取消</h2>\n<pre><code class=\"language-c++\">int pthread_cancel(pthread_t thread);\n/*\nDescription:\n\t在一个线程中杀死另外一个线程。使用这个函数杀死一个线程需要分两步：\n\t1. 在线程A中调用线程取消函数pthread_cancel(),指定杀死线程B。\n\t2. 线程B中执行一次系统调用时才会被杀死，否则仍然存活。\n*/\n</code></pre>\n<h2 id=\"线程id比较\"><a class=\"anchor\" href=\"#线程id比较\">#</a> 线程 ID 比较</h2>\n<pre><code class=\"language-c++\">int pthread_equal(pthread_t t1, pthread_t t2);\n/*\nDescription:\n\tt1,t2为需要比较的两个线程ID。\nReturn Value:\n\t如果两个线程ID相等返回一个非0值，如果不等则返回0\n*/\n</code></pre>\n<h2 id=\"线程同步\"><a class=\"anchor\" href=\"#线程同步\">#</a> 线程同步</h2>\n<h3 id=\"互斥锁\"><a class=\"anchor\" href=\"#互斥锁\">#</a> 互斥锁</h3>\n<p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块。被锁定的代码块，所以线程只能顺序执行。</p>\n<pre><code class=\"language-c++\">pthread_mutex_t mutex;\n/* 初始化互斥锁 */\nint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *attr);\n/*\n\tmutex: 互斥锁变量地址\n\tattr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为NULL\n\t返回0，则初始化成功，否则返回错误码\n*/\n/* 释放互斥锁 */\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n/* 上锁 */\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t这个函数被调用，实现会判断参数mutex互斥锁中的状态是不是锁定状态：\n\t\t- 没有锁定，则这个线程可以加锁成功，这个锁会记录是哪一个线程加锁成功了\n\t\t- 如果被锁定，其他线程加锁就失败了，这些线程都会被堵塞在这把锁上\n\t\t- 当这把锁被解开之后，这些堵塞在锁上的线程就会解除堵塞，并且这些线程通过竞争的方式对这把锁加锁，没抢到锁的进程继续堵塞\n*/\n/* 尝试加锁 */\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t尝试对mutex互斥锁进行加锁：\n\t\t- 若互斥锁没有被锁定，线程加锁成功\n\t\t- 若互斥锁被锁定，调用这个函数加锁的线程，不会被堵塞，加锁失败直接返回错误码\n*/\n\n/* 解锁 */\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t并不是所以的线程都可以对互斥锁解锁，那个线程加的锁，那个线程才可以解锁。\n*/\n</code></pre>\n<h3 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h3>\n<p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。</p>\n<h3 id=\"读写锁\"><a class=\"anchor\" href=\"#读写锁\">#</a> 读写锁</h3>\n<p>读锁是共享的，写锁是独占的；写锁比读锁优先级高；如果临界区涉及大量的读操作，使用读写锁比使用互斥锁效率高，而只有少量的读操作，则互斥锁和读写锁效率差异不大</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pthread_rwlock_t rwlock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">/* 初始化读写锁 */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_init</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>restrict rwlock<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> pthread_rwlockattr_t <span class=\"token operator\">*</span>restrict attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/* 销毁读写锁 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_destroy</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/* 加读锁 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_rdlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">/* 尝试加读锁，加锁失败不堵塞 */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_tryrdlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">/* 加写锁 */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_wrlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* 尝试加写锁，加锁失败不堵塞 */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_trywrlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">/* 解锁（读锁 / 写锁） */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_unlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"条件变量\"><a class=\"anchor\" href=\"#条件变量\">#</a> 条件变量</h3>\n<p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型为 <code>pthread_cond_t</code> ，被条件变量堵塞的线程以及线程信息会被记录到这个变量中，以便在解除堵塞时使用。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pthread_cond_t cond<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">/* 初始化 */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_init</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> pthread_condaddr_t <span class=\"token operator\">*</span>restrict attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/* 销毁释放资源 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_destroy</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/* 堵塞当前线程 / 进程 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> pthread_mutex_t <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">timespec</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    time_t tv_sec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">long</span> tv_nsec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_timedwait</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> pthread_mutex_t <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">timespec</span> <span class=\"token operator\">*</span>restrict abstime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">/* 唤醒堵塞在条件变量上的一个线程 */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">/* 唤醒所以堵塞在条件变量上的线程 */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_broadcast</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;semaphore.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>sem_t sem<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_init</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pshared<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tsem: 信号量变量地址</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tpshared: 0 表示线程同步；非 0 表示进程同步</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tvalue: 初始化当前信号量拥有的资源数</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_destroy</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">&amp;</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_try_wait</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* 产看信号量 sem 当前拥有的资源个数，通过第二个参数传出（返回值也可以） */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_getvalue</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>sval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_post</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "C++",
                "多线程"
            ]
        }
    ]
}
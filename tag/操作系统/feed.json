{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"操作系统\" tag",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "操作系统面试题",
            "date_published": "2024-03-13T01:21:27.470Z",
            "content_html": "<h1 id=\"操作系统面试题\"><a class=\"anchor\" href=\"#操作系统面试题\">#</a> 操作系统面试题</h1>\n<h2 id=\"什么的操作系统\"><a class=\"anchor\" href=\"#什么的操作系统\">#</a> 什么的操作系统</h2>\n<p>操作系统是负责管理协调计算机硬件和软件资源的一种系统软件。其屏蔽了底层硬件的异构性和复杂性，为上层应用程序提供统一易用的接口.</p>\n<h2 id=\"主机启动\"><a class=\"anchor\" href=\"#主机启动\">#</a> 主机启动</h2>\n<blockquote>\n<p><code>BIOS</code> ：I/O 处理系统，开机时可以自动检测各种外设<br />\n <code>Bootloader</code> ：加载 OS</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.png\" alt=\"\" /></p>\n<h2 id=\"中断和异常的处理过程\"><a class=\"anchor\" href=\"#中断和异常的处理过程\">#</a> 中断和异常的处理过程</h2>\n<ul>\n<li>\n<p>外中断是指由 CPU 执行指令以外的时间引起的，如 IO 完成中断、时钟中断、控制台中断；</p>\n</li>\n<li>\n<p>内中断（异常）是由 CPU 执行指令内部事件引起的，如地址越界、除 0、算术溢出等.</p>\n</li>\n<li>\n<p>硬件</p>\n<blockquote>\n<ol>\n<li>设置中断标记</li>\n<li>操作系统根据这个标记（中断号）去找到对应的处理程序</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>软件</p>\n<blockquote>\n<ol>\n<li>保存现场：把当前执行程序的相关数据保存在寄存器中，然后入栈</li>\n<li>开中断：以便于响应优先级更高的中断请求</li>\n<li>中断服务程序处理</li>\n<li>关中断：保证恢复现场时不被中断</li>\n<li>恢复现场</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"系统调用\"><a class=\"anchor\" href=\"#系统调用\">#</a> 系统调用</h2>\n<blockquote>\n<p>应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用</p>\n<p><code>用户态</code> 转化到 <code>内核态</code></p>\n</blockquote>\n<h2 id=\"操作系统功能\"><a class=\"anchor\" href=\"#操作系统功能\">#</a> 操作系统功能</h2>\n<ul>\n<li>进程管理</li>\n<li>内存管理：负责管理内存的分配、回收。在进程创建时分配内存以及在进程结束时回收内存，协调内存资源</li>\n<li>设备管理</li>\n<li>文件管理</li>\n<li>提供用户接口</li>\n</ul>\n<h2 id=\"cpu内部结构\"><a class=\"anchor\" href=\"#cpu内部结构\">#</a> CPU 内部结构</h2>\n<ul>\n<li>计算逻辑单元 ALU</li>\n<li>寄存器</li>\n<li>控制器</li>\n<li>缓存</li>\n<li>内存管理单元 MMU</li>\n</ul>\n<h2 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h2>\n<ul>\n<li>程序计数器 <code>(prgram counter, PC)</code> ：用于存放下一条运行指令的地址.</li>\n<li>指令寄存器 <code>(Instraution Register, IR)</code> ：用于存放当前正在执行的指令.</li>\n<li>程序状态字 <code>(Program Status Word, PSW)</code></li>\n<li>累加寄存器 <code>(Accumulator Register, AX)</code> ：</li>\n<li>基地寄存器 <code>(Base Register, BX)</code></li>\n<li>变址寄存器</li>\n</ul>\n<h2 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">#</a> 进程与线程</h2>\n<p>进程是程序执行的一个过程，其实资源分配的基本单位，各个进程拥有自己独立的虚拟地址空间，执行互不干扰；同时父进程创建出的自进程之间也互不影响，子进程的崩溃或父进程的崩溃对互相并不影响。进程主要由程序段、数据段和程序控制块组成.</p>\n<blockquote>\n<ol>\n<li>程序段：程序运行的代码</li>\n<li>数据段：程序运行所产生的数据（全局变量、局部变量）</li>\n<li>程序控制块：操作系统对该进程进行管理所涉及到的各种信息\n<ul>\n<li><code>PID</code> ：进程标识符</li>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>程序计数器 PC</li>\n<li>内存指针</li>\n<li>上下文数据</li>\n</ul>\n</li>\n</ol>\n<p>在 <code>Linux</code>  中通过 <code>fork</code>  函数来创建一个子进程，子进程会拷贝父进程的；</p>\n<p>同一个进程共享堆、全局变量、静态变量，但是线程独占栈、程序计数器</p>\n</blockquote>\n<p>线程是进程内部的一个控制序列，其是 <code>CPU</code>  资源调度的基本单位，其是在进程内部运行，本质是在进程的地址空间运行，其可以和其他线程共享该进程的一些资源，比如全局变量、堆空间。但是每个线程也有自己独立的线程 ID，栈空间和程序计数器.</p>\n<h2 id=\"多线程与多进程\"><a class=\"anchor\" href=\"#多线程与多进程\">#</a> 多线程与多进程</h2>\n<blockquote>\n<p>多进程的优点：</p>\n<ul>\n<li>各个进程拥有自己独立的虚拟地址空间，各个程序之间的执行互不干扰，而且子进程的崩溃不会影响父进程，反之父进程崩溃也不会影响子进程</li>\n<li>多个进程可以充分利用 CPU，并行执行程序，不用担心并行执行程序导致的问题</li>\n</ul>\n<p>多线程的缺点：</p>\n<ul>\n<li>由于进程的独立性，不同进程之间数据交换需要进程通信</li>\n<li>创建一个子进程的开销比创建一个子线程的开销大</li>\n<li>线程的切换比进程的切换系统开销会更大【切换页表、切换内核栈和硬件上下文（进程切换之后，新程序的虚拟地址在 TLB 内失效，会导致频繁的访存）】</li>\n</ul>\n<p>多线程的优点：</p>\n<p>多线程的缺点：</p>\n</blockquote>\n<h2 id=\"进程调度算法\"><a class=\"anchor\" href=\"#进程调度算法\">#</a> 进程调度算法</h2>\n<ul>\n<li>先来先服务 <code>FCFS(First Come First Serverd)</code> ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）</li>\n<li>短作业优先 <code>SJF(Shortest Job First)</code> ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）</li>\n<li>最短剩余时间有优先</li>\n<li>时间片轮转</li>\n<li>优先级调度</li>\n<li>多级反馈队列：在一定程度上减少了频繁的进程切换的开销.</li>\n</ul>\n<h2 id=\"进程状态切换\"><a class=\"anchor\" href=\"#进程状态切换\">#</a> 进程状态切换</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg\" alt=\"\" title=\"进程状态切换\" /></p>\n<h2 id=\"进程间通信ipc方式\"><a class=\"anchor\" href=\"#进程间通信ipc方式\">#</a> 进程间通信 IPC 方式</h2>\n<blockquote>\n<p>两个或多个进程之间产生的数据交互</p>\n</blockquote>\n<ul>\n<li>\n<p>管道：半双工通信，数据只能单向流动.</p>\n<blockquote>\n<p>在内核中开辟一块缓冲区，进程 A 把数据从用户区拷贝到内核缓冲区，进程 B 再从内核缓冲区把数据读走.</p>\n</blockquote>\n<ul>\n<li>\n<p>匿名管道：具有情缘关系的进程之间的通信方式（具有同一个祖先）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> pipefd<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  1. pipefd [0]: 读端 read (管道空时堵塞)</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  2. pipefd [1]: 写端 write (管道满时堵塞)</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>*/</span></pre></td></tr></table></figure></li>\n<li>\n<p>有名管道：不相干的两个进程之间的通信方式</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/stat.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">mkfifo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>path<span class=\"token punctuation\">,</span> mode_t mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    path: 创建的命名管道的全路径名：</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mod: 为指定了文件的读写权限； </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>*/</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>共享内存 <code>(Shared Memory Segment)</code> ：由一个进程创建，多个进程都可以访问的一段内存空间。通过 <code>shmat</code>  可以将共享内存空间关联到指定的进程地址空间中</p>\n</li>\n<li>\n<p>消息队列</p>\n</li>\n<li>\n<p><code>Socket</code>  套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信</p>\n</li>\n<li>\n<p>信号 <code>Signal</code></p>\n</li>\n<li>\n<p>信号量</p>\n</li>\n</ul>\n<h2 id=\"进程同步\"><a class=\"anchor\" href=\"#进程同步\">#</a> 进程同步</h2>\n<ul>\n<li>互斥锁 + 条件变量</li>\n<li>信号量</li>\n<li>管程</li>\n</ul>\n<h2 id=\"多线程模型\"><a class=\"anchor\" href=\"#多线程模型\">#</a> 多线程模型</h2>\n<blockquote>\n<ul>\n<li>用户级线程</li>\n</ul>\n</blockquote>\n<h2 id=\"锁机制\"><a class=\"anchor\" href=\"#锁机制\">#</a> 锁机制</h2>\n<ul>\n<li>读写锁</li>\n<li>互斥锁</li>\n<li>条件变量</li>\n<li>自旋锁</li>\n</ul>\n<h2 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h2>\n<p>死锁是两个或两个以上的线程在执行的过程中，去争夺同一个共享资源锁导致的互相等待的一个现象，在没有外部干预的情况下，这些线程会一直处于堵塞状态，无法往下去执行.</p>\n<p>死锁产生的四个条件：</p>\n<blockquote>\n<ol>\n<li>互传条件</li>\n<li>请求与保持条件</li>\n<li>不剥夺条件</li>\n<li>循环等待条件</li>\n</ol>\n</blockquote>\n<h2 id=\"防止死锁的方法\"><a class=\"anchor\" href=\"#防止死锁的方法\">#</a> 防止死锁的方法</h2>\n<ol>\n<li>在第一次执行的时候一次性申请所有的共享资源</li>\n<li>占用部分资源的进程在进一步去申请其他共享资源的时候，如果申请不到，就主动释放它所占有的资源</li>\n</ol>\n<h2 id=\"银行家算法\"><a class=\"anchor\" href=\"#银行家算法\">#</a> 银行家算法</h2>\n<h2 id=\"连续内存分配\"><a class=\"anchor\" href=\"#连续内存分配\">#</a> 连续内存分配</h2>\n<ul>\n<li>\n<p>单一连续分配</p>\n<blockquote>\n<p>内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"单一连续分配\" /></p>\n</li>\n<li>\n<p>固定分区分配（无外部碎片，会产生内部碎片）</p>\n<blockquote>\n<ol>\n<li>分区大小相等（固定）：缺乏灵活性</li>\n<li>分区大小不等（固定）</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"固定分区分配\" /></p>\n</li>\n<li>\n<p>动态内存分配：不会预先划分内存空间</p>\n<blockquote>\n<ol>\n<li>首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区</li>\n<li>最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区</li>\n<li>最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区</li>\n<li>邻近适应算法： <code>首次适应算法</code> 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"空闲内存的管理方式\"><a class=\"anchor\" href=\"#空闲内存的管理方式\">#</a> 空闲内存的管理方式</h2>\n<ul>\n<li>空闲链表</li>\n<li>位图：将内存划分为均等的分配单元，每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用；分配单元的大小是一个值得考量的问题，分配单元太小会使得位图占用的空间过大，如果分配单元过大，内造成内部碎片。当需要分配一定大小空间的内存时，需要遍历真个位图，依次检查，时间复杂度较高.</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png\" alt=\"\" /></p>\n<h2 id=\"内存紧缩与交换式碎片整理\"><a class=\"anchor\" href=\"#内存紧缩与交换式碎片整理\">#</a> 内存紧缩与交换式碎片整理</h2>\n<h2 id=\"非连续内存分配\"><a class=\"anchor\" href=\"#非连续内存分配\">#</a> 非连续内存分配</h2>\n<blockquote>\n<ol>\n<li>连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高</li>\n<li>非连续内存分配优点：\n<ul>\n<li>程序的物理地址空间是非连续的，更好的利用内存空间</li>\n<li>允许共享代码与数据</li>\n<li>支持动态加载和动态链接</li>\n</ul>\n</li>\n<li>非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>分段</p>\n<blockquote>\n<ol>\n<li>分段的寻址方式</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分段的寻址方式\" /></p>\n</li>\n<li>\n<p>分页</p>\n<blockquote>\n<ol>\n<li>逻辑页 <code>page</code>  和物理页 <code>frame(帧)</code>  的大小一致</li>\n<li>不是所有的页都有对应的帧</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分页寻址方式\" /></p>\n</li>\n<li>\n<p>分段与分页的区别</p>\n<blockquote>\n<ol>\n<li>分页对程序员是透明的，但是分段需要程序员显示的划分每个段</li>\n<li>页的大小不可改变，段的大小可动态变化</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"页表\"><a class=\"anchor\" href=\"#页表\">#</a> 页表</h2>\n<ul>\n<li>\n<p>标志位</p>\n<blockquote>\n<ol>\n<li>访问位：表示当前页之前是否被访问过</li>\n<li>修改位：表示当前页之前是否被修改过</li>\n<li>保护位：表示是否允许对该页做任何类型的操作（读、写、可执行等)</li>\n<li>驻留位：表示该页是在 <code>内存</code> 中还是在 <code>外存</code> 中</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>帧号</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt=\"\" title=\"页表结构\" /></p>\n<blockquote>\n<ul>\n<li>由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.</li>\n<li>时间优化：TLB</li>\n<li>空间优化：多级页表、反向页表</li>\n</ul>\n</blockquote>\n<h2 id=\"tlb\"><a class=\"anchor\" href=\"#tlb\">#</a> TLB</h2>\n<blockquote>\n<p><code>TLB(Translation Look-aside Buffer)</code> ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png\" alt=\"\" title=\"TLB\" /></p>\n<h2 id=\"多级页表\"><a class=\"anchor\" href=\"#多级页表\">#</a> 多级页表</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png\" alt=\"\" title=\"多级页表\" /></p>\n<h2 id=\"反向页表\"><a class=\"anchor\" href=\"#反向页表\">#</a> 反向页表</h2>\n<h2 id=\"分段与分页对比\"><a class=\"anchor\" href=\"#分段与分页对比\">#</a> 分段与分页对比</h2>\n<h2 id=\"覆盖技术\"><a class=\"anchor\" href=\"#覆盖技术\">#</a> 覆盖技术</h2>\n<blockquote>\n<p>需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</p>\n</blockquote>\n<h2 id=\"交换技术\"><a class=\"anchor\" href=\"#交换技术\">#</a> 交换技术</h2>\n<blockquote>\n<p>以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</p>\n</blockquote>\n<h2 id=\"虚拟技术\"><a class=\"anchor\" href=\"#虚拟技术\">#</a> 虚拟技术</h2>\n<blockquote>\n<p>虚拟技术是把一个物理实体转化为多个逻辑实体</p>\n</blockquote>\n<ul>\n<li>\n<p>时空复用技术</p>\n<blockquote>\n<p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU</p>\n</blockquote>\n</li>\n<li>\n<p>空分复用技术</p>\n<blockquote>\n<p>虚拟内存：将物理内存抽象为逻辑地址空间，每个进程都有各自的地址空间.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"虚拟内存\"><a class=\"anchor\" href=\"#虚拟内存\">#</a> 虚拟内存</h2>\n<blockquote>\n<ol>\n<li>将物理空间扩充为更大的逻辑空间</li>\n<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行</li>\n<li>在程序执行过程中，如果执行的指令或访问的数据不在内存中（ <code>缺页</code> 或 <code>缺段</code> ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序</li>\n<li>另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序</li>\n</ol>\n</blockquote>\n<h2 id=\"缺页中断处理过程\"><a class=\"anchor\" href=\"#缺页中断处理过程\">#</a> 缺页中断处理过程</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"页面置换算法\"><a class=\"anchor\" href=\"#页面置换算法\">#</a> 页面置换算法</h2>\n<blockquote>\n<p>当缺页中断发生时，需要调入新的页面而内存已满时，选择内存当中那个物理页面进行替换（更可能减少换入换出的次数）</p>\n</blockquote>\n<ol>\n<li>\n<p>最优页面置换算法：将未来最久不会被访问的页面置换出去（理想情况）</p>\n</li>\n<li>\n<p>先进先出算法</p>\n</li>\n<li>\n<p>最近最久未使用 <code>LRU,Least Recently Used</code></p>\n<ol>\n<li>时钟页面置换算法 <code>CLOCK</code> ：最近未用算法</li>\n</ol>\n</li>\n<li>\n<p>二次机会法</p>\n</li>\n<li>\n<p>最不常用算法 <code>LFU,Least Frequently Used</code></p>\n</li>\n</ol>\n<blockquote>\n<p><code>Belady</code>  现象：分配的物理页面数增加，缺页率反而提高的异常现象（没有考虑进程访问的动态特征导致的， <code>FIFO</code> ）</p>\n</blockquote>\n<h2 id=\"虚拟地址转换位物理地址的过程\"><a class=\"anchor\" href=\"#虚拟地址转换位物理地址的过程\">#</a> 虚拟地址转换位物理地址的过程</h2>\n<h2 id=\"malloc申请内存时操作系统会怎么做\"><a class=\"anchor\" href=\"#malloc申请内存时操作系统会怎么做\">#</a>  <code>malloc</code>  申请内存时操作系统会怎么做？</h2>\n<p><code>malloc</code>  会调用 <code>brk</code>  和 <code>mmap</code>  两个系统调用来实现.</p>\n<h2 id=\"磁盘调度算法\"><a class=\"anchor\" href=\"#磁盘调度算法\">#</a> 磁盘调度算法</h2>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==\">王道计算机考研 操作系统_哔哩哔哩_bilibili</span></li>\n<li>[2] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">清华 操作系统原理_哔哩哔哩_bilibili</span></li>\n<li>[3] <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODA4NzI5MjA=\">操作系统常见面试题</span></li>\n<li>[4] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE1OTY1\">这 50 道操作系统面试题，真牛批！</span></li>\n</ul>\n",
            "tags": [
                "面试题",
                "操作系统"
            ]
        }
    ]
}
<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>繁華落盡 似水流年 • Posts by &#34;操作系统&#34; category</title>
        <link>http://example.com</link>
        <description>编程日记 &amp; 随笔</description>
        <language>en</language>
        <pubDate>Mon, 25 Mar 2024 21:35:06 +0800</pubDate>
        <lastBuildDate>Mon, 25 Mar 2024 21:35:06 +0800</lastBuildDate>
        <category>mathematics</category>
        <category>语法</category>
        <category>C++</category>
        <category>VMware</category>
        <category>install</category>
        <category>数据库</category>
        <category>STL</category>
        <category>CNN</category>
        <category>Project</category>
        <category>面试题</category>
        <category>日常</category>
        <category>校招</category>
        <category>算法</category>
        <category>Leetcode双周赛</category>
        <category>Algorithm</category>
        <category>Leetcode周赛</category>
        <category>设计模式</category>
        <category>多线程</category>
        <category>池化技术</category>
        <category>MySQL</category>
        <category>操作系统</category>
        <category>计算机网络</category>
        <category>CMake</category>
        <category>线程池</category>
        <category>Go</category>
        <category>Redis</category>
        <category>Linux</category>
        <category>json</category>
        <category>Python</category>
        <category>牛客</category>
        <category>Git</category>
        <category>normalization</category>
        <category>推理加速</category>
        <category>LLM</category>
        <category>AI算法</category>
        <category>Pytorch</category>
        <category>激活函数</category>
        <category>部署</category>
        <category>DolphinScheduler</category>
        <category>ZooKeeper</category>
        <item>
            <guid isPermalink="true">http://example.com/value/Linux%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</guid>
            <title>Linux基础与常用命令</title>
            <link>http://example.com/value/Linux%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</link>
            <category>Linux</category>
            <pubDate>Mon, 25 Mar 2024 21:35:06 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;linux基础与常用命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linux基础与常用命令&#34;&gt;#&lt;/a&gt; Linux 基础与常用命令&lt;/h1&gt;
&lt;h2 id=&#34;目录结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录结构&#34;&gt;#&lt;/a&gt; 目录结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bin(binary)&lt;/code&gt; ：存放一些常用命令，比如 &lt;code&gt;ls, mkdir&lt;/code&gt;  等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot&lt;/code&gt; ：存放系统启动需要用到的核心文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dev(device)&lt;/code&gt; ：在 &lt;code&gt;linux&lt;/code&gt;  中一切皆文件，存放 &lt;code&gt;Linux&lt;/code&gt;  下的设备文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etc&lt;/code&gt; ：存放系统用户所需要的配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;home&lt;/code&gt; ：存放用户目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib&lt;/code&gt; ：存放一些动态库文件，共应用程序使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lost+found&lt;/code&gt; ：一般情况下是空的，当系统异常关机后，该目录下会存放一些系统文件，用于恢复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;media&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mnt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sbin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;srv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;usr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件颜色&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件颜色&#34;&gt;#&lt;/a&gt; 文件颜色&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;白色：普通文件&lt;/li&gt;
&lt;li&gt;蓝色：目录&lt;/li&gt;
&lt;li&gt;绿色：可执行文件&lt;/li&gt;
&lt;li&gt;青色：链接文件&lt;/li&gt;
&lt;li&gt;红色：压缩文件、失效的链接文件&lt;/li&gt;
&lt;li&gt;黄色：设备文件&lt;/li&gt;
&lt;li&gt;灰色：其他文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;终端快捷键&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#终端快捷键&#34;&gt;#&lt;/a&gt; 终端快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl + b&lt;/code&gt; ：向后移动光标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + f&lt;/code&gt; ：向前移动光标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + a&lt;/code&gt; ：光标移动到行首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + e&lt;/code&gt; ：光标移动的行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + u&lt;/code&gt; ：删除光标之前位置的所有内容（不包括光标当前位置）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + k&lt;/code&gt; ：删除光标之后位置的所有内容（包括光标当前位置）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + w&lt;/code&gt; ：删除光标前面的一个单词&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件的权限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件的权限&#34;&gt;#&lt;/a&gt; 文件的权限&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可读 &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可写 &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可执行 &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;无权限 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;文件所有者： &lt;code&gt;rwx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用户组：&lt;/li&gt;
&lt;li&gt;其他人&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;通配符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#通配符&#34;&gt;#&lt;/a&gt; 通配符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; ：匹配 0 个或者多个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; ：匹配一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[abcd]&lt;/code&gt; ：匹配 &lt;code&gt;abcd&lt;/code&gt;  中任意 &lt;code&gt;一个&lt;/code&gt; 字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[a-z]&lt;/code&gt; ：匹配 &lt;code&gt;a-z&lt;/code&gt;  范围内的任意 &lt;code&gt;一个&lt;/code&gt; 字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[!abc]&lt;/code&gt; ：除 &lt;code&gt;abc&lt;/code&gt;  中的字符之外，可以与任意 &lt;code&gt;一个&lt;/code&gt; 字符匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[^abc]&lt;/code&gt; ：与 &lt;code&gt;[!abc]&lt;/code&gt;  一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; ：列出当前目录或指定目录下的文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; ：显示所有文件，包括隐藏文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; ：个性化显示文件大小， &lt;code&gt;KB&lt;/code&gt;  替代字节数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; ：切换目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; ：家目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;..&lt;/code&gt; ：上一级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;  当前目录&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt; ：显示当前所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt; ：输出指定的字符串或变量值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; ：查看文件内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; ：显示行号&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tac&lt;/code&gt; ：反向查看文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;more&lt;/code&gt; ：逐页显示文件内容，配合上下键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;less&lt;/code&gt; ：逐页显示文件内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; ：显示文件前几行内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tail&lt;/code&gt; ：显示文件最后几行内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt; ：过滤或搜索文件中的关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt; ：搜索文件&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;figcaption data-lang=&#34;Bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;find&lt;/span&gt; /home/ &lt;span class=&#34;token parameter variable&#34;&gt;-name&lt;/span&gt; test.txt	&lt;span class=&#34;token comment&#34;&gt;# 根据文件名搜索&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; ：产看网卡信息（IP 地址、子网掩码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ping&lt;/code&gt; ：常用于检查网络连通性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;telnet&lt;/code&gt; ：检查端口连通性&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;figcaption data-lang=&#34;Bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;telnet &lt;span class=&#34;token number&#34;&gt;192.168&lt;/span&gt;.0.180 &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;# 检查 22 端口是否连通&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; ：检查网络连接状况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; ：抓包分析工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; ：远程连接主机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wget&lt;/code&gt; ：从远程下载文件&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;figcaption data-lang=&#34;Bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wget&lt;/span&gt; https://download/xxx.txt&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; ：产看进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kill&lt;/code&gt; ：杀死进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt; ：关机并关闭电源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reboot&lt;/code&gt; ：重启&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;hostname&lt;/code&gt; ：查看主机名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt; ：查看当前进程的资源使用情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; ：添加用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;usermod&lt;/code&gt; ：修改用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;userdel&lt;/code&gt; ：删除用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt; ：修改用户名的密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;su&lt;/code&gt; ：切换用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chmod&lt;/code&gt; ：修改文件或目录的权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python2与python3共存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python2与python3共存&#34;&gt;#&lt;/a&gt; python2 与 python3 共存&lt;/h2&gt;
&lt;h2 id=&#34;yum失效&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#yum失效&#34;&gt;#&lt;/a&gt; yum 失效&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98</guid>
            <title>操作系统面试题</title>
            <link>http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98</link>
            <category>面试题</category>
            <category>操作系统</category>
            <pubDate>Wed, 13 Mar 2024 09:21:27 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;操作系统面试题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作系统面试题&#34;&gt;#&lt;/a&gt; 操作系统面试题&lt;/h1&gt;
&lt;h2 id=&#34;什么的操作系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么的操作系统&#34;&gt;#&lt;/a&gt; 什么的操作系统&lt;/h2&gt;
&lt;p&gt;操作系统是负责管理协调计算机硬件和软件资源的一种系统软件。其屏蔽了底层硬件的异构性和复杂性，为上层应用程序提供统一易用的接口.&lt;/p&gt;
&lt;h2 id=&#34;主机启动&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主机启动&#34;&gt;#&lt;/a&gt; 主机启动&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;BIOS&lt;/code&gt; ：I/O 处理系统，开机时可以自动检测各种外设&lt;br /&gt;
 &lt;code&gt;Bootloader&lt;/code&gt; ：加载 OS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;中断和异常的处理过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#中断和异常的处理过程&#34;&gt;#&lt;/a&gt; 中断和异常的处理过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;外中断是指由 CPU 执行指令以外的时间引起的，如 IO 完成中断、时钟中断、控制台中断；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内中断（异常）是由 CPU 执行指令内部事件引起的，如地址越界、除 0、算术溢出等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;设置中断标记&lt;/li&gt;
&lt;li&gt;操作系统根据这个标记（中断号）去找到对应的处理程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;保存现场：把当前执行程序的相关数据保存在寄存器中，然后入栈&lt;/li&gt;
&lt;li&gt;开中断：以便于响应优先级更高的中断请求&lt;/li&gt;
&lt;li&gt;中断服务程序处理&lt;/li&gt;
&lt;li&gt;关中断：保证恢复现场时不被中断&lt;/li&gt;
&lt;li&gt;恢复现场&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#系统调用&#34;&gt;#&lt;/a&gt; 系统调用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用户态&lt;/code&gt; 转化到 &lt;code&gt;内核态&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;操作系统功能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作系统功能&#34;&gt;#&lt;/a&gt; 操作系统功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程管理&lt;/li&gt;
&lt;li&gt;内存管理：负责管理内存的分配、回收。在进程创建时分配内存以及在进程结束时回收内存，协调内存资源&lt;/li&gt;
&lt;li&gt;设备管理&lt;/li&gt;
&lt;li&gt;文件管理&lt;/li&gt;
&lt;li&gt;提供用户接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu内部结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu内部结构&#34;&gt;#&lt;/a&gt; CPU 内部结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算逻辑单元 ALU&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;内存管理单元 MMU&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寄存器&#34;&gt;#&lt;/a&gt; 寄存器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器 &lt;code&gt;(prgram counter, PC)&lt;/code&gt; ：用于存放下一条运行指令的地址.&lt;/li&gt;
&lt;li&gt;指令寄存器 &lt;code&gt;(Instraution Register, IR)&lt;/code&gt; ：用于存放当前正在执行的指令.&lt;/li&gt;
&lt;li&gt;程序状态字 &lt;code&gt;(Program Status Word, PSW)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;累加寄存器 &lt;code&gt;(Accumulator Register, AX)&lt;/code&gt; ：&lt;/li&gt;
&lt;li&gt;基地寄存器 &lt;code&gt;(Base Register, BX)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变址寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程与线程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程与线程&#34;&gt;#&lt;/a&gt; 进程与线程&lt;/h2&gt;
&lt;p&gt;进程是程序执行的一个过程，其实资源分配的基本单位，各个进程拥有自己独立的虚拟地址空间，执行互不干扰；同时父进程创建出的自进程之间也互不影响，子进程的崩溃或父进程的崩溃对互相并不影响。进程主要由程序段、数据段和程序控制块组成.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;程序段：程序运行的代码&lt;/li&gt;
&lt;li&gt;数据段：程序运行所产生的数据（全局变量、局部变量）&lt;/li&gt;
&lt;li&gt;程序控制块：操作系统对该进程进行管理所涉及到的各种信息
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PID&lt;/code&gt; ：进程标识符&lt;/li&gt;
&lt;li&gt;进程状态&lt;/li&gt;
&lt;li&gt;进程优先级&lt;/li&gt;
&lt;li&gt;程序计数器 PC&lt;/li&gt;
&lt;li&gt;内存指针&lt;/li&gt;
&lt;li&gt;上下文数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt;  中通过 &lt;code&gt;fork&lt;/code&gt;  函数来创建一个子进程，子进程会拷贝父进程的；&lt;/p&gt;
&lt;p&gt;同一个进程共享堆、全局变量、静态变量，但是线程独占栈、程序计数器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程是进程内部的一个控制序列，其是 &lt;code&gt;CPU&lt;/code&gt;  资源调度的基本单位，其是在进程内部运行，本质是在进程的地址空间运行，其可以和其他线程共享该进程的一些资源，比如全局变量、堆空间。但是每个线程也有自己独立的线程 ID，栈空间和程序计数器.&lt;/p&gt;
&lt;h2 id=&#34;多线程与多进程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多线程与多进程&#34;&gt;#&lt;/a&gt; 多线程与多进程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;多进程的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各个进程拥有自己独立的虚拟地址空间，各个程序之间的执行互不干扰，而且子进程的崩溃不会影响父进程，反之父进程崩溃也不会影响子进程&lt;/li&gt;
&lt;li&gt;多个进程可以充分利用 CPU，并行执行程序，不用担心并行执行程序导致的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多线程的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于进程的独立性，不同进程之间数据交换需要进程通信&lt;/li&gt;
&lt;li&gt;创建一个子进程的开销比创建一个子线程的开销大&lt;/li&gt;
&lt;li&gt;线程的切换比进程的切换系统开销会更大【切换页表、切换内核栈和硬件上下文（进程切换之后，新程序的虚拟地址在 TLB 内失效，会导致频繁的访存）】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多线程的优点：&lt;/p&gt;
&lt;p&gt;多线程的缺点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;进程调度算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程调度算法&#34;&gt;#&lt;/a&gt; 进程调度算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务 &lt;code&gt;FCFS(First Come First Serverd)&lt;/code&gt; ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）&lt;/li&gt;
&lt;li&gt;短作业优先 &lt;code&gt;SJF(Shortest Job First)&lt;/code&gt; ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）&lt;/li&gt;
&lt;li&gt;最短剩余时间有优先&lt;/li&gt;
&lt;li&gt;时间片轮转&lt;/li&gt;
&lt;li&gt;优先级调度&lt;/li&gt;
&lt;li&gt;多级反馈队列：在一定程度上减少了频繁的进程切换的开销.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程状态切换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程状态切换&#34;&gt;#&lt;/a&gt; 进程状态切换&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;&#34; title=&#34;进程状态切换&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;进程间通信ipc方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程间通信ipc方式&#34;&gt;#&lt;/a&gt; 进程间通信 IPC 方式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;两个或多个进程之间产生的数据交互&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管道：半双工通信，数据只能单向流动.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在内核中开辟一块缓冲区，进程 A 把数据从用户区拷贝到内核缓冲区，进程 B 再从内核缓冲区把数据读走.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;匿名管道：具有情缘关系的进程之间的通信方式（具有同一个祖先）&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;unistd.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; pipefd&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;/*&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  1. pipefd [0]: 读端 read (管道空时堵塞)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  2. pipefd [1]: 写端 write (管道满时堵塞)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有名管道：不相干的两个进程之间的通信方式&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;sys/types.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;sys/stat.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkfifo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;path&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; mode_t mode&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;/*&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    path: 创建的命名管道的全路径名：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    mod: 为指定了文件的读写权限； &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享内存 &lt;code&gt;(Shared Memory Segment)&lt;/code&gt; ：由一个进程创建，多个进程都可以访问的一段内存空间。通过 &lt;code&gt;shmat&lt;/code&gt;  可以将共享内存空间关联到指定的进程地址空间中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;  套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号 &lt;code&gt;Signal&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程同步&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程同步&#34;&gt;#&lt;/a&gt; 进程同步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁 + 条件变量&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;管程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程模型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多线程模型&#34;&gt;#&lt;/a&gt; 多线程模型&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;用户级线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;锁机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#锁机制&#34;&gt;#&lt;/a&gt; 锁机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;读写锁&lt;/li&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;条件变量&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#死锁&#34;&gt;#&lt;/a&gt; 死锁&lt;/h2&gt;
&lt;p&gt;死锁是两个或两个以上的线程在执行的过程中，去争夺同一个共享资源锁导致的互相等待的一个现象，在没有外部干预的情况下，这些线程会一直处于堵塞状态，无法往下去执行.&lt;/p&gt;
&lt;p&gt;死锁产生的四个条件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;互传条件&lt;/li&gt;
&lt;li&gt;请求与保持条件&lt;/li&gt;
&lt;li&gt;不剥夺条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;防止死锁的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#防止死锁的方法&#34;&gt;#&lt;/a&gt; 防止死锁的方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在第一次执行的时候一次性申请所有的共享资源&lt;/li&gt;
&lt;li&gt;占用部分资源的进程在进一步去申请其他共享资源的时候，如果申请不到，就主动释放它所占有的资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;银行家算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#银行家算法&#34;&gt;#&lt;/a&gt; 银行家算法&lt;/h2&gt;
&lt;h2 id=&#34;连续内存分配&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#连续内存分配&#34;&gt;#&lt;/a&gt; 连续内存分配&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单一连续分配&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png&#34; alt=&#34;&#34; title=&#34;单一连续分配&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定分区分配（无外部碎片，会产生内部碎片）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;分区大小相等（固定）：缺乏灵活性&lt;/li&gt;
&lt;li&gt;分区大小不等（固定）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png&#34; alt=&#34;&#34; title=&#34;固定分区分配&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态内存分配：不会预先划分内存空间&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区&lt;/li&gt;
&lt;li&gt;最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区&lt;/li&gt;
&lt;li&gt;最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区&lt;/li&gt;
&lt;li&gt;邻近适应算法： &lt;code&gt;首次适应算法&lt;/code&gt; 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;空闲内存的管理方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#空闲内存的管理方式&#34;&gt;#&lt;/a&gt; 空闲内存的管理方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空闲链表&lt;/li&gt;
&lt;li&gt;位图：将内存划分为均等的分配单元，每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用；分配单元的大小是一个值得考量的问题，分配单元太小会使得位图占用的空间过大，如果分配单元过大，内造成内部碎片。当需要分配一定大小空间的内存时，需要遍历真个位图，依次检查，时间复杂度较高.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存紧缩与交换式碎片整理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存紧缩与交换式碎片整理&#34;&gt;#&lt;/a&gt; 内存紧缩与交换式碎片整理&lt;/h2&gt;
&lt;h2 id=&#34;非连续内存分配&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#非连续内存分配&#34;&gt;#&lt;/a&gt; 非连续内存分配&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高&lt;/li&gt;
&lt;li&gt;非连续内存分配优点：
&lt;ul&gt;
&lt;li&gt;程序的物理地址空间是非连续的，更好的利用内存空间&lt;/li&gt;
&lt;li&gt;允许共享代码与数据&lt;/li&gt;
&lt;li&gt;支持动态加载和动态链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分段&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;分段的寻址方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;&#34; title=&#34;分段的寻址方式&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分页&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;逻辑页 &lt;code&gt;page&lt;/code&gt;  和物理页 &lt;code&gt;frame(帧)&lt;/code&gt;  的大小一致&lt;/li&gt;
&lt;li&gt;不是所有的页都有对应的帧&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;&#34; title=&#34;分页寻址方式&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分段与分页的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;分页对程序员是透明的，但是分段需要程序员显示的划分每个段&lt;/li&gt;
&lt;li&gt;页的大小不可改变，段的大小可动态变化&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#页表&#34;&gt;#&lt;/a&gt; 页表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标志位&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;访问位：表示当前页之前是否被访问过&lt;/li&gt;
&lt;li&gt;修改位：表示当前页之前是否被修改过&lt;/li&gt;
&lt;li&gt;保护位：表示是否允许对该页做任何类型的操作（读、写、可执行等)&lt;/li&gt;
&lt;li&gt;驻留位：表示该页是在 &lt;code&gt;内存&lt;/code&gt; 中还是在 &lt;code&gt;外存&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帧号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png&#34; alt=&#34;&#34; title=&#34;页表结构&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.&lt;/li&gt;
&lt;li&gt;时间优化：TLB&lt;/li&gt;
&lt;li&gt;空间优化：多级页表、反向页表&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tlb&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tlb&#34;&gt;#&lt;/a&gt; TLB&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TLB(Translation Look-aside Buffer)&lt;/code&gt; ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png&#34; alt=&#34;&#34; title=&#34;TLB&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;多级页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多级页表&#34;&gt;#&lt;/a&gt; 多级页表&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png&#34; alt=&#34;&#34; title=&#34;多级页表&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;反向页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反向页表&#34;&gt;#&lt;/a&gt; 反向页表&lt;/h2&gt;
&lt;h2 id=&#34;分段与分页对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分段与分页对比&#34;&gt;#&lt;/a&gt; 分段与分页对比&lt;/h2&gt;
&lt;h2 id=&#34;覆盖技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#覆盖技术&#34;&gt;#&lt;/a&gt; 覆盖技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;交换技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交换技术&#34;&gt;#&lt;/a&gt; 交换技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;虚拟技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟技术&#34;&gt;#&lt;/a&gt; 虚拟技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟技术是把一个物理实体转化为多个逻辑实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时空复用技术&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空分复用技术&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟内存：将物理内存抽象为逻辑地址空间，每个进程都有各自的地址空间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟内存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟内存&#34;&gt;#&lt;/a&gt; 虚拟内存&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;将物理空间扩充为更大的逻辑空间&lt;/li&gt;
&lt;li&gt;在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行&lt;/li&gt;
&lt;li&gt;在程序执行过程中，如果执行的指令或访问的数据不在内存中（ &lt;code&gt;缺页&lt;/code&gt; 或 &lt;code&gt;缺段&lt;/code&gt; ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序&lt;/li&gt;
&lt;li&gt;另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;缺页中断处理过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#缺页中断处理过程&#34;&gt;#&lt;/a&gt; 缺页中断处理过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;页面置换算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#页面置换算法&#34;&gt;#&lt;/a&gt; 页面置换算法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;当缺页中断发生时，需要调入新的页面而内存已满时，选择内存当中那个物理页面进行替换（更可能减少换入换出的次数）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最优页面置换算法：将未来最久不会被访问的页面置换出去（理想情况）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先进先出算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近最久未使用 &lt;code&gt;LRU,Least Recently Used&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时钟页面置换算法 &lt;code&gt;CLOCK&lt;/code&gt; ：最近未用算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二次机会法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最不常用算法 &lt;code&gt;LFU,Least Frequently Used&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Belady&lt;/code&gt;  现象：分配的物理页面数增加，缺页率反而提高的异常现象（没有考虑进程访问的动态特征导致的， &lt;code&gt;FIFO&lt;/code&gt; ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;虚拟地址转换位物理地址的过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟地址转换位物理地址的过程&#34;&gt;#&lt;/a&gt; 虚拟地址转换位物理地址的过程&lt;/h2&gt;
&lt;h2 id=&#34;malloc申请内存时操作系统会怎么做&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#malloc申请内存时操作系统会怎么做&#34;&gt;#&lt;/a&gt;  &lt;code&gt;malloc&lt;/code&gt;  申请内存时操作系统会怎么做？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt;  会调用 &lt;code&gt;brk&lt;/code&gt;  和 &lt;code&gt;mmap&lt;/code&gt;  两个系统调用来实现.&lt;/p&gt;
&lt;h2 id=&#34;磁盘调度算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#磁盘调度算法&#34;&gt;#&lt;/a&gt; 磁盘调度算法&lt;/h2&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考资料&#34;&gt;#&lt;/a&gt; 参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==&#34;&gt;王道计算机考研 操作系统_哔哩哔哩_bilibili&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=&#34;&gt;清华 操作系统原理_哔哩哔哩_bilibili&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODA4NzI5MjA=&#34;&gt;操作系统常见面试题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE1OTY1&#34;&gt;这 50 道操作系统面试题，真牛批！&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>

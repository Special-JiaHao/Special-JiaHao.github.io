{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"操作系统\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "操作系统面试题",
            "date_published": "2024-03-13T01:21:27.470Z",
            "content_html": "<h1 id=\"操作系统面试题\"><a class=\"anchor\" href=\"#操作系统面试题\">#</a> 操作系统面试题</h1>\n<h2 id=\"主机启动\"><a class=\"anchor\" href=\"#主机启动\">#</a> 主机启动</h2>\n<blockquote>\n<p><code>BIOS</code> ：I/O 处理系统，开机时可以自动检测各种外设<br />\n <code>Bootloader</code> ：加载 OS</p>\n</blockquote>\n<h2 id=\"中断和异常的处理过程\"><a class=\"anchor\" href=\"#中断和异常的处理过程\">#</a> 中断和异常的处理过程</h2>\n<ul>\n<li>\n<p>硬件</p>\n<blockquote>\n<ol>\n<li>设置中断标记</li>\n<li>操作系统根据这个标记（中断号）去找到对应的处理程序</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>软件</p>\n<blockquote>\n<ol>\n<li>保存现场</li>\n<li>中断服务程序处理</li>\n<li>清除中断标记</li>\n<li>恢复现场</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"系统调用\"><a class=\"anchor\" href=\"#系统调用\">#</a> 系统调用</h2>\n<blockquote>\n<p>应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用</p>\n<p><code>用户态</code> 转化到 <code>内核态</code></p>\n</blockquote>\n<h2 id=\"cpu内部结构\"><a class=\"anchor\" href=\"#cpu内部结构\">#</a> CPU 内部结构</h2>\n<ul>\n<li>计算逻辑单元 ALU</li>\n<li>寄存器</li>\n<li>控制器</li>\n<li>缓存</li>\n<li>内存管理单元 MMU</li>\n</ul>\n<h2 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">#</a> 进程与线程</h2>\n<ul>\n<li>进程是资源分配的基本单位，线程是资源调度的基本单位</li>\n<li>一个线程属于一个进程，每个进程可以包含多个不同的线程</li>\n<li>每个进程有多个线程组层，但只有一个主线程，它们共享内存空间（堆、全局变量），但是有各自的栈空间</li>\n<li>系统开销</li>\n</ul>\n<h2 id=\"进程调度算法\"><a class=\"anchor\" href=\"#进程调度算法\">#</a> 进程调度算法</h2>\n<ul>\n<li>先来先服务 <code>FCFS(First Come First Serverd)</code> ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）</li>\n<li>短作业优先 <code>SJF(Shortest Job First)</code> ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）</li>\n<li>时间片轮转</li>\n<li>优先级调度</li>\n<li>多级反馈队列</li>\n</ul>\n<h2 id=\"进程间通信方式\"><a class=\"anchor\" href=\"#进程间通信方式\">#</a> 进程间通信方式</h2>\n<ul>\n<li>管道</li>\n<li>共享内存</li>\n<li>消息队列</li>\n<li>套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信</li>\n<li>信号：</li>\n<li>信号量</li>\n</ul>\n<h2 id=\"进程同步的四种方式\"><a class=\"anchor\" href=\"#进程同步的四种方式\">#</a> 进程同步的四种方式</h2>\n<h2 id=\"连续内存分配\"><a class=\"anchor\" href=\"#连续内存分配\">#</a> 连续内存分配</h2>\n<ul>\n<li>\n<p>单一连续分配</p>\n<blockquote>\n<p>内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"单一连续分配\" /></p>\n</li>\n<li>\n<p>固定分区分配（无外部碎片，会产生内部碎片）</p>\n<blockquote>\n<ol>\n<li>分区大小相等（固定）：缺乏灵活性</li>\n<li>分区大小不等（固定）</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"固定分区分配\" /></p>\n</li>\n<li>\n<p>动态内存分配：不会预先划分内存空间</p>\n<blockquote>\n<ol>\n<li>首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区</li>\n<li>最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区</li>\n<li>最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区</li>\n<li>邻近适应算法： <code>首次适应算法</code> 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"如何记录内存的使用情况\"><a class=\"anchor\" href=\"#如何记录内存的使用情况\">#</a> 如何记录内存的使用情况</h2>\n<ul>\n<li>空闲分区表</li>\n<li>空闲分区链</li>\n</ul>\n<h2 id=\"内存紧缩与交换式碎片整理\"><a class=\"anchor\" href=\"#内存紧缩与交换式碎片整理\">#</a> 内存紧缩与交换式碎片整理</h2>\n<h2 id=\"非连续内存分配\"><a class=\"anchor\" href=\"#非连续内存分配\">#</a> 非连续内存分配</h2>\n<blockquote>\n<ol>\n<li>连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高</li>\n<li>非连续内存分配优点：\n<ul>\n<li>程序的物理地址空间是非连续的，更好的利用内存空间</li>\n<li>允许共享代码与数据</li>\n<li>支持动态加载和动态链接</li>\n</ul>\n</li>\n<li>非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>分段</p>\n<blockquote>\n<ol>\n<li>分段的寻址方式</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分段的寻址方式\" /></p>\n</li>\n<li>\n<p>分页</p>\n<blockquote>\n<ol>\n<li>逻辑页 <code>page</code>  和物理页 <code>frame(帧)</code>  的大小一致</li>\n<li>不是所有的页都有对应的帧</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分页寻址方式\" /></p>\n</li>\n</ul>\n<h2 id=\"页表\"><a class=\"anchor\" href=\"#页表\">#</a> 页表</h2>\n<ul>\n<li>\n<p>标志位</p>\n<blockquote>\n<ol>\n<li>访问位：表示当前页之前是否被访问过</li>\n<li>修改位：表示当前页之前是否被修改过</li>\n<li>保护位：表示是否允许对该页做任何类型的操作（读、写、可执行等)</li>\n<li>驻留位：表示该页是在 <code>内存</code> 中还是在 <code>外存</code> 中</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>帧号</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt=\"\" title=\"页表结构\" /></p>\n<blockquote>\n<ul>\n<li>由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.</li>\n<li>时间优化：TLB</li>\n<li>空间优化：多级页表、反向页表</li>\n</ul>\n</blockquote>\n<h2 id=\"tlb\"><a class=\"anchor\" href=\"#tlb\">#</a> TLB</h2>\n<blockquote>\n<p><code>TLB(Translation Look-aside Buffer)</code> ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png\" alt=\"\" title=\"TLB\" /></p>\n<h2 id=\"多级页表\"><a class=\"anchor\" href=\"#多级页表\">#</a> 多级页表</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png\" alt=\"\" title=\"多级页表\" /></p>\n<h2 id=\"反向页表\"><a class=\"anchor\" href=\"#反向页表\">#</a> 反向页表</h2>\n<h2 id=\"覆盖技术\"><a class=\"anchor\" href=\"#覆盖技术\">#</a> 覆盖技术</h2>\n<blockquote>\n<p>需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</p>\n</blockquote>\n<h2 id=\"交换技术\"><a class=\"anchor\" href=\"#交换技术\">#</a> 交换技术</h2>\n<blockquote>\n<p>以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</p>\n</blockquote>\n<h2 id=\"虚拟技术\"><a class=\"anchor\" href=\"#虚拟技术\">#</a> 虚拟技术</h2>\n<blockquote>\n<p>虚拟技术是把一个物理实体转化为多个逻辑实体</p>\n</blockquote>\n<ul>\n<li>\n<p>时空复用技术</p>\n<blockquote>\n<p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU</p>\n</blockquote>\n</li>\n<li>\n<p>空分复用技术</p>\n<blockquote>\n<p>虚拟内存：将物理内存抽象为地址空间，每个进程都有各自的地址空间.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"虚拟内存\"><a class=\"anchor\" href=\"#虚拟内存\">#</a> 虚拟内存</h2>\n<blockquote>\n<ol>\n<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行</li>\n<li>在程序执行过程中，如果执行的指令或访问的数据不在内存中（ <code>缺页</code> 或 <code>缺段</code> ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序</li>\n<li>另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序</li>\n</ol>\n</blockquote>\n<h2 id=\"缺页中断处理过程\"><a class=\"anchor\" href=\"#缺页中断处理过程\">#</a> 缺页中断处理过程</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"页面置换算法\"><a class=\"anchor\" href=\"#页面置换算法\">#</a> 页面置换算法</h2>\n<blockquote>\n<p>当缺页中断发生时，需要调入新的页面而内存已满时，选择内存当中那个物理页面进行替换（更可能减少换入换出的次数）</p>\n</blockquote>\n<ol>\n<li>最优页面置换算法：将未来最久不会被访问的页面置换出去（理想情况）</li>\n<li>先进先出算法</li>\n<li>最近最久未使用 <code>LRU,Least Recently Used</code></li>\n<li>时钟页面置换算法</li>\n<li>二次机会法</li>\n<li>最不常用算法 <code>LFU,Least Frequently Used</code></li>\n</ol>\n<blockquote>\n<p><code>Belady</code>  现象：分配的物理页面数增加，缺页率反而提高的异常现象（没有考虑进程访问的动态特征导致的， <code>FIFO</code> ）</p>\n</blockquote>\n<h2 id=\"进程状态切换\"><a class=\"anchor\" href=\"#进程状态切换\">#</a> 进程状态切换</h2>\n<h2 id=\"虚拟地址转换位物理地址的过程\"><a class=\"anchor\" href=\"#虚拟地址转换位物理地址的过程\">#</a> 虚拟地址转换位物理地址的过程</h2>\n<h2 id=\"磁盘调度算法\"><a class=\"anchor\" href=\"#磁盘调度算法\">#</a> 磁盘调度算法</h2>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==\">王道计算机考研 操作系统_哔哩哔哩_bilibili</span></li>\n<li>[2] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">清华 操作系统原理_哔哩哔哩_bilibili</span></li>\n</ul>\n",
            "tags": [
                "面试题"
            ]
        }
    ]
}
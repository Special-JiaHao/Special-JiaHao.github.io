{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"操作系统\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/Linux%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/Linux%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "Linux面试题",
            "date_published": "2024-03-25T13:35:06.598Z",
            "content_html": "<h1 id=\"linux面试题\"><a class=\"anchor\" href=\"#linux面试题\">#</a> Linux 面试题</h1>\n<h2 id=\"linux常用命令\"><a class=\"anchor\" href=\"#linux常用命令\">#</a> Linux 常用命令</h2>\n<ul>\n<li>\n<p><code>ls</code> ：列出当前目录或指定目录下的文件</p>\n<blockquote>\n<ol>\n<li><code>-a</code> ：显示所有文件，包括隐藏文件</li>\n<li><code>-h</code> ：个性化显示文件大小， <code>KB</code>  替代字节数</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>cd</code> ：切换目录</p>\n<blockquote>\n<ol>\n<li><code>~</code> ：家目录</li>\n<li><code>..</code> ：上一级</li>\n<li><code>.</code>  当前目录</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>pwd</code> ：显示当前所在目录</p>\n</li>\n<li>\n<p><code>echo</code> ：输出指定的字符串或变量值</p>\n</li>\n<li>\n<p><code>cat</code> ：查看文件内容</p>\n<blockquote>\n<ol>\n<li><code>-n</code> ：显示行号</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>tac</code> ：反向查看文件内容</p>\n</li>\n<li>\n<p><code>more</code> ：逐页显示文件内容，配合上下键</p>\n</li>\n<li>\n<p><code>less</code> ：逐页显示文件内容</p>\n</li>\n<li>\n<p><code>head</code> ：显示文件前几行内容</p>\n</li>\n<li>\n<p><code>tail</code> ：显示文件最后几行内容</p>\n</li>\n<li>\n<p><code>grep</code> ：过滤或搜索文件中的关键字</p>\n</li>\n<li>\n<p><code>find</code> ：搜索文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">find</span> /home/ <span class=\"token parameter variable\">-name</span> test.txt\t<span class=\"token comment\"># 根据文件名搜索</span></pre></td></tr></table></figure></li>\n<li>\n<p><code>ifconfig</code> ：产看网卡信息（IP 地址、子网掩码）</p>\n</li>\n<li>\n<p><code>ping</code> ：常用于检查网络连通性</p>\n</li>\n<li>\n<p><code>telnet</code> ：检查端口连通性</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>telnet <span class=\"token number\">192.168</span>.0.180 <span class=\"token number\">22</span>\t<span class=\"token comment\"># 检查 22 端口是否连通</span></pre></td></tr></table></figure></li>\n<li>\n<p><code>netstat</code> ：检查网络连接状况</p>\n</li>\n<li>\n<p><code>tcpdump</code> ：抓包分析工具</p>\n</li>\n<li>\n<p><code>ssh</code> ：远程连接主机</p>\n</li>\n<li>\n<p><code>wget</code> ：从远程下载文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> https://download/xxx.txt</pre></td></tr></table></figure></li>\n<li>\n<p><code>ps</code> ：产看进程</p>\n</li>\n<li>\n<p><code>kill</code> ：杀死进程</p>\n</li>\n<li>\n<p><code>shutdown</code> ：关机并关闭电源</p>\n</li>\n<li>\n<p><code>reboot</code> ：重启</p>\n</li>\n<li>\n<p><code>hostname</code> ：查看主机名</p>\n</li>\n<li>\n<p><code>top</code> ：查看当前进程的资源使用情况</p>\n</li>\n<li>\n<p><code>useradd</code> ：添加用户</p>\n</li>\n<li>\n<p><code>usermod</code> ：修改用户</p>\n</li>\n<li>\n<p><code>userdel</code> ：删除用户</p>\n</li>\n<li>\n<p><code>passwd</code> ：修改用户名的密码</p>\n</li>\n<li>\n<p><code>su</code> ：切换用户</p>\n</li>\n<li>\n<p><code>chmod</code> ：修改文件或目录的权限</p>\n</li>\n</ul>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "操作系统面试题",
            "date_published": "2024-03-13T01:21:27.470Z",
            "content_html": "<h1 id=\"操作系统面试题\"><a class=\"anchor\" href=\"#操作系统面试题\">#</a> 操作系统面试题</h1>\n<h2 id=\"主机启动\"><a class=\"anchor\" href=\"#主机启动\">#</a> 主机启动</h2>\n<blockquote>\n<p><code>BIOS</code> ：I/O 处理系统，开机时可以自动检测各种外设<br />\n <code>Bootloader</code> ：加载 OS</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.png\" alt=\"\" /></p>\n<h2 id=\"中断和异常的处理过程\"><a class=\"anchor\" href=\"#中断和异常的处理过程\">#</a> 中断和异常的处理过程</h2>\n<blockquote>\n<p>外中断是指由 CPU 执行指令以外的时间引起的，如 IO 完成中断、时钟中断；内中断（异常）是由 CPU 执行指令内部事件引起的，如地址越界、除 0、算术溢出等.</p>\n</blockquote>\n<ul>\n<li>\n<p>硬件</p>\n<blockquote>\n<ol>\n<li>设置中断标记</li>\n<li>操作系统根据这个标记（中断号）去找到对应的处理程序</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>软件</p>\n<blockquote>\n<ol>\n<li>保存现场：把当前执行程序的相关数据保存在寄存器中，然后入栈</li>\n<li>开中断：以便于响应优先级更高的中断请求</li>\n<li>中断服务程序处理</li>\n<li>关中断：保证恢复现场时不被中断</li>\n<li>恢复现场</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"系统调用\"><a class=\"anchor\" href=\"#系统调用\">#</a> 系统调用</h2>\n<blockquote>\n<p>应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用</p>\n<p><code>用户态</code> 转化到 <code>内核态</code></p>\n</blockquote>\n<h2 id=\"操作系统功能\"><a class=\"anchor\" href=\"#操作系统功能\">#</a> 操作系统功能</h2>\n<ul>\n<li>进程管理</li>\n<li>内存管理：负责管理内存的分配、回收。在进程创建时分配内存以及在进程结束时回收内存，协调内存资源</li>\n<li>设备管理</li>\n<li>文件管理</li>\n<li>提供用户接口</li>\n</ul>\n<h2 id=\"cpu内部结构\"><a class=\"anchor\" href=\"#cpu内部结构\">#</a> CPU 内部结构</h2>\n<ul>\n<li>计算逻辑单元 ALU</li>\n<li>寄存器</li>\n<li>控制器</li>\n<li>缓存</li>\n<li>内存管理单元 MMU</li>\n</ul>\n<h2 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">#</a> 进程与线程</h2>\n<blockquote>\n<ol>\n<li>进程的组成：\n<ul>\n<li>进程控制块 <code>PCB</code> （ <code>PID</code> ：唯一标识进程、进程状态、进程优先级、程序计数器 PC、内存指针\t）</li>\n<li>代码段</li>\n<li>程序段</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<ul>\n<li>进程是资源分配的基本单位，线程是资源调度的基本单位</li>\n<li>一个线程属于一个进程，每个进程可以包含多个不同的线程</li>\n<li>每个进程有多个线程组层，但只有一个主线程，它们共享内存空间（堆、全局变量），但是有各自的栈空间</li>\n<li>系统开销：</li>\n</ul>\n<blockquote>\n<p>进程切换：切换页表、切换内核栈和硬件上下文（进程切换之后，新程序的虚拟地址在 TLB 内失效，会导致频繁的访存）</p>\n</blockquote>\n<h2 id=\"进程调度算法\"><a class=\"anchor\" href=\"#进程调度算法\">#</a> 进程调度算法</h2>\n<ul>\n<li>先来先服务 <code>FCFS(First Come First Serverd)</code> ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）</li>\n<li>短作业优先 <code>SJF(Shortest Job First)</code> ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）</li>\n<li>最短剩余时间有优先</li>\n<li>时间片轮转</li>\n<li>优先级调度</li>\n<li>多级反馈队列</li>\n</ul>\n<h2 id=\"进程状态切换\"><a class=\"anchor\" href=\"#进程状态切换\">#</a> 进程状态切换</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg\" alt=\"\" title=\"进程状态切换\" /></p>\n<h2 id=\"进程间通信ipc方式\"><a class=\"anchor\" href=\"#进程间通信ipc方式\">#</a> 进程间通信 IPC 方式</h2>\n<blockquote>\n<p>两个或多个进程之间产生的数据交互</p>\n</blockquote>\n<ul>\n<li>管道：半双工通信，数据只能单向流动，而且往往是在父子进程关系中使用. (一种特殊的共享文件 <code>pipe</code> ，其实就是在内存中开辟的一块固定大小的缓冲区)</li>\n<li>共享内存：由一个进程创建，多个进程都可以访问的一段内存空间.</li>\n<li>消息队列</li>\n<li><code>Socket</code>  套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信</li>\n<li>信号</li>\n<li>信号量</li>\n</ul>\n<h2 id=\"进程同步的四种方式\"><a class=\"anchor\" href=\"#进程同步的四种方式\">#</a> 进程同步的四种方式</h2>\n<h2 id=\"多线程模型\"><a class=\"anchor\" href=\"#多线程模型\">#</a> 多线程模型</h2>\n<blockquote>\n<ul>\n<li>用户级线程</li>\n</ul>\n</blockquote>\n<h2 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h2>\n<blockquote>\n<p>两个或多个进程无期限的堵塞、互相等待的一种状态.</p>\n</blockquote>\n<ul>\n<li>\n<p>死锁的四个必要条件</p>\n<blockquote>\n<ol>\n<li>互传条件</li>\n<li>请求与保持条件</li>\n<li>不剥夺条件</li>\n<li>循环等待条件</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"连续内存分配\"><a class=\"anchor\" href=\"#连续内存分配\">#</a> 连续内存分配</h2>\n<ul>\n<li>\n<p>单一连续分配</p>\n<blockquote>\n<p>内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"单一连续分配\" /></p>\n</li>\n<li>\n<p>固定分区分配（无外部碎片，会产生内部碎片）</p>\n<blockquote>\n<ol>\n<li>分区大小相等（固定）：缺乏灵活性</li>\n<li>分区大小不等（固定）</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"固定分区分配\" /></p>\n</li>\n<li>\n<p>动态内存分配：不会预先划分内存空间</p>\n<blockquote>\n<ol>\n<li>首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区</li>\n<li>最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区</li>\n<li>最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区</li>\n<li>邻近适应算法： <code>首次适应算法</code> 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"空闲内存的管理方式\"><a class=\"anchor\" href=\"#空闲内存的管理方式\">#</a> 空闲内存的管理方式</h2>\n<ul>\n<li>空闲链表：</li>\n<li>位图：将内存划分为均等的分配单元，每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用；分配单元的大小是一个值得考量的问题，分配单元太小会使得位图占用的空间过大，如果分配单元过大，内造成内部碎片。当需要分配一定大小空间的内存时，需要遍历真个位图，依次检查，时间复杂度较高.</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png\" alt=\"\" /></p>\n<h2 id=\"内存紧缩与交换式碎片整理\"><a class=\"anchor\" href=\"#内存紧缩与交换式碎片整理\">#</a> 内存紧缩与交换式碎片整理</h2>\n<h2 id=\"非连续内存分配\"><a class=\"anchor\" href=\"#非连续内存分配\">#</a> 非连续内存分配</h2>\n<blockquote>\n<ol>\n<li>连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高</li>\n<li>非连续内存分配优点：\n<ul>\n<li>程序的物理地址空间是非连续的，更好的利用内存空间</li>\n<li>允许共享代码与数据</li>\n<li>支持动态加载和动态链接</li>\n</ul>\n</li>\n<li>非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>分段</p>\n<blockquote>\n<ol>\n<li>分段的寻址方式</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分段的寻址方式\" /></p>\n</li>\n<li>\n<p>分页</p>\n<blockquote>\n<ol>\n<li>逻辑页 <code>page</code>  和物理页 <code>frame(帧)</code>  的大小一致</li>\n<li>不是所有的页都有对应的帧</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分页寻址方式\" /></p>\n</li>\n<li>\n<p>分段与分页的区别</p>\n<blockquote>\n<ol>\n<li>分页对程序员是透明的，但是分段需要程序员显示的划分每个段</li>\n<li>页的大小不可改变，段的大小可动态变化</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"页表\"><a class=\"anchor\" href=\"#页表\">#</a> 页表</h2>\n<ul>\n<li>\n<p>标志位</p>\n<blockquote>\n<ol>\n<li>访问位：表示当前页之前是否被访问过</li>\n<li>修改位：表示当前页之前是否被修改过</li>\n<li>保护位：表示是否允许对该页做任何类型的操作（读、写、可执行等)</li>\n<li>驻留位：表示该页是在 <code>内存</code> 中还是在 <code>外存</code> 中</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>帧号</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt=\"\" title=\"页表结构\" /></p>\n<blockquote>\n<ul>\n<li>由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.</li>\n<li>时间优化：TLB</li>\n<li>空间优化：多级页表、反向页表</li>\n</ul>\n</blockquote>\n<h2 id=\"tlb\"><a class=\"anchor\" href=\"#tlb\">#</a> TLB</h2>\n<blockquote>\n<p><code>TLB(Translation Look-aside Buffer)</code> ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png\" alt=\"\" title=\"TLB\" /></p>\n<h2 id=\"多级页表\"><a class=\"anchor\" href=\"#多级页表\">#</a> 多级页表</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png\" alt=\"\" title=\"多级页表\" /></p>\n<h2 id=\"反向页表\"><a class=\"anchor\" href=\"#反向页表\">#</a> 反向页表</h2>\n<h2 id=\"覆盖技术\"><a class=\"anchor\" href=\"#覆盖技术\">#</a> 覆盖技术</h2>\n<blockquote>\n<p>需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</p>\n</blockquote>\n<h2 id=\"交换技术\"><a class=\"anchor\" href=\"#交换技术\">#</a> 交换技术</h2>\n<blockquote>\n<p>以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</p>\n</blockquote>\n<h2 id=\"虚拟技术\"><a class=\"anchor\" href=\"#虚拟技术\">#</a> 虚拟技术</h2>\n<blockquote>\n<p>虚拟技术是把一个物理实体转化为多个逻辑实体</p>\n</blockquote>\n<ul>\n<li>\n<p>时空复用技术</p>\n<blockquote>\n<p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU</p>\n</blockquote>\n</li>\n<li>\n<p>空分复用技术</p>\n<blockquote>\n<p>虚拟内存：将物理内存抽象为地址空间，每个进程都有各自的地址空间.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"虚拟内存\"><a class=\"anchor\" href=\"#虚拟内存\">#</a> 虚拟内存</h2>\n<blockquote>\n<ol>\n<li>将物理空间扩充为更大的逻辑空间</li>\n<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行</li>\n<li>在程序执行过程中，如果执行的指令或访问的数据不在内存中（ <code>缺页</code> 或 <code>缺段</code> ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序</li>\n<li>另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序</li>\n</ol>\n</blockquote>\n<h2 id=\"缺页中断处理过程\"><a class=\"anchor\" href=\"#缺页中断处理过程\">#</a> 缺页中断处理过程</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"页面置换算法\"><a class=\"anchor\" href=\"#页面置换算法\">#</a> 页面置换算法</h2>\n<blockquote>\n<p>当缺页中断发生时，需要调入新的页面而内存已满时，选择内存当中那个物理页面进行替换（更可能减少换入换出的次数）</p>\n</blockquote>\n<ol>\n<li>最优页面置换算法：将未来最久不会被访问的页面置换出去（理想情况）</li>\n<li>先进先出算法</li>\n<li>最近最久未使用 <code>LRU,Least Recently Used</code></li>\n<li>时钟页面置换算法</li>\n<li>二次机会法</li>\n<li>最不常用算法 <code>LFU,Least Frequently Used</code></li>\n</ol>\n<blockquote>\n<p><code>Belady</code>  现象：分配的物理页面数增加，缺页率反而提高的异常现象（没有考虑进程访问的动态特征导致的， <code>FIFO</code> ）</p>\n</blockquote>\n<h2 id=\"虚拟地址转换位物理地址的过程\"><a class=\"anchor\" href=\"#虚拟地址转换位物理地址的过程\">#</a> 虚拟地址转换位物理地址的过程</h2>\n<h2 id=\"磁盘调度算法\"><a class=\"anchor\" href=\"#磁盘调度算法\">#</a> 磁盘调度算法</h2>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==\">王道计算机考研 操作系统_哔哩哔哩_bilibili</span></li>\n<li>[2] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">清华 操作系统原理_哔哩哔哩_bilibili</span></li>\n<li>[3] <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODA4NzI5MjA=\">操作系统常见面试题</span></li>\n<li>[4] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE1OTY1\">这 50 道操作系统面试题，真牛批！</span></li>\n</ul>\n",
            "tags": [
                "面试题",
                "操作系统"
            ]
        }
    ]
}
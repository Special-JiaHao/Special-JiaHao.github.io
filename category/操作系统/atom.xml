<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>繁華落盡 似水流年 • Posts by &#34;操作系统&#34; category</title>
    <link href="http://example.com" />
    <updated>2024-03-13T01:21:27.470Z</updated>
    <category term="mathematics" />
    <category term="语法" />
    <category term="C++" />
    <category term="VMware" />
    <category term="项目构建工具" />
    <category term="install" />
    <category term="数据库" />
    <category term="STL" />
    <category term="CNN" />
    <category term="Project" />
    <category term="面试题" />
    <category term="日常" />
    <category term="校招" />
    <category term="算法" />
    <category term="Leetcode双周赛" />
    <entry>
        <id>http://example.com/value/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98</id>
        <title>操作系统面试题</title>
        <link rel="alternate" href="http://example.com/value/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98"/>
        <content type="html">&lt;h1 id=&#34;操作系统面试题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作系统面试题&#34;&gt;#&lt;/a&gt; 操作系统面试题&lt;/h1&gt;
&lt;h2 id=&#34;主机启动&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主机启动&#34;&gt;#&lt;/a&gt; 主机启动&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;BIOS&lt;/code&gt; ：I/O 处理系统，开机时可以自动检测各种外设&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bootloader&lt;/code&gt; ：加载 OS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;中断和异常的处理过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#中断和异常的处理过程&#34;&gt;#&lt;/a&gt; 中断和异常的处理过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;设置中断标记&lt;/li&gt;
&lt;li&gt;操作系统根据这个标记（中断号）去找到对应的处理程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;保存现场&lt;/li&gt;
&lt;li&gt;中断服务程序处理&lt;/li&gt;
&lt;li&gt;清除中断标记&lt;/li&gt;
&lt;li&gt;恢复现场&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#系统调用&#34;&gt;#&lt;/a&gt; 系统调用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用户态&lt;/code&gt; 转化到 &lt;code&gt;内核态&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cpu内部结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu内部结构&#34;&gt;#&lt;/a&gt; CPU 内部结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算逻辑单元 ALU&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;内存管理单元 MMU&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程与线程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程与线程&#34;&gt;#&lt;/a&gt; 进程与线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程是资源分配的基本单位，线程是资源调度的基本单位&lt;/li&gt;
&lt;li&gt;一个线程属于一个进程，每个进程可以包含多个不同的线程&lt;/li&gt;
&lt;li&gt;每个进程有多个线程组层，但只有一个主线程，它们共享内存空间（堆、全局变量），但是有各自的栈空间&lt;/li&gt;
&lt;li&gt;系统开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程调度算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程调度算法&#34;&gt;#&lt;/a&gt; 进程调度算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务 &lt;code&gt;FCFS(First Come First Serverd)&lt;/code&gt; ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）&lt;/li&gt;
&lt;li&gt;短作业优先 &lt;code&gt;SJF(Shortest Job First)&lt;/code&gt; ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）&lt;/li&gt;
&lt;li&gt;时间片轮转&lt;/li&gt;
&lt;li&gt;优先级调度&lt;/li&gt;
&lt;li&gt;多级反馈队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程间通信方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程间通信方式&#34;&gt;#&lt;/a&gt; 进程间通信方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信&lt;/li&gt;
&lt;li&gt;信号：&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程同步的四种方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程同步的四种方式&#34;&gt;#&lt;/a&gt; 进程同步的四种方式&lt;/h2&gt;
&lt;h2 id=&#34;连续内存分配&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#连续内存分配&#34;&gt;#&lt;/a&gt; 连续内存分配&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单一连续分配&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png&#34; alt=&#34;&#34; title=&#34;单一连续分配&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定分区分配（无外部碎片，会产生内部碎片）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;分区大小相等（固定）：缺乏灵活性&lt;/li&gt;
&lt;li&gt;分区大小不等（固定）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png&#34; alt=&#34;&#34; title=&#34;固定分区分配&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态内存分配：不会预先划分内存空间&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区&lt;/li&gt;
&lt;li&gt;最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区&lt;/li&gt;
&lt;li&gt;最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区&lt;/li&gt;
&lt;li&gt;邻近适应算法： &lt;code&gt;首次适应算法&lt;/code&gt; 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何记录内存的使用情况&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何记录内存的使用情况&#34;&gt;#&lt;/a&gt; 如何记录内存的使用情况&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空闲分区表&lt;/li&gt;
&lt;li&gt;空闲分区链&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存紧缩与交换式碎片整理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存紧缩与交换式碎片整理&#34;&gt;#&lt;/a&gt; 内存紧缩与交换式碎片整理&lt;/h2&gt;
&lt;h2 id=&#34;非连续内存分配&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#非连续内存分配&#34;&gt;#&lt;/a&gt; 非连续内存分配&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高&lt;/li&gt;
&lt;li&gt;非连续内存分配优点：
&lt;ul&gt;
&lt;li&gt;程序的物理地址空间是非连续的，更好的利用内存空间&lt;/li&gt;
&lt;li&gt;允许共享代码与数据&lt;/li&gt;
&lt;li&gt;支持动态加载和动态链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分段&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;分段的寻址方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;&#34; title=&#34;分段的寻址方式&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分页&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;逻辑页 &lt;code&gt;page&lt;/code&gt;  和物理页 &lt;code&gt;frame(帧)&lt;/code&gt;  的大小一致&lt;/li&gt;
&lt;li&gt;不是所有的页都有对应的帧&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png&#34; alt=&#34;&#34; title=&#34;分页寻址方式&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#页表&#34;&gt;#&lt;/a&gt; 页表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标志位&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;访问位&lt;/li&gt;
&lt;li&gt;修改位&lt;/li&gt;
&lt;li&gt;保护位：&lt;/li&gt;
&lt;li&gt;驻留位：表示该页是在 &lt;code&gt;内存&lt;/code&gt; 中还是在 &lt;code&gt;外存&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帧号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png&#34; alt=&#34;&#34; title=&#34;页表结构&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.&lt;/li&gt;
&lt;li&gt;时间优化：TLB&lt;/li&gt;
&lt;li&gt;空间优化：多级页表、反向页表&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tlb&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tlb&#34;&gt;#&lt;/a&gt; TLB&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TLB(Translation Look-aside Buffer)&lt;/code&gt; ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png&#34; alt=&#34;&#34; title=&#34;TLB&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;多级页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多级页表&#34;&gt;#&lt;/a&gt; 多级页表&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png&#34; alt=&#34;&#34; title=&#34;多级页表&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;反向页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反向页表&#34;&gt;#&lt;/a&gt; 反向页表&lt;/h2&gt;
&lt;h2 id=&#34;覆盖技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#覆盖技术&#34;&gt;#&lt;/a&gt; 覆盖技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;交换技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交换技术&#34;&gt;#&lt;/a&gt; 交换技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;虚拟技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟技术&#34;&gt;#&lt;/a&gt; 虚拟技术&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟技术是把一个物理实体转化为多个逻辑实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时空复用技术&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空分复用技术&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟内存：将物理内存抽象为地址空间，每个进程都有各自的地址空间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟内存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟内存&#34;&gt;#&lt;/a&gt; 虚拟内存&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行&lt;/li&gt;
&lt;li&gt;在程序执行过程中，如果执行的指令或访问的数据不在内存中（ &lt;code&gt;缺页&lt;/code&gt; 或 &lt;code&gt;缺段&lt;/code&gt; ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序&lt;/li&gt;
&lt;li&gt;另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;页面置换算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#页面置换算法&#34;&gt;#&lt;/a&gt; 页面置换算法&lt;/h2&gt;
&lt;h2 id=&#34;进程状态切换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程状态切换&#34;&gt;#&lt;/a&gt; 进程状态切换&lt;/h2&gt;
&lt;h2 id=&#34;虚拟地址转换位物理地址的过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟地址转换位物理地址的过程&#34;&gt;#&lt;/a&gt; 虚拟地址转换位物理地址的过程&lt;/h2&gt;
&lt;h2 id=&#34;磁盘调度算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#磁盘调度算法&#34;&gt;#&lt;/a&gt; 磁盘调度算法&lt;/h2&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考资料&#34;&gt;#&lt;/a&gt; 参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==&#34;&gt;王道计算机考研 操作系统_哔哩哔哩_bilibili&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=&#34;&gt;清华 操作系统原理_哔哩哔哩_bilibili&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="面试题" />
        <updated>2024-03-13T01:21:27.470Z</updated>
    </entry>
</feed>

<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>繁華落盡 似水流年 • Posts by &#34;cpp面试题&#34; category</title>
        <link>http://example.com</link>
        <description>编程日记 &amp; 随笔</description>
        <language>en</language>
        <pubDate>Fri, 08 Mar 2024 21:53:12 +0800</pubDate>
        <lastBuildDate>Fri, 08 Mar 2024 21:53:12 +0800</lastBuildDate>
        <category>mathematics</category>
        <category>语法</category>
        <category>C++</category>
        <category>VMware</category>
        <category>install</category>
        <category>数据库</category>
        <category>STL</category>
        <category>CNN</category>
        <category>Project</category>
        <category>面试题</category>
        <category>日常</category>
        <category>校招</category>
        <category>算法</category>
        <category>Leetcode双周赛</category>
        <category>Algorithm</category>
        <category>Leetcode周赛</category>
        <category>设计模式</category>
        <category>多线程</category>
        <category>池化技术</category>
        <category>MySQL</category>
        <category>操作系统</category>
        <category>计算机网络</category>
        <category>CMake</category>
        <category>线程池</category>
        <category>Go</category>
        <category>Redis</category>
        <category>Linux</category>
        <category>json</category>
        <category>Python</category>
        <category>牛客</category>
        <category>Git</category>
        <category>normalization</category>
        <category>推理加速</category>
        <category>LLM</category>
        <category>AI算法</category>
        <category>Pytorch</category>
        <category>激活函数</category>
        <item>
            <guid isPermalink="true">http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/C++%E9%9D%A2%E8%AF%95%E9%A2%98</guid>
            <title>C++面试题</title>
            <link>http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/C++%E9%9D%A2%E8%AF%95%E9%A2%98</link>
            <category>C++</category>
            <category>面试题</category>
            <pubDate>Fri, 08 Mar 2024 21:53:12 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;c面试题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c面试题&#34;&gt;#&lt;/a&gt; C++ 面试题&lt;/h1&gt;
&lt;h2 id=&#34;程序编译过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#程序编译过程&#34;&gt;#&lt;/a&gt; 程序编译过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预处理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成宏定义 &lt;code&gt;#define&lt;/code&gt;  内容替换&lt;/li&gt;
&lt;li&gt;处理所有的条件预编译指令，如 &lt;code&gt;#if #endif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把 &lt;code&gt;#include&lt;/code&gt;  文件内容复制到 &lt;code&gt;.cpp&lt;/code&gt;  文件中（递归执行）&lt;/li&gt;
&lt;li&gt;删除所有注释&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译：转化为汇编代码，主要工作是检查一些语法规则，代码优化（寻找合适的寻址方式，使用位运算来替代乘法运算，删除多余的指令）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编：将汇编代码转化为二进制格式的文件（机器码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接：将多个目标文件以及库文件链接成最终的可执行文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态链接：在链接阶段将库文件的函数和数据合并到应用程序中，组成一个最终的可执行文件.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运行速度快：可执行程序中具备运行阶段所需要的所以东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间浪费：可执行程序中有所以目标文件的副本。当多个程序对同一个目标文件有依赖关系时，那么这个目标文件在内存中会有多个副本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当其中一个库文件需要修改，整个程序需要重新编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态链接：在程序运行阶段才把多个目标文件链接成一个完整的程序.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运行效率会有所损耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;节省空间：共享库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新方便：只需要重新编译修改的目标文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cc内存空间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cc内存空间&#34;&gt;#&lt;/a&gt; C/C++ 内存空间&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4C.jpg&#34; alt=&#34;&#34; width=&#34;200px&#34; /&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png&#34; alt=&#34;&#34; width=&#34;200px&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈：用于存储局部变量，由编译器自动管理分配与释放，效率很高，但是内存有限&lt;/li&gt;
&lt;li&gt;堆：动态内存空间，由应用程序去控制。如若程序结束没有释放，则会由操作系统自动回收.&lt;/li&gt;
&lt;li&gt;代码区：存放函数体二进制代码&lt;/li&gt;
&lt;li&gt;全局 / 静态存储区：用于存储全局变量和静态变量。在以前 C 语言中，这部分分为初始化的 &lt;code&gt;.data&lt;/code&gt;  和未初始化 &lt;code&gt;.bss&lt;/code&gt; . 现在 C++ 中则没有这样的划分，区域内的变量会被默认初始化为 0.&lt;/li&gt;
&lt;li&gt;常量存储区：用于存储常量，不允许修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;堆与栈&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#堆与栈&#34;&gt;#&lt;/a&gt; 堆与栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;栈内存是由编译器自动管理的，堆可由程序员控制，对于开辟的内存需要主动释放，否则容易产生内存泄漏&lt;/li&gt;
&lt;li&gt;栈的内存增长方向是向着地址空间减小的方向，堆内存的增长方向是朝着地址空间增大的方向.&lt;/li&gt;
&lt;li&gt;栈分配的内存都是连续空间，同时是一个先进后出的数据结构，其不存在内存碎片的问题。堆所分配的内存空间不一定连续，会存在内存碎片的问题&lt;/li&gt;
&lt;li&gt;栈的分配效率要高于堆的分配效率。操作系统内有专门的寄存器用于存储栈的地址和栈顶指针地址。堆的内存分配是调用 C/C++ 的库函数，分配空间时还需要按照不同的算法去搜索足够大的空间进行分配。同时由于内存碎片问题，操作系统会进行内存紧缩的操作，需要额外的系统开销.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数调用的过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数调用的过程&#34;&gt;#&lt;/a&gt; 函数调用的过程&lt;/h2&gt;
&lt;h2 id=&#34;计算机内部数据的存储&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算机内部数据的存储&#34;&gt;#&lt;/a&gt; 计算机内部数据的存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整数：通过补码的形式进行存储（整数的补码是本省，负数的补码是取反 + 1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float&lt;/code&gt;  的存储，遵循 &lt;code&gt;IEEE&lt;/code&gt;  规范，占用 32 位（4 字节）.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;符号位（1bit）&lt;/li&gt;
&lt;li&gt;指数位（8bit）&lt;/li&gt;
&lt;li&gt;尾数部分（23bit）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/float%E7%9A%84%E5%AD%98%E5%82%A8.webp&#34; alt=&#34;&#34; title=&#34;float的存储&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt;  的存储，遵循 &lt;code&gt;IEEE&lt;/code&gt;  规范，占用 64 位（8 字节）.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;符号位（1bit）&lt;/li&gt;
&lt;li&gt;指数位（11bit）&lt;/li&gt;
&lt;li&gt;尾数部分（52bit）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/double%E7%9A%84%E5%AD%98%E5%82%A8.jpg&#34; alt=&#34;&#34; title=&#34;double的存储&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;static&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#static&#34;&gt;#&lt;/a&gt; static&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰局部变量：改变变量的存储位置（由栈区转移到静态存储区），延长了变量的生命周期； &lt;code&gt;static&lt;/code&gt;  局部变量只在当前的作用域内有效，在作用外无法访问.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰全局变量：只能在当前源文件内有效，在其他源文件内无法访问. （无 &lt;code&gt;static&lt;/code&gt;  修饰的全局变量可以在其他源文件中使用 extern 申明其他源文件中的全局变量，即可在当前源文件中使用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰函数：和 &lt;code&gt;static&lt;/code&gt;  用于修饰全局变量具有一样的特性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰成员变量：静态成员变量，为类所以，可供所以对象共享，不占用实例的存储空间，同时其初始化必须定义外类外部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰成员函数：静态成员函数，没有隐藏的 &lt;code&gt;this&lt;/code&gt;  指针，因此函数体内不能访问该类的非静态成员变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;  修饰的变量默认初始化为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;const&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#const&#34;&gt;#&lt;/a&gt; const&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;  修饰的变量值不可变修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;  成员变量：不能在类外初始化，只能通过构造函数初始化列表进行初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;  修饰的函数为常函数，不能改变类的成员变量（可以修改被 &lt;code&gt;mutable&lt;/code&gt;  修饰的变量）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;  对象不能调用非 &lt;code&gt;const&lt;/code&gt;  成员函数（防止类的非常函数对 &lt;code&gt;const&lt;/code&gt;  对象的成员变量进行修改）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mutable&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mutable&#34;&gt;#&lt;/a&gt; mutable&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mutable&lt;/code&gt;  与 &lt;code&gt;const&lt;/code&gt;  是相对的，表示一个变量的易变的；被 &lt;code&gt;mutable&lt;/code&gt;  修饰是成员变量可以再 &lt;code&gt;const&lt;/code&gt;  修饰的函数内被修改（也可以被常对象进行直接修改）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;explicit&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#explicit&#34;&gt;#&lt;/a&gt; explicit&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;用于修饰类的构造函数，防止其他对象隐式的转化为该类对象，只能显示的进行类型转化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;volatile&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt; volatile&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于修饰变量，表示其值随时可能发送变化，编译器不会对访问该变量的代码进行优化，可以保证访问变量的稳定（从内存中读取）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;  指针&lt;/li&gt;
&lt;li&gt;多线程下的 &lt;code&gt;volatile&lt;/code&gt; ：当多个线程都需要用到某一个变量时，应该用 &lt;code&gt;volatile&lt;/code&gt; ，防止编译器把变量从内存装入 CPU 寄存器中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;extern&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#extern&#34;&gt;#&lt;/a&gt; extern&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于变量的声明（不分配内存空间，不用赋予初值）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当我们需要再 A 文件中使用 B 文件的中的函数或者全局变量的时候，有两种做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;include&lt;/code&gt;  将 B 的头文件导入进 A 文件中，可能存在递归导入很多无关紧要的函数或变量，其会导致程序的编译（预编译）变慢&lt;/li&gt;
&lt;li&gt;在 A 文件中 &lt;code&gt;extern&lt;/code&gt;  所需要使用的 B 文件的函数或变量，在 &lt;code&gt;makefile&lt;/code&gt;  时将他们的 &lt;code&gt;.o&lt;/code&gt;  文件放在一起做 &lt;code&gt;link&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c三大特性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c三大特性&#34;&gt;#&lt;/a&gt; C++ 三大特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;封装、继承、多态（封装和继承可以实现 &lt;code&gt;代码的重用&lt;/code&gt; ，多态可以实现 &lt;code&gt;接口的重用&lt;/code&gt; ）
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;封装：将数据和实现过程包裹起来，隐藏代码的实现细节，通过定义的接口来访问数据成员，使代码模块化. (直接体现面向对象，代码重用，权限控制)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt; ：公有权限，类内可以访问，类外也可以访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt; ：保护权限，类内可以访问，类外不可以访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt; ：私有权限，类内可以访问，类外不可以访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承：无需重新编写代码而可以直接使用现有类的所以功能，同时可以对现有类进行功能上的扩展，是一个从一般到特殊的过程.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权限继承：表示基类在子类中的最高权限（破坏继承： &lt;code&gt;friend&lt;/code&gt; ，  &lt;code&gt;using&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;多继承：通过多继承可以得到更多类的数据和方法，实现更大程度的代码复用，当然也存在一些问题，如菱形继承.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多态：通过父类指针指向多个派生的子类对象时，调用父类的一个接口，可以实现多种不同的行为即为多态.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被 &lt;code&gt;virtual&lt;/code&gt;  修饰的成员函数即为虚函数，如基类的虚函数为空即为纯虚函数，这个类即可为抽象类，不能被实例化，否则就是一个虚类，可被实例化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在编译阶段，虚类内会隐藏的存储一个虚函数表指针的成员变量，指向一张虚函数表（存储在全局 / 静态存储区）该类的所以对象共用这张虚函数表.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;派生类继承虚类时，其会复制一份父类的虚函数表，类内的虚函数指针指向这张新的虚函数表，如派生类重写了虚函数则会将对应的虚函数表对应的指针项做一个修改，如果派生类定义了新的虚函数，则会在新的虚函数表后追加新的函数与地址的映射. （如若派生类继承了多个父类，即多继承，那么这个派生类可能存储多个虚函数表指针）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚析构函数：基类中析构函数前使用 &lt;code&gt;virtual&lt;/code&gt;  修饰。当基类指针指向派生类对象时，使用基类指针去释放空间时，则会去先调用派生类的析构函数，再去调用基类的析构函数；若不加 &lt;code&gt;virtual&lt;/code&gt;  则不会触发动态绑定（多态），只会调用基类的析构函数，导致内存泄漏. (虽然虚构函数名不一样，其实也是一种重写，系统内部对析构函数做了特殊处理，将析构函数名称都改成了 &lt;code&gt;destructor&lt;/code&gt; )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚函数地址在运行时绑定（函数地址在运行阶段确定），使用了虚函数表的机制，所以在调用的时候会增加一次内存开销. （虚函数的缺点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协变：基类和派生类虚函数的返回值不同（基类返回基类对象的指针或引用，派生类返回派生类对象的指针或引用），其也是一种多态&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;iostream&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;namespace&lt;/span&gt; std&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;virtual&lt;/span&gt; User &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;return user&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;Manager&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token base-clause&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;User&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;virtual&lt;/span&gt; Manager &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;return manager&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    Manager mg&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    User&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;mg&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    ptr&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚函数与纯虚函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚函数与纯虚函数&#34;&gt;#&lt;/a&gt; 虚函数与纯虚函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;纯虚函数是在基类中声明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;菱形继承&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#菱形继承&#34;&gt;#&lt;/a&gt; 菱形继承&lt;/h2&gt;
&lt;h2 id=&#34;为什么c默认析构函数不是虚函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为什么c默认析构函数不是虚函数&#34;&gt;#&lt;/a&gt; 为什么 C++ 默认析构函数不是虚函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虚函数需要虚函数表和虚函数表指针，会占用内存空间。如果一个类没有子类，那么就没有必要将析构函数设置为虚函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重载-重写-重定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重载-重写-重定义&#34;&gt;#&lt;/a&gt; 重载、重写、重定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重载：多个同名函数，他们的参数个数或者参数类型不同；（编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就变成了不同的函数），也可以称之为静态多态，函数地址在编译器就已经确定了&lt;/li&gt;
&lt;li&gt;重定义：继承中的同名隐藏，当派生类中有一个函数与基类的函数名相同，不管参数是否相同，只要该函数不为虚函数，发生了重定义.&lt;/li&gt;
&lt;li&gt;重写：派生类中重写了基类的虚函数，其中函数名、参数列表和返回值都相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;final和override&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final和override&#34;&gt;#&lt;/a&gt; final 和 override&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;final&lt;/code&gt; ：修饰虚函数，表示该虚函数不能再被重写。修饰类表示该类不能被继承&lt;/li&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt; ：检查派生类虚函数是否重写了基类的某个虚函数，如果没有则编译器报错；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;struct-与class&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#struct-与class&#34;&gt;#&lt;/a&gt; struct 与 class&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ 中的 &lt;code&gt;struct&lt;/code&gt;  默认 &lt;code&gt;public&lt;/code&gt;  共有权限， &lt;code&gt;class&lt;/code&gt;  默认 &lt;code&gt;private&lt;/code&gt;  私有权限&lt;/li&gt;
&lt;li&gt;C 语言中的 &lt;code&gt;struct&lt;/code&gt;  只是一个变量的集合体，只可以用于封装数据，而不备面向对象的一些特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;struct-与-union&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#struct-与-union&#34;&gt;#&lt;/a&gt; struct 与 union&lt;/h2&gt;
&lt;h2 id=&#34;new-和-malloc的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#new-和-malloc的区别&#34;&gt;#&lt;/a&gt; new 和 malloc 的区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;  和 &lt;code&gt;malloc&lt;/code&gt;  都是用于分配内存的，其中 &lt;code&gt;new&lt;/code&gt;  是 C++ 中的操作符，可以被重载， &lt;code&gt;malloc&lt;/code&gt;  是 C 语言中的库函数，不可以被重载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数不同；new 可以自动计算所分配的对象的内存大小，同时返回值为指向该对象的指针. malloc 则需要传入需要分配的内存的字节数，返回一个 &lt;code&gt;void *&lt;/code&gt;  指针&lt;/li&gt;
&lt;li&gt;new 分配失败会抛出异常 &lt;code&gt;bac_alloc&lt;/code&gt; ，malloc 分配失败会返回 &lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;new 分配的内存在 &lt;code&gt;free store&lt;/code&gt; （自由存储区）上，malloc 分配的内存在堆上（其中自由存储区是 C++ 中的一个抽象的概念，new 的底层调用的逻辑是先调用 &lt;code&gt;operator new&lt;/code&gt;  分配内存，由系统决定或者用户重载 &lt;code&gt;operator new&lt;/code&gt;  决定，其次是调用对象的构造函数，初始化成员变量）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;  分配的内存是虚拟内存，而 &lt;code&gt;new&lt;/code&gt;  分配的内存是物理内存。因为 new 调用了对象的构造函数，对对象成员进行了初始化（发生了缺页中断，使得虚拟内存映射到了物理内存）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;delete-与-free&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#delete-与-free&#34;&gt;#&lt;/a&gt; delete 与 free&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;delete&lt;/code&gt;  和 &lt;code&gt;free&lt;/code&gt;  都是用于释放内存的，其中 &lt;code&gt;delete&lt;/code&gt;  是 C++ 中的操作符，可以被重载，free 是 C 语言中的库函数，不可以被重载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数不同；delete 需要给出释放的对象的类型指针，free 可以是 &lt;code&gt;void *&lt;/code&gt;  类型的指针（delete 底层调用的逻辑是先调用对象的析构函数，再调用 &lt;code&gt;operator delete&lt;/code&gt;  释放对象所占内存）（free 只需要提供 &lt;code&gt;void *&lt;/code&gt;  就可以释放申请的所以内存： &lt;code&gt;malloc&lt;/code&gt;  在分配内存时，不仅仅是分配了用户所需要的内存空间的大小，还会在该空间上部分配额外的一部分空间用于存储此次分配的内存的描述信息）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意： &lt;code&gt;delete&lt;/code&gt;  和 &lt;code&gt;free&lt;/code&gt;  被调用后，指针也不会指向空，如果没有其他用途，需要把它设置为 &lt;code&gt;nullptr&lt;/code&gt; ，否则会出现野指针.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;free回收的内存是立即返回给操作系统吗&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#free回收的内存是立即返回给操作系统吗&#34;&gt;#&lt;/a&gt; free 回收的内存是立即返回给操作系统吗？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不是的。被 &lt;code&gt;free&lt;/code&gt;  回收的内存会被 &lt;code&gt;ptmalloc&lt;/code&gt;  使用双链表保存起来，当用户下一次申请内存空间的时候，会尝试先从这些内存中寻找合适的返回.&lt;/li&gt;
&lt;li&gt;可以避免频繁的系统调用，提高程序效率.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ptmalloc&lt;/code&gt;  也会尝试对小块进行合并，避免过多的内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; is the second major version of C++ and the most important update since C&lt;ins&gt;98. A large number of changes were introduced to both standardize existing practices and improve the abstractions available to the C&lt;/ins&gt; programmers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;new与delete&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#new与delete&#34;&gt;#&lt;/a&gt; new [] 与 delete []&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new[]&lt;/code&gt;  会先调用 &lt;code&gt;operateor new[]&lt;/code&gt;  分配内存，然后再分配的内存的前几个字节写入数组的大小，然后进行 n 次构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;malloc与free实现原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#malloc与free实现原理&#34;&gt;#&lt;/a&gt; malloc 与 free 实现原理&lt;/h2&gt;
&lt;h2 id=&#34;c中的几种new&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c中的几种new&#34;&gt;#&lt;/a&gt; C++ 中的几种 new&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; ： &lt;code&gt;plain new&lt;/code&gt; ，分配内存失败会抛出异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nothrow new&lt;/code&gt; ：分配内存失败不抛出异常，而是返回 &lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;placement new&lt;/code&gt; ：不会分配内存，在已有的内存空间上重新构造对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c强制类型转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c强制类型转换&#34;&gt;#&lt;/a&gt; C++ 强制类型转换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;static_cast&amp;lt;T&amp;gt;()&lt;/code&gt; ：不进行类型检查，不安全&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;用于层次结构中基类与派生类间指针的转换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 上行转换（派生类指针转化为基类指针），安全&lt;/p&gt;
&lt;p&gt;b. 下行转化（基类指针转化为派生类指针），不安全&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;基本数据类型的转化&lt;/li&gt;
&lt;li&gt;将空指针转化为目标类型的指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; ：专门用于派生类与基类之间的类型转化，基类中必须有虚函数；会进行类型的检查，是一种安全类型转化（转换失败，指针为 &lt;code&gt;nullptr&lt;/code&gt; ）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;运行时会进行类型的检查&lt;/li&gt;
&lt;li&gt;不能用于内置基本数据类型的转化&lt;/li&gt;
&lt;li&gt;如果转化成功的话会返回指向类的指针或引用，转换失败的话则会返回 &lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt; ：转化过程仅仅是简单的比特位拷贝，不安全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const_cast&amp;lt;T&amp;gt;()&lt;/code&gt; ：用于修改变量的 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  属性，变量类型与转换后的类型一致（只能修改底层 &lt;code&gt;const&lt;/code&gt; ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指针与引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指针与引用&#34;&gt;#&lt;/a&gt; 指针与引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储的是一个地址；而引用只是变量的别名.&lt;/li&gt;
&lt;li&gt;指针可不进行初始化，也可以指向空，并且指向可以改变；引用必须初始化，且只可绑定一个变量。这也导致了在使用指针时，往往需要判空操作，而引用是一种安全的指针，一定不为空（引用的底层是通过指针来实现）.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;  指针得到的是指针的大小， &lt;code&gt;sizeof&lt;/code&gt;  引用得到的是引用绑定对象的大小&lt;/li&gt;
&lt;li&gt;指针可以是多级的，引用只有一级&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常引用&#34;&gt;#&lt;/a&gt; 常引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保护传递给函数的数据在函数内不被改变.  &lt;code&gt;const 类型&amp;amp; 引用名&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 C++ 中，临时对象都是 &lt;code&gt;const&lt;/code&gt;  类型的，const 类型的对象转换为非 const 类型是非法的.&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;string &lt;span class=&#34;token function&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;string &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;s&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	    &lt;span class=&#34;token comment&#34;&gt;//  非法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;hello world&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;token comment&#34;&gt;// 非法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;野指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#野指针&#34;&gt;#&lt;/a&gt; 野指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;野指针：指向已被释放的内存空间或者指向没有访问权限的内存空间&lt;/li&gt;
&lt;li&gt;指针未被初始化、内存释放后未将指针设置为 &lt;code&gt;nullptr&lt;/code&gt; 、指针超过了变量的作用范围（越界）都可能导致野指针的产生&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c中的顶层const与底层const&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c中的顶层const与底层const&#34;&gt;#&lt;/a&gt; C++ 中的顶层 const 与底层 const&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;顶层const&lt;/code&gt; ： &lt;code&gt;const&lt;/code&gt;  修饰的变量本身是一个常量，无法修改；（指的是指针，出现在 &lt;code&gt;*&lt;/code&gt;  的右边）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;底层const&lt;/code&gt; ： &lt;code&gt;const&lt;/code&gt;  修饰的变量所指向的对象是一个常量（出现在 &lt;code&gt;*&lt;/code&gt;  左边）&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;				&lt;span class=&#34;token comment&#34;&gt;// 顶层 const&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; other b &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;				&lt;span class=&#34;token comment&#34;&gt;//other 类型为 int&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;/* --------------- */&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; b &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	          &lt;span class=&#34;token comment&#34;&gt;// 底层 const, 常量指针，表示指针所指向的内容无法通过该指针进行修改，但是可以改变指针的指向&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		          &lt;span class=&#34;token comment&#34;&gt;//other1 类型为 const int*&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		              &lt;span class=&#34;token comment&#34;&gt;// error! &lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;b&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;			    	 &lt;span class=&#34;token comment&#34;&gt;// right!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ptr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		  &lt;span class=&#34;token comment&#34;&gt;//other2 类型为 const int *&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		              &lt;span class=&#34;token comment&#34;&gt;// error! &lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;b&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;			    	 &lt;span class=&#34;token comment&#34;&gt;// right!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;/* --------------- */&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; b &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	         &lt;span class=&#34;token comment&#34;&gt;// 顶层 const，指针常量，表示指针是一个常量，不可修改指针的指向，但是可以通过指针去修改所指向空间的内容&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		        &lt;span class=&#34;token comment&#34;&gt;//other1 类型为 int *&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		            &lt;span class=&#34;token comment&#34;&gt;// right!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;other1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;b&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		   		   &lt;span class=&#34;token comment&#34;&gt;// right!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ptr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;token comment&#34;&gt;//other2 的类型为 int* const&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                   &lt;span class=&#34;token comment&#34;&gt;// right!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;other2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;b&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                    &lt;span class=&#34;token comment&#34;&gt;// error!&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量指针与指针常量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常量指针与指针常量&#34;&gt;#&lt;/a&gt; 常量指针与指针常量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常量指针： &lt;code&gt;int const* p = a&lt;/code&gt; ，指针的指向可以改变，而不能通过该指针去改变所指向的内容&lt;/li&gt;
&lt;li&gt;指针常量： &lt;code&gt;int *const p = a&lt;/code&gt; ，指针的指向不可改变，可以通过指针去改变指向的内容.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组指针与指针数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数组指针与指针数组&#34;&gt;#&lt;/a&gt; 数组指针与指针数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组指针： &lt;code&gt;int (*p)[n]&lt;/code&gt; ，指向一个整形的一维数组，这个数组的长度是 n，在执行 &lt;code&gt;p+1&lt;/code&gt;  操作时， &lt;code&gt;p&lt;/code&gt;  要跨越 n 个整形数据长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针数组： &lt;code&gt;int *p[n]&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt;  优先级高于 &lt;code&gt;*&lt;/code&gt; ，是一个具有 n 个指针类型的数组.&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//a 理解成一个一维数组，元素为 a [0], a [1], a [2]， 其中 a [0] 的类型为 (int *), a 与 &amp; amp;a [0] 等价，类型为 int (*p)[4]&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数指针&#34;&gt;#&lt;/a&gt; 函数指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数指针的类型是由其返回类型和参数列表共同决定的&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;pf&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;//pf 为一个函数指针&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 区别于 int *pf (const int&amp;amp;, const int&amp;amp;);	pf 为一个函数声明，函数返回值为 int&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数指针的赋值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;指针名=函数名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;指针名=&amp;amp;函数名&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;宏定义与typedef&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#宏定义与typedef&#34;&gt;#&lt;/a&gt; 宏定义与 typedef&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宏定义主要用于定义常量或者一些书写复杂的内容， &lt;code&gt;typedef&lt;/code&gt;  主要用于定义类型的别名&lt;/li&gt;
&lt;li&gt;宏定义在预处理阶段完成，只会进行文本的替换，不进行类型的检查； &lt;code&gt;typedef&lt;/code&gt;  在编译阶段完成，会进行类型的检查&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;const与define&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#const与define&#34;&gt;#&lt;/a&gt; const 与 define&lt;/h2&gt;
&lt;h2 id=&#34;inline内联函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#inline内联函数&#34;&gt;#&lt;/a&gt; inline 内联函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把 inline 函数体复制到函数调用处（避免了函数调用所需要的压栈和出栈操作，提高了程序运行效率）&lt;/li&gt;
&lt;li&gt;特性类似于宏定义，但 inline 会做类型的检查&lt;/li&gt;
&lt;li&gt;不能包含循环、递归复杂操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;  函数有多个返回点，会使用 &lt;code&gt;goto&lt;/code&gt;  跳转&lt;/li&gt;
&lt;li&gt;在类中定义的成员函数，除了虚函数，往往会自动转化为内联函数&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;代码膨胀，占用代码区的内存空间&lt;/li&gt;
&lt;li&gt;是否内敛由编译器决定，不可控.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;this指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#this指针&#34;&gt;#&lt;/a&gt; this 指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;this 是一个隐含于每一个非静态成员函数中的特殊指针，指向被实例化的对象。当调用对象成员函数时，会将对象的地址赋值给 &lt;code&gt;this&lt;/code&gt;  指针，并会隐式的将 &lt;code&gt;this&lt;/code&gt;  指针传入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tihs&lt;/code&gt;  为一个右值，并由 &lt;code&gt;const&lt;/code&gt;  修饰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;初始化列表c11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#初始化列表c11&#34;&gt;#&lt;/a&gt; 初始化列表（C++11）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过花括号来进行初始化。直接在变量名后面跟上初始化列表来进行对象的初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类成员函数初始化方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类成员函数初始化方法&#34;&gt;#&lt;/a&gt; 类成员函数初始化方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;赋值初始化&lt;/code&gt; ：在函数体内进行赋值. (其是在所有成员被分配内存之后才进行的，此时会触发成员函数的默认构造函数，同时进入函数体赋值往往会产生临时对象，和拷贝赋值函数)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;列表初始化&lt;/code&gt; ：在冒号后使用初始化列表进行初始化.（给数据成员分配内存时进行的，在函数体执行之前）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于基本数据类型而言，两种在速度方面没有太大的差别，但对于复杂一些的数据类型，列表初始化速度会快于赋值初始化&lt;/p&gt;
&lt;p&gt;什么情况下必须用初始化列表？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化一个引用成员变量时&lt;/li&gt;
&lt;li&gt;初始化一个常量成员时&lt;/li&gt;
&lt;li&gt;当父类没有默认构造函数的时&lt;/li&gt;
&lt;li&gt;当成员变量没有默认构造函数时&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;autoc11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#autoc11&#34;&gt;#&lt;/a&gt;  &lt;code&gt;auto（C++11）&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;  可以自动推导变量类型；使用 &lt;code&gt;auto&lt;/code&gt;  声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译阶段将 &lt;code&gt;auto&lt;/code&gt;  占位符替换成其真正的类型.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于有 &lt;code&gt;const&lt;/code&gt;  和 &lt;code&gt;volatile&lt;/code&gt;  修饰的变量， &lt;code&gt;auto&lt;/code&gt;  只能推断底层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt; ，顶层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  会被忽略，需要自己添加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能在函数的参数中使用，不能用于定义数组，不能用于类的非静态成员的初始化（只能用于类的静态常量成员变量的初始化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能用于模版参数的类型推导&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类的成员变量并不属于类，而属于具体的实例。如果没有创建实例，那么就没有办法进行自动类型推导.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;decltypec11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#decltypec11&#34;&gt;#&lt;/a&gt;  &lt;code&gt;decltype（C++11）&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我们希望从表达式（函数返回值）中推断出想要定义的变量的类型，但是却不想用表达式的值去初始化变量，这种情况 &lt;code&gt;auto&lt;/code&gt;  显得无力了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;推断表达式类型作为变量的定义类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推断函数返回值（实际不会调用，仅推断），推导出的对象类型与函数返回值一致&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当函数返回的是一个纯右值，需要忽略掉前面的 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无论是底层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  还是顶层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  都会被保留&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式是一个左值，或者被 &lt;code&gt;()&lt;/code&gt;  包围，使用 &lt;code&gt;decltype&lt;/code&gt;  推导出来是表达式类型的引用（如果有 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  则需要加上）&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; b &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;token comment&#34;&gt;//b 的类型为 int&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; c &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;//c 的类型为 int&amp;amp;，绑定 a 对象&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;范围for循环c11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#范围for循环c11&#34;&gt;#&lt;/a&gt; 范围 for 循环（C++11）&lt;/h2&gt;
&lt;h2 id=&#34;null与nullptr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#null与nullptr&#34;&gt;#&lt;/a&gt;  &lt;code&gt;NULL&lt;/code&gt;  与 &lt;code&gt;nullptr&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;  来自 C 语言，由宏定义实现， &lt;code&gt;nullptr&lt;/code&gt;  是 C++11 新增的关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 C 语言中 &lt;code&gt;NULL&lt;/code&gt;  被定义成 &lt;code&gt;(void *)0&lt;/code&gt; ，在 C++ 中则被定义成 &lt;code&gt;0&lt;/code&gt; ，故引入 &lt;code&gt;nullptr&lt;/code&gt;  替代了 &lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;ifdef&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;__cplusplus&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;token macro-name&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;token macro-name&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有一个函数被重载时，且参数都是指针类型时，调用函数时需要明确强制转换成对应类型，否则编译器无法确定需要调用哪一个函数&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;iostream&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;namespace&lt;/span&gt; std&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; p&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;char* p&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; p&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;int* p&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; p&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;int p&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;// 语句 1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;// 语句 2&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token constant&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;// 语句 3&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 运行结果：&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 语句 1：char* p&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 语句 2: 报错，有多个匹配&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//3：int p&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lambda表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lambda表达式&#34;&gt;#&lt;/a&gt; lambda 表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;匿名函数。一个 &lt;code&gt;lambda&lt;/code&gt;  表达式具有一个返回值、一个参数列表和一个函数体。与函数不同的是， &lt;code&gt;lambda&lt;/code&gt;  表达式可以定义在函数体内部，格式为： &lt;code&gt;[capture list](parameter list) opt -&amp;gt;return type &amp;#123;function body&amp;#125;&lt;/code&gt; ，不能用默认参数.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;capture list&lt;/code&gt; ：捕获列表
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; ：不捕获任何变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; ：捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; ：捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获），拷贝的副本在匿名函数体内部是只读的，不可改变.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=, &amp;amp;foo]&lt;/code&gt; ：按值捕获外部作用域内的所以变量，按引用捕获变量 &lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[this]&lt;/code&gt; ：捕获当前实例的 &lt;code&gt;this&lt;/code&gt;  指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(parameter list)&lt;/code&gt; ：参数列表，和普通函数的参数列表一样，如果没有参数列表可以省略不写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt&lt;/code&gt;  选项，不需要可以省略
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mutable&lt;/code&gt; ：可以修改按值拷贝进来的副本（注意修改的是副本）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exception&lt;/code&gt; ：指定函数抛出的异常&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return type&lt;/code&gt; ：一般情况下，不指定 &lt;code&gt;lambda&lt;/code&gt;  表达式的返回值，编译器会根据 &lt;code&gt;return&lt;/code&gt;  语句自动推导返回值类型，但是 &lt;code&gt;初始化列表不能用于返回值的自动推导&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;左值引用与右值引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#左值引用与右值引用&#34;&gt;#&lt;/a&gt; 左值引用与右值引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;左值引用：对左值的引用（可以出现在等式的左边，也可以出现在等式的右边，是具名的，同时可以取地址， &lt;code&gt;const左值引用&lt;/code&gt; 可以引用右值）; 避免对象的拷贝，在一定程度上让程序脱离了危险的指针&lt;/li&gt;
&lt;li&gt;右值引用：右值（只能出现在等式的右边，不能取地址，纯右值 [字面值，返回的非引用的函数调用，后置自增 / 减，算术表达式，逻辑表达式，比较表达式], 将亡值 [C++11 引入，会触发移动构造或者移动赋值，并进行资源转移]）往往是没有名称，在实际开发中我们可能需要对右值进行修改，需要借助右值引用（ &lt;code&gt;类型&amp;amp;&amp;amp; 变量名=右值&lt;/code&gt; ）
&lt;ol&gt;
&lt;li&gt;移动语义：将一个临时对象（将亡值）的资源转移到另外一个对象中去，可以减少不必要的资源的销毁和开辟，提高运行效率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;move()&lt;/code&gt; ：将左值强制转化为右值引用，通过右值引用来使用，实现移动语义.&lt;/li&gt;
&lt;li&gt;完美转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;大小端存储&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大小端存储&#34;&gt;#&lt;/a&gt; 大小端存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大端存储：高位存储在低字节中&lt;/li&gt;
&lt;li&gt;小端存储：低位存储在低字节中&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Socket网络编程&lt;/code&gt; 中，有主机字节序和网络字节序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存对齐&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存对齐&#34;&gt;#&lt;/a&gt; 内存对齐&lt;/h2&gt;
&lt;p&gt;理论上计算机对于任何变量的访问都可以从任务位置开始，然而实际上系统会对这些变量的存放做一些限制，通常将某个变量的地址设置为某个数 &lt;code&gt;N&lt;/code&gt;  的整数倍。这就是内存对齐.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存是以字节为基本单位，但是对于处理器往往是按字节块来存取数据。进行内存对齐，主要是为了加快内存的存取速度.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存池&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存池&#34;&gt;#&lt;/a&gt; 内存池&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;预先申请分配一定数量的内存块留作备用，当有新的内存需求时，就从内存池中分出一部分内存块，对于使用完的内存块将其放回内存池。若内存池不够，在继续申请新的内存. （防止频繁的内存申请与释放所带来的开销，提高分配效率，同时可以避免内存碎片）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stl六大组件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#stl六大组件&#34;&gt;#&lt;/a&gt; STL 六大组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;容器、算法、迭代器、适配器、仿函数、空间分配器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么stack的pop和top要分离&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为什么stack的pop和top要分离&#34;&gt;#&lt;/a&gt; 为什么 stack 的 pop () 和 top () 要分离&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;pop()&lt;/code&gt;  来弹出并返回栈顶值这种方式不安全，可能导致原始数据丢失；pop () 在函数返回时，会发生对象的拷贝，如果弹出对象比较大，同时堆内内存比较紧张，可能无法分配住够的内存会抛出异常，无法正确的返回栈顶元素，但是此时栈顶元素已经弹出.&lt;/li&gt;
&lt;li&gt;通过引用或者指针可以解决这个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map-set-multimap-multiset关联容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#map-set-multimap-multiset关联容器&#34;&gt;#&lt;/a&gt; map、set、multimap、multiset（关联容器）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;底层实现是 &lt;code&gt;红黑树&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;  和 &lt;code&gt;multiset&lt;/code&gt;  会对元素进行排序， &lt;code&gt;set&lt;/code&gt;  不存储重复元素， &lt;code&gt;multiset&lt;/code&gt;  可以存储重复元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;  和 &lt;code&gt;multimap&lt;/code&gt;  存储的元素为 k-v 键值对，会更加 key 进行排序， &lt;code&gt;map&lt;/code&gt;  中不允许重复 key， &lt;code&gt;multimap&lt;/code&gt;  可以重复 key&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unordered_set与set&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unordered_set与set&#34;&gt;#&lt;/a&gt; unordered_set 与 set&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unordered_set&lt;/code&gt;  内部无序，通过哈希来实现，对于非标准类型需要提供判等函数，插入，查询，删除的时间复杂度都是 &lt;code&gt;O(1)&lt;/code&gt; ，但是不稳定，当数据量大冲突大时，时间复杂度最坏退化为 &lt;code&gt;O(n)&lt;/code&gt; ； &lt;code&gt;set&lt;/code&gt;  内部有序，通过红黑树来实现，对于非标准类型需要提供比较函数，插入，查询，删除的时间复杂度比较稳定 &lt;code&gt;log2(n)&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哈希函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#哈希函数&#34;&gt;#&lt;/a&gt; 哈希函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;平方取中发：去关键字的平方值的中间几位作为哈希地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哈希冲突&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#哈希冲突&#34;&gt;#&lt;/a&gt; 哈希冲突&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;开放地址法（再散列）：线性探测，再平方探测、伪随机探测&lt;/li&gt;
&lt;li&gt;拉链法&lt;/li&gt;
&lt;li&gt;再哈希&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vector的扩容机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vector的扩容机制&#34;&gt;#&lt;/a&gt; vector 的扩容机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;  是一个动态数组，当插入元素使，若 &lt;code&gt;capacity&lt;/code&gt;  和 &lt;code&gt;size&lt;/code&gt;  相等，则会发生扩容； &lt;code&gt;vector&lt;/code&gt;  扩容并不是在原有空间进行扩充，而是在堆内申请一块更大空间的区域，将原来的数据复制过去，同时释放原有空间。至于这个扩容系数，得看具体的实现，得看取舍（内存和效率的取舍）， &lt;code&gt;GCC&lt;/code&gt;  下的扩容系数是 2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vectorclear-swap-shrink_to_fitresizereserve&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vectorclear-swap-shrink_to_fitresizereserve&#34;&gt;#&lt;/a&gt; vector（clear(), swap(), shrink_to_fit(),resize(),reserve()）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt; ：清空内容，不释放内存（capacity 不变，size 变成 0）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap()&lt;/code&gt; ：清空内容，释放内存 (capacity，size 均变成 0)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shrink_to_fit()&lt;/code&gt; ：可能会释放内存，使 capacity 与 size 适配（capacity 与 size 相等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resize(n)&lt;/code&gt; ：会改变 &lt;code&gt;vector&lt;/code&gt;  的 size&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reserve()&lt;/code&gt; ：不会改变 size，但是可能会改变 capacity. 主要目的是为了优化性能，避免在添加元素时频繁进行内存分配&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vector与list&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vector与list&#34;&gt;#&lt;/a&gt; vector 与 list&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;  的内存空间是连续的，可以在 &lt;code&gt;o(1)&lt;/code&gt;  内实现随机存取，但是需要再内部进行插入和删除时，需要 &lt;code&gt;O(n)&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt;  是双向链表，内存空间不一定连续，往往是离散的， &lt;code&gt;O(n)&lt;/code&gt;  完成随机存取，但是可以 &lt;code&gt;O(1)&lt;/code&gt;  实现删除和插入操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;clear的时间复杂度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#clear的时间复杂度&#34;&gt;#&lt;/a&gt; clear 的时间复杂度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无论是顺序容器还是关联容器在使用 &lt;code&gt;clear()&lt;/code&gt;  时，时间复杂度都是 &lt;code&gt;O(n)&lt;/code&gt; ；因为执行 &lt;code&gt;clear()&lt;/code&gt;  需要调用元素的析构函数，这个析构函数会逐个进行。不过当存储的数据类型是基本数据类型的时候，不需要虚构，系统可能会做一些优化， &lt;code&gt;vector&lt;/code&gt;  容器可以使得复杂度降为常数级.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c智能指针c11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c智能指针c11&#34;&gt;#&lt;/a&gt; C&lt;ins&gt; 智能指针（C&lt;/ins&gt;11）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;智能指针是一个类，用来存储指向动态内存空间的对象指针，负责自动释放动态内存，防止堆内存泄漏.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt; ：C&lt;ins&gt;98 引入，由于其不够安全，被 &lt;code&gt;unique_ptr&lt;/code&gt;  取代，C&lt;/ins&gt;11 废弃；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; ：与 &lt;code&gt;auto_ptr&lt;/code&gt;  一样采用独占所有权模式，同一时间只能有一个指针可以指向某个对象，但是 &lt;code&gt;unique_ptr&lt;/code&gt;  禁止了拷贝操作， &lt;code&gt;unique_ptr&lt;/code&gt;  采用了移动赋值 &lt;code&gt;move()&lt;/code&gt;  函数来进行控制权转移.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt; ：共享所有权的一个智能指针。允许多个指针指针指向同一个对象，并使用引用计数来管理指向对象的指针（成员函数 &lt;code&gt;use_count()&lt;/code&gt;  可获得引用计数），该对象和相关资源会在最后一个引用被销毁时释放&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt; ：内部的引用计数是线程安全的，但是对象的读取需要加锁.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;  循环计数问题：创建了两个 &lt;code&gt;shared_ptr&lt;/code&gt;  分别指向两个对象，而这两个对象内的一个共享指针分别又指向了对方，造成了循环计数，使得两个对象的空间都无法被释放.&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;ListNode&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; _data&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	shared_ptr&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; data&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;_data&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;data&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token operator&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;~ListNode()&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	shared_ptr&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;node1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	shared_ptr&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;ListNode&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;node2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; node1&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use_count&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; node2&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use_count&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	node1&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; node2&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	node2&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; node1&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; node1&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use_count&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 2&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; node2&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use_count&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 2&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 常用的解决方案是讲成员函数内的 shared_pre 改成弱指针 weak_ptr&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt; ：一种不控制对象生命周期的智能指针，不会影响 &lt;code&gt;share_ptr&lt;/code&gt;  的引用计数，只是提供一种访问其管理对象的方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存泄漏&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存泄漏&#34;&gt;#&lt;/a&gt; 内存泄漏&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;堆内存泄漏（ &lt;code&gt;Heap leak&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;在释放对象数组时没有使用 &lt;code&gt;delete []&lt;/code&gt;  而使用 &lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有将基类的析构函数定义为虚函数&lt;/li&gt;
&lt;li&gt;缺少拷贝构造函数和拷贝赋值函数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 下内存泄漏检查工具：&lt;strong&gt;Valgrind&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;深拷贝与浅拷贝&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#深拷贝与浅拷贝&#34;&gt;#&lt;/a&gt; 深拷贝与浅拷贝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝：C++ 默认的方式（如果程序员不主动编写拷贝构造函数和赋值构造，编译器将以浅拷贝的方式生成缺省的函数），简单的将成员函数值进行复制. （当成员变量出现指针时，则会导致多个指针指向同一片内存空间，新旧对象共享内存，当其中一个对象释放内存，再调释放其他对象时就会出现问题，同一片内存空间被释放了多次）&lt;/li&gt;
&lt;li&gt;深拷贝：必须显示的提供拷贝构造函数和赋值构造，新旧对象不共享内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c类默认生成的函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c类默认生成的函数&#34;&gt;#&lt;/a&gt; C++ 类默认生成的函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无参构造函数、析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、重载取地址符，均是 &lt;code&gt;public&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象复用与零拷贝&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对象复用与零拷贝&#34;&gt;#&lt;/a&gt; 对象复用与零拷贝&lt;/h2&gt;
&lt;h2 id=&#34;stl内存优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#stl内存优化&#34;&gt;#&lt;/a&gt; STL 内存优化&lt;/h2&gt;
&lt;h2 id=&#34;const-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#const-2&#34;&gt;#&lt;/a&gt;  &lt;code&gt;const&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当以编译初始化的方式定义了一个 &lt;code&gt;const&lt;/code&gt;  对象时，例如 &lt;code&gt;const int bufsize=512&lt;/code&gt; ，编译器将在编译过程中把用到该变量的地方都替换成对应的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;  对象被设定为仅在文件内有效，当多个文件中出现了同名的 &lt;code&gt;const&lt;/code&gt;  变量时，其实等同于在不同文件下分别定义了独立的变量；当某一个 &lt;code&gt;const&lt;/code&gt;  对象需要再多个文件间共享时，我们需要对于 &lt;code&gt;const&lt;/code&gt;  变量不管是声明还是定义都添加 &lt;code&gt;extern&lt;/code&gt;  关键字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对常量的引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对常量的引用&#34;&gt;#&lt;/a&gt; 对常量的引用&lt;/h3&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;double&lt;/span&gt; dval &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;r &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; dval&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;等价于&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; temp &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; dval&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;r &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; temp&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;系统在内部会将对常数的引用绑定在一个临时对象上，实际并未绑定 &lt;code&gt;dval&lt;/code&gt; ；通过这种设计可以防止非法的操作。&lt;/p&gt;
&lt;h2 id=&#34;顺序容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顺序容器&#34;&gt;#&lt;/a&gt; 顺序容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt; ：可变长数组。支持快速随机访问。在尾部之外的其他位置插入或者删除元素可能比较慢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deque&lt;/code&gt; ：双端队列。支持快速随机访问。在头部或者尾部插入、删除元素速度很快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt; ：双向列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forward_list&lt;/code&gt; ：单向列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt; ：固定大小数组。支持快速随机访问。不能添加或者删除元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; ：与 &lt;code&gt;vector&lt;/code&gt;  类似，但专门用于存储字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指针空值类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指针空值类型&#34;&gt;#&lt;/a&gt; 指针空值类型&lt;/h2&gt;
&lt;p&gt;C 与 C&lt;ins&gt; 内定义的 &lt;code&gt;NULL&lt;/code&gt;  含义不同；C&lt;/ins&gt; 内定义： &lt;code&gt;#define NULL 0&lt;/code&gt; , 而 C 内的定义： &lt;code&gt;#define NULL ((void *)0)&lt;/code&gt; .C 与 C&lt;ins&gt; 都是强类型语言，从 C 到 C&lt;/ins&gt; 语言的类型定义变的更加严格，C++ 内不允许 &lt;code&gt;void( *)&lt;/code&gt;  类型的变量隐式转化为其他类型。&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 宏定义&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;ifndef&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token constant&#34;&gt;NULL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;ifdef&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;__cplusplus&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;token macro-name&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;token macro-name&#34;&gt;NULL&lt;/span&gt;  &lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt;  无法隐式的转化为整形，但是可以隐式匹配指针类型&lt;/p&gt;
&lt;h2 id=&#34;使用结构化绑定来解包绑定的返回值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用结构化绑定来解包绑定的返回值&#34;&gt;#&lt;/a&gt; 使用结构化绑定来解包绑定的返回值&lt;/h2&gt;
&lt;p&gt;结构化绑定是 C++17 新特性，其可以结合语法糖自动推导类型，并可以从组对、元祖和结构体中提取单独的变量（解包）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用结构化绑定是为了能过更加简单的为绑定的多个变量进行赋值&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//  对 pair 的结构化绑定&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;pair&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;divide_remainder&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; dividend&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; divisor&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; b&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;divide_remainder&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//  对 tuple 进行结构化绑定&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;tuple&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;string&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;chrono&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;system_clock&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;time_point&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;unsigned&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;name&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; valid_time&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; price&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;stock_info&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;INTC&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//  对自定义结构体进行结构化绑定&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;employee&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;unsigned&lt;/span&gt; id&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    string name&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    string role&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;unsigned&lt;/span&gt; salary&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;vector&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;employee&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; employees&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;/* 注意：在适当时候使用引用，尽量减少不必要的复制 */&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;id&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; name&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; role&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; salary&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; employees&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;Name: &#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;         &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;Role: &#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; role&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;         &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;Salary: &#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; salary &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token char&#34;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;STL&lt;/code&gt;  中的基础数据结构都能通过结构化绑定来直接进行访问&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;map&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;string&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; size_t&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; animal_population&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;species&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; count&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; animal_population&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  cout &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;There are &#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; count &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; species&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;            &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34; on this planet.\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Node：与 C 的语法特征不同，将复杂结构体作为返回值传回会耗费大量的时间，因为对象需要在返回函数中进行初始化，之后将这个对象拷贝到相应容器中返回给调用端。现代编译器支持&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96&#34;&gt;&lt;strong&gt;返回值优化&lt;/strong&gt;&lt;/a&gt; (RVO, &lt;em&gt;return value optimization&lt;/em&gt;) 技术，这项技术可以省略中间副本的拷贝。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;带初始化的if和switch&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#带初始化的if和switch&#34;&gt;#&lt;/a&gt; 带初始化的 if 和 switch&lt;/h2&gt;
&lt;h2 id=&#34;括号初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#括号初始化&#34;&gt;#&lt;/a&gt; 括号初始化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;C++11&lt;/code&gt;  引入了新的括号初始化语法 &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt; ，其不仅允许集合式的初始化，而且还是对常规构造函数的调用。遗憾的是，当与 &lt;code&gt;auto&lt;/code&gt;  类型变量结合使用时，这种方式很容易出现错误， &lt;code&gt;c++17&lt;/code&gt;  增强了这一系列初始化规则。&lt;/p&gt;
&lt;h2 id=&#34;参考博文&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考博文&#34;&gt;#&lt;/a&gt; 参考博文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NfYmFzZV9qaW4vYXJ0aWNsZS9kZXRhaWxzLzg2MDM2MTg1&#34;&gt;C++ 菱形继承问题和虚继承分析 - CSDN 博客&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>

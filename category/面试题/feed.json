{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"面试题\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "MySQL面试题",
            "date_published": "2024-03-13T06:46:17.113Z",
            "content_html": "<h1 id=\"mysql面试题\"><a class=\"anchor\" href=\"#mysql面试题\">#</a> MySQL 面试题</h1>\n<h2 id=\"关系型数据库和非关系型数据库\"><a class=\"anchor\" href=\"#关系型数据库和非关系型数据库\">#</a> 关系型数据库和非关系型数据库</h2>\n<h2 id=\"myisam和innodb的区别\"><a class=\"anchor\" href=\"#myisam和innodb的区别\">#</a>  <code>MyISAM</code>  和 <code>InnoDB</code>  的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引采用的是非聚簇索引，索引的数据域存储数据的指针，而 <code>InnoDB</code>  主键采用的是聚簇索引，非主键采用非聚簇索引，索引的数据域存储主键的 id.</li>\n<li><code>MyISAM</code>  不支持事务，但是每次查询都是原子操作； <code>Innodb</code>  支持 <code>ACID</code>  的事务，支持事务的四种隔离级别</li>\n<li><code>MyISAM</code>  存储表的总行数； <code>InnoDB</code>  不存储表的总行数</li>\n<li><code>MyISAM</code>  不支持外键约束，而 <code>InnoDB</code>  支持</li>\n<li><code>MyISAM</code>  支持最小粒度所为表级锁； <code>InnoDB</code>  支持行级锁</li>\n</ol>\n<h2 id=\"覆盖索引\"><a class=\"anchor\" href=\"#覆盖索引\">#</a> 覆盖索引</h2>\n<blockquote>\n<p>索引的值包含所需要查询的字段</p>\n</blockquote>\n<h2 id=\"innodb的索引与myisam的所索引的区别\"><a class=\"anchor\" href=\"#innodb的索引与myisam的所索引的区别\">#</a>  <code>InnoDB</code>  的索引与 <code>MyISAM</code>  的所索引的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引文件和数据文件是分离的，使用 B + 树来实现，主键索引和辅助索引实现基本一致（非主键不保证唯一）；叶子节点仅保存数据和数据的地址（非聚簇索引）.</li>\n<li><code>InnoDB</code>  索引分两种，聚簇索引和非聚簇索引，聚簇索引的叶子节点同 时也会存储数据。非聚簇索引的索引数据域保存主键的 id</li>\n</ol>\n<h2 id=\"为什么使用索引\"><a class=\"anchor\" href=\"#为什么使用索引\">#</a> 为什么使用索引</h2>\n<blockquote>\n<p>索引是数据库中用于加速数据访问的一种数据结构</p>\n</blockquote>\n<ul>\n<li>\n<p>在关系型数据库中，通常使用 <code>B-Tree</code>  或哈希表等索引结构</p>\n</li>\n<li>\n<p>索引可以提高查询效率，建立索引的原则如下.</p>\n<blockquote>\n<ol>\n<li>区分度高的列作为索引可以加快查询速度</li>\n<li>经常出现在 <code>where</code>  中的列</li>\n<li>表记录较少索引效果不好，没有必要建立索引</li>\n<li>定义有外键的数据列一定要建立索引</li>\n<li>更新频繁的数据列不适合建立索引</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>索引会降低插入、删除、更新表的速度，因为在执行这些操作时，还需要操作索引文件.</p>\n</li>\n<li>\n<p>索引需要占用物理空间，除了索引表需要占用空间之外，每个索引也需要占用额外的存储空间。同时如果非聚餐索引很多，一旦聚簇索引改变，那么非聚簇索引也需要跟着改变，代价比较大</p>\n</li>\n</ul>\n<blockquote>\n<p>MySQL 中使用较多的是 <code>Hash索引</code> 和 <code>B+树索引</code></p>\n<p>对于哈希索引来说，底层的数据结构就是哈希表，因此对于绝大多数需求为单挑记录的查询的时候，可以选择哈希索引，查询性能高，其余的绝大多数场景使用 B + 树所以</p>\n</blockquote>\n<h2 id=\"聚簇索引和非聚簇索引的区别\"><a class=\"anchor\" href=\"#聚簇索引和非聚簇索引的区别\">#</a> 聚簇索引和非聚簇索引的区别</h2>\n<ul>\n<li>\n<p>聚簇索引：主键索引</p>\n<blockquote>\n<ol>\n<li>将数据存储在索引树的叶子节点上，可以减少一次查询（查询索引树的同时就能获得数据）</li>\n<li>当需要对数据进行修改或删除时，需要更新索引树，增加系统开销（聚簇索引保证顺序，当中间有数据需要插入时，可能引起分页）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>非聚簇索引：二级索引 / 辅助索引</p>\n<blockquote>\n<ol>\n<li>不将数据存储在索引树中，而是存储在数据页中；查询数据时需要两次查询，一次用于查询索引树，获取数据页的地址，在通过数据页的地址来查询数据（如果索引覆盖的话实际上不用回表）</li>\n<li>当需要对数据进行修改或删除时，不需要更新索引树，减少了系统开销</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"唯一索引与普通索引\"><a class=\"anchor\" href=\"#唯一索引与普通索引\">#</a> 唯一索引与普通索引</h2>\n<ul>\n<li>\n<p>区别：唯一索引的索引值必须唯一，但允许有空值（即可以是单列唯一索引也可以是联合唯一索引）；普通索引索引值不一定唯一，且允许有空值.</p>\n<blockquote>\n<p>唯一索引可以保证数据的唯一性</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"联合索引-组合索引-复合索引\"><a class=\"anchor\" href=\"#联合索引-组合索引-复合索引\">#</a> 联合索引、组合索引、复合索引</h2>\n<blockquote>\n<p>组合索引、联合索引、复合索引指代都是一个意思，一个索引包含多个列</p>\n</blockquote>\n<ul>\n<li>\n<p><code>最左前缀匹配</code> ：组合索引的第一个字段必须出现在查询语句中，还不能跳跃，只有这样才能让组合索引生效</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 假设给 username，age 创建了组合索引</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 组合索引生效</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span> <span class=\"token operator\">and</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 特殊情况</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 组合索引失效</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> city <span class=\"token operator\">=</span> <span class=\"token string\">'shenzhen'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">18</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"索引失效的情况\"><a class=\"anchor\" href=\"#索引失效的情况\">#</a> 索引失效的情况</h2>\n<ul>\n<li>\n<p>使用 <code>like</code>  查询并且左边带 <code>%</code></p>\n<blockquote>\n<p>索引往往使用的是 B + 树结构，是一个有序排列的。百分号放在前面进行一个模糊查找时，前面都能匹配，很有可能就无法更具索引的有序性来进行查找了.</p>\n</blockquote>\n</li>\n<li>\n<p>隐式类型转换。索引字段是 <code>int</code> ，而使用字符串类型去查询</p>\n</li>\n<li>\n<p><code>where</code>  条件里面对索引使用运算或者函数</p>\n</li>\n<li>\n<p>使用 <code>or</code>  且存在非索引列</p>\n</li>\n<li>\n<p><code>where</code>  条件中对两列作比较</p>\n</li>\n<li>\n<p>使用 <code>in</code> （和数据量有关系）</p>\n</li>\n<li>\n<p>使用 <code>order by</code></p>\n</li>\n<li>\n<p><code>is null</code> 、 <code>is not null</code> 、 <code>≠</code></p>\n</li>\n</ul>\n<h2 id=\"innodb为什么使用自增id作为主键\"><a class=\"anchor\" href=\"#innodb为什么使用自增id作为主键\">#</a>  <code>InnoDB</code>  为什么使用自增 <code>id</code>  作为主键</h2>\n<ul>\n<li>使用自增 <code>id</code>  作为主键，那么在建立索引时，每次插入新的记录，记录会顺序添加到当前索引的后续位置，直到一页满为至才会开辟一个新的页</li>\n<li>如果使用非自增主键，由于每次插入的主键值比较随机，每次新纪录可能需要插入到现在索引的中间位置，会操作频繁的移动（内部单链表）和分页</li>\n</ul>\n<h2 id=\"b树与b树\"><a class=\"anchor\" href=\"#b树与b树\">#</a> B 树与 B + 树</h2>\n<blockquote>\n<p>查询一个数据时，在数据页内往往使用二分查找</p>\n</blockquote>\n<ul>\n<li>\n<p>B 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>每个节点包含多个关键字和对应的指针，即 B 数的每个节点都会存储数据</li>\n<li>B 树的叶子节点之间是指针相连的，不支持顺序访问</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>B + 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>所以的关键字都存储在叶子节点上，非叶子节点不存储数据，只存储索引和指向孩子节点的指针</li>\n<li>叶子节点通过指针连接起来，形成一个有序的链表，支持顺序访问和范围查找（MySQL 底层实际是一个双向链表）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>MySQL 选择 B + 树作为索引结构的原因</p>\n<blockquote>\n<ol>\n<li>范围查询和顺序访问的性能更高：B + 树的叶子节点通过指针连接成一个双向链表，可以很好的支持数据库的范围查询，同时在连续的数据查询中，B + 树可以利用磁盘的预读特性，提高数据顺序访问性能，嫌少磁盘 I/O</li>\n<li>更少的磁盘 I/O：B + 树的非叶子节点只存储索引和指向孩子的节点指针，不存储数据，相比于 B 树，每个节点可以存储更多的关键字，减少了磁盘 I/O 次数（节点可以存储更多的关键字，可以使得 B + 树高更矮)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> 数据库三大范式</h2>\n<blockquote>\n<p>数据库设计表结构时所遵循的规范，目的是为了减少冗余，提高数据存储和使用的效率</p>\n</blockquote>\n<ul>\n<li>第一范式：数据库表中的每个列都必须是原子性的，不可再分；同时每个表有一个主键.</li>\n<li>第二范式：表中非主键列必须完全依赖于主键，而不是部分依赖于主键. (如果有非主键列部分依赖于主键，需要将改列拆分并且放置于另外一张表中)</li>\n<li>第三范式：表中的非主键列之间不能存在传递依赖关系</li>\n</ul>\n<blockquote>\n<p>在实际的设计，经常也有反范式的现象，通过冗余的数据，来避免跨表的连接查询，以此来提高数据库的查询效率</p>\n</blockquote>\n<h2 id=\"数据库表的连接方式\"><a class=\"anchor\" href=\"#数据库表的连接方式\">#</a> 数据库表的连接方式</h2>\n<ul>\n<li>内连接</li>\n<li>左连接</li>\n<li>右连接</li>\n<li>全连接</li>\n<li>自连接</li>\n</ul>\n<h2 id=\"char与varchar\"><a class=\"anchor\" href=\"#char与varchar\">#</a> char 与 varchar</h2>\n<ul>\n<li>\n<p><code>char</code> ：定长字符类型。如果存储的字符串长度小于指定长度，会使用空格进行填充</p>\n</li>\n<li>\n<p><code>varchar</code> ：变长字符类型。它实际占用的存储空间为字符串的实际空间和用于存储字符串长度信息的空间</p>\n<blockquote>\n<ol>\n<li>存储效率： <code>char</code>  定长，无论字符串的实际长度多少，它占用的存储空间是固定，会浪费一定的空间.  <code>varchar</code>  是变长的，其占用的实际空间会随着字符串的大小而变动，存储效率较高</li>\n<li>查询效率： <code>char</code>  在搜索和排序方面的操作效率要高于 <code>varchar</code>  类型</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql锁的种类\"><a class=\"anchor\" href=\"#mysql锁的种类\">#</a> MySQL 锁的种类</h2>\n<ul>\n<li>\n<p>读写锁（锁的属性）</p>\n<blockquote>\n<ol>\n<li>共享锁 <code>Share Lock</code> ：读锁（ <code>S锁</code> ），当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁。为了支持高并发读取数据.</li>\n<li>排他锁 <code>Exclusive Lock</code> ：写锁（ <code>X锁</code> ），当一个事务为数据加上了写锁之后，其他请求不能再为这条数据加任何锁.</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>锁的粒度</p>\n<blockquote>\n<ol>\n<li>行锁：锁住表中的某一行或多行，粒度小，冲突小</li>\n<li>表锁：锁住整张表，粒度大，容易冲突</li>\n<li>记录数 <code>Record Lock</code> ：是行锁的一种，锁住表中的一条记录（命中的条件字段是一定是唯一索引）</li>\n<li>页锁：一种粒度介于行所和表锁之间的一种锁。每次锁定相邻的一组记录.</li>\n<li>间隙锁 <code>Gap Lock</code> ：属于行锁的一种</li>\n<li>临建锁 <code>Next-Key Lock</code></li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>意向锁</p>\n<blockquote>\n<p>如果当事务 A 加锁成功后设置一个状态告诉后面的人：已经有人对表里的行加了一个排他锁，不能再对整个表加共享锁或排他锁，那么后面需要对整个表加锁的人获取这个状态就知道是不是可以对表加锁，避免对这个索引表的每个节点扫描查看他们是否加锁，这个锁就是意向锁.</p>\n<ul>\n<li>意向共享锁：当一个事务试图对整个表加共享锁时，首先需要获取这个表的意向共享锁</li>\n<li>意向排他锁：当一个事务试图对整个表加排他锁时，首先需要获取这个表的意向排他锁</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql执行计划\"><a class=\"anchor\" href=\"#mysql执行计划\">#</a> MySQL 执行计划</h2>\n<blockquote>\n<p>执行计划： <code>sql</code>  的执行查询的顺序，以及如何使用索引</p>\n<p>在语句前面添加 <code>explain</code>  即可打印执行计划</p>\n</blockquote>\n<ul>\n<li>\n<p>执行计划参数</p>\n<blockquote>\n<ol>\n<li><code>id</code> ：</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql中的死锁\"><a class=\"anchor\" href=\"#mysql中的死锁\">#</a> MySQL 中的死锁</h2>\n<blockquote>\n<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的的一种互相等待的现象.</p>\n<p>产看死锁的命令： <code>show engine innodb status</code> ；可以通过设置 <code>innodblockwait_timeout</code>  来设置曹超时时间或主动回滚死锁中的某个事务.</p>\n</blockquote>\n<h2 id=\"数据库的四大特性acid\"><a class=\"anchor\" href=\"#数据库的四大特性acid\">#</a> 数据库的四大特性 ACID</h2>\n<ul>\n<li>\n<p><code>原子性Atomicity</code> ：当前事务的操作要么执行成功，要么执行失败</p>\n<blockquote>\n<p>由 <code>undo log</code>  日志保证，记录了需要回滚的日子信息，事务回滚时撤销已经执行成功的 <code>sql</code>  语句</p>\n</blockquote>\n</li>\n<li>\n<p><code>一致性Consistency</code></p>\n<blockquote>\n<p>由其他三大特性共同来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>隔离性Isolation</code> ：在事务并发执行时，他们内部的操作不能互相干扰</p>\n<blockquote>\n<p>由 <code>MVCC</code>  来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>持久性Durability</code></p>\n<blockquote>\n<p>由内存 <code>redo log</code>  来保证， <code>mysql</code>  修改数据同时在内存和 <code>redo log</code>  记录这次操作，宕机的时候可以从 <code>redo log</code>  恢复</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"事务隔离级别\"><a class=\"anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h2>\n<blockquote>\n<p><code>InnoDB</code>  中 隔离性是由 MySQL 的各种锁机制以及 <code>MVCC</code>  来实现的</p>\n</blockquote>\n<ul>\n<li>读未提交 <code>read_uncommitted(RU)</code> ：有脏读问题</li>\n<li>读已提交 <code>read_committed(RC)</code> ：有不可重复读的问题</li>\n<li>可重复读 <code>repeatable-read(RR)</code> ：会有幻读的问题</li>\n<li>串行化 <code>serializable</code></li>\n</ul>\n<h2 id=\"数据库并发事务会带来哪些问题\"><a class=\"anchor\" href=\"#数据库并发事务会带来哪些问题\">#</a> 数据库并发事务会带来哪些问题</h2>\n<ul>\n<li>脏读</li>\n<li>不可重复读</li>\n<li>幻读</li>\n<li>丢失修改</li>\n</ul>\n<h2 id=\"mvcc\"><a class=\"anchor\" href=\"#mvcc\">#</a> MVCC</h2>\n<blockquote>\n<p>多版本并发控制：读取数据时通过一种类似于快照的方式将数据保存下来，这样读锁和写锁就不冲突了；不同的事务会看到特定版本的数据（版本链）</p>\n</blockquote>\n<ul>\n<li>\n<p><code>MVCC</code>  只在读已提交和可重复读两个隔离级别下工作. ( <code>read_uncommited</code>  总是读取最新的数据； <code>serializable</code>  会对所以的读操作加锁)</p>\n<blockquote>\n<p>聚簇索引中有两个隐藏的列</p>\n<ol>\n<li><code>trx_id</code> ：存储每次对这条索引记录进行修改的 <code>事务ID</code>  (事务 ID 根据时间顺序依次递增)</li>\n<li><code>roll_pointer</code> ：上一版本的记录地址.（每次对聚簇索引记录有修改操作时，都会把老版本写入 <code>undo</code>  日志中，而这个修改后的新记录的 <code>roll_pointer</code>  则会指向日志中旧版本）</li>\n</ol>\n<p><code>ReadView</code>  是快照读（普通的 <code>select</code>  查询语句）执行时 <code>MVCC</code>  提取数据的依据</p>\n<ol>\n<li><code>m_ids</code> ：当前活跃的事务编号的集合（还未提交的事务集合）</li>\n<li><code>min_trx_id</code> ：最小活跃事务的编号</li>\n<li><code>max_trx_id</code> ：预分配事务的编号，当前最大事务 ID+1</li>\n<li><code>creator_trx_id</code> ： <code>ReadView</code>  创建者的事务编号</li>\n</ol>\n<p><code>当前读</code> ：指执行如下指令对数据进行读取</p>\n<ul>\n<li><code>Insert、Update、Delete、Select ... for Update、Select ... lock in share mode</code></li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%89%88%E6%9C%AC%E9%93%BE.png\" alt=\"\" title=\"版本链\" /></p>\n</li>\n<li>\n<p>读已提交隔离级别下 MVCC 的工作方式：在每一次执行快照读的时候生成 <code>ReadView</code></p>\n<blockquote>\n<p>1. 判断版本链的 <code>trx_id</code>  是否等于 <code>creator_trx_id</code> ，若等于说明对该条记录的更新就是当前事务，则可以访问</p>\n<p>2. 判断版本链的 <code>trx_id</code>  是否小于 <code>min_trx_id</code> ，若小于说明对该记录的处理已经提交，可访问</p>\n<p>3. 判断版本链的 <code>trx_id</code>  是否大于等于 <code>max_trx_id</code> ，如果成立说明对该条记录的操作是在生成 <code>ReadView</code>  之后，不可访问</p>\n<p>4. 判断版本链的 <code>trx_id</code>  是否在 <code>m_idx</code>  中，如果不存在，说明对该条记录的操作已提交，可以访问，若存在，则不可访问</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/ReadView.png\" alt=\"\" title=\"ReadView\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>可重复读级别下 MVCC 的工作方式：仅在第一次执行快照读的时候生成 <code>ReadView</code>  ，从而保证事务内对于一条记录的查询是一致的</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png\" alt=\"\" /></p>\n<blockquote>\n<p>多次连续的快照读， <code>ReadView</code>  会复用，没有幻读问题。但是两次连续的 <code>快照读</code> 之间存在 <code>当前读</code> 时， <code>ReadView</code>  会重新生成，导致产生幻读</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.png\" alt=\"\" /></p>\n</li>\n</ul>\n<h2 id=\"mysql主从同步原理\"><a class=\"anchor\" href=\"#mysql主从同步原理\">#</a> MySQL 主从同步原理</h2>\n<blockquote>\n<p><code>MySQL主从同步</code> 主要涉及到三个线程，主节点 master 上的 <code>binlog dump thread</code> ，从节点 slave 上的 <code>IO thread</code>  和 <code>sql thread</code> . 主节点的 <code>binlog</code>  维护的是主库记录的所以变更记录.</p>\n<ol>\n<li>主节点的 <code>log dump</code>  线程，当 <code>binlog</code>  有变动时， <code>log dump</code>  会读取 <code>binlog</code>  日志变动的内容并发送到从节点</li>\n<li>从节点的 <code>IO thread</code>  接收到 <code>binlog</code>  内容 ，并将其写入 <code>relay log</code>  文件中.</li>\n<li>从节点的 <code>sql thread</code>  读取 <code>realy log</code>  新增的内容并执行，最终保持主从数据库的一致性.</li>\n</ol>\n<p>注：主节点使用 <code>binlog</code>  文件和 <code>position</code>  偏移量来定位主动同步的位置（增量同步）</p>\n<p>由于 MySQL 的默认的主从同步方式是异步 的，主节点把日志发送给从节点后不关系从库是否已经处理，这样会产生一个问题：主节点挂了，从节点处理失败了，那么这时从节点升级为主节点后，就会有一部分日志丢失了，有一下解决方案：</p>\n<ul>\n<li>全同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，需要等待所以的从节点执行完成之后，在将结果返回给客户端. (影响效率)</li>\n<li>半同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，不需要等待所以的从节点执行完成，当收到至少一个从节点的同步完成就将结果返回给客户端.</li>\n</ul>\n</blockquote>\n<pre><code>## 慢查询如何优化\n</code></pre>\n<ul>\n<li>检查是否建了索引，查询是否走了索引</li>\n<li>检查是否 <code>load</code>  了多余的数据列</li>\n<li>返回的数据量太多</li>\n</ul>\n<h2 id=\"mysql-ngram全文检索\"><a class=\"anchor\" href=\"#mysql-ngram全文检索\">#</a>  <code>MySQL Ngram</code>  全文检索</h2>\n<h2 id=\"跳表与b树\"><a class=\"anchor\" href=\"#跳表与b树\">#</a> 跳表与 B + 树</h2>\n<ul>\n<li>跳表：将部分链表节点提取出来，再构建出一个新的链表，一直递归的做上述的过程，形成的新的数据结构就是跳表。每次在进行查询操作的时候，先查询上层的链表，看落在那个范围，在递归去下层链表搜索. （跳表一条数据一个节点）</li>\n</ul>\n<blockquote>\n<p>跳表的写入性能比 B + 树好：B + 树在进行插入数据的时候，由于 B + 树的一个多叉的平衡树，可能会导致拆分合并索引数据页。跳表则是独立插入，并根据随机函数确定是否在上层中增加节点。没有旋转维持平衡的开销</p>\n</blockquote>\n",
            "tags": [
                "面试题",
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "操作系统面试题",
            "date_published": "2024-03-13T01:21:27.470Z",
            "content_html": "<h1 id=\"操作系统面试题\"><a class=\"anchor\" href=\"#操作系统面试题\">#</a> 操作系统面试题</h1>\n<h2 id=\"什么的操作系统\"><a class=\"anchor\" href=\"#什么的操作系统\">#</a> 什么的操作系统</h2>\n<p>操作系统是负责管理协调计算机硬件和软件资源的一种系统软件。其屏蔽了底层硬件的异构性和复杂性，为上层应用程序提供统一易用的接口.</p>\n<h2 id=\"主机启动\"><a class=\"anchor\" href=\"#主机启动\">#</a> 主机启动</h2>\n<blockquote>\n<p><code>BIOS</code> ：I/O 处理系统，开机时可以自动检测各种外设<br />\n <code>Bootloader</code> ：加载 OS</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.png\" alt=\"\" /></p>\n<h2 id=\"中断和异常的处理过程\"><a class=\"anchor\" href=\"#中断和异常的处理过程\">#</a> 中断和异常的处理过程</h2>\n<ul>\n<li>\n<p>外中断是指由 CPU 执行指令以外的时间引起的，如 IO 完成中断、时钟中断、控制台中断；</p>\n</li>\n<li>\n<p>内中断（异常）是由 CPU 执行指令内部事件引起的，如地址越界、除 0、算术溢出等.</p>\n</li>\n<li>\n<p>硬件</p>\n<blockquote>\n<ol>\n<li>设置中断标记</li>\n<li>操作系统根据这个标记（中断号）去找到对应的处理程序</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>软件</p>\n<blockquote>\n<ol>\n<li>保存现场：把当前执行程序的相关数据保存在寄存器中，然后入栈</li>\n<li>开中断：以便于响应优先级更高的中断请求</li>\n<li>中断服务程序处理</li>\n<li>关中断：保证恢复现场时不被中断</li>\n<li>恢复现场</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"系统调用\"><a class=\"anchor\" href=\"#系统调用\">#</a> 系统调用</h2>\n<blockquote>\n<p>应用程序需要操作系统提供服务，而这些服务不能由应用程序直接执行。需要操作系统提供接 --- 系统调用</p>\n<p><code>用户态</code> 转化到 <code>内核态</code></p>\n</blockquote>\n<h2 id=\"操作系统功能\"><a class=\"anchor\" href=\"#操作系统功能\">#</a> 操作系统功能</h2>\n<ul>\n<li>进程管理</li>\n<li>内存管理：负责管理内存的分配、回收。在进程创建时分配内存以及在进程结束时回收内存，协调内存资源</li>\n<li>设备管理</li>\n<li>文件管理</li>\n<li>提供用户接口</li>\n</ul>\n<h2 id=\"cpu内部结构\"><a class=\"anchor\" href=\"#cpu内部结构\">#</a> CPU 内部结构</h2>\n<ul>\n<li>计算逻辑单元 ALU</li>\n<li>寄存器</li>\n<li>控制器</li>\n<li>缓存</li>\n<li>内存管理单元 MMU</li>\n</ul>\n<h2 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h2>\n<ul>\n<li>程序计数器 <code>(prgram counter, PC)</code> ：用于存放下一条运行指令的地址.</li>\n<li>指令寄存器 <code>(Instraution Register, IR)</code> ：用于存放当前正在执行的指令.</li>\n<li>程序状态字 <code>(Program Status Word, PSW)</code></li>\n<li>累加寄存器 <code>(Accumulator Register, AX)</code> ：</li>\n<li>基地寄存器 <code>(Base Register, BX)</code></li>\n<li>变址寄存器</li>\n</ul>\n<h2 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">#</a> 进程与线程</h2>\n<p>进程是程序执行的一个过程，其实资源分配的基本单位，各个进程拥有自己独立的虚拟地址空间，执行互不干扰；同时父进程创建出的自进程之间也互不影响，子进程的崩溃或父进程的崩溃对互相并不影响。进程主要由程序段、数据段和程序控制块组成.</p>\n<blockquote>\n<ol>\n<li>程序段：程序运行的代码</li>\n<li>数据段：程序运行所产生的数据（全局变量、局部变量）</li>\n<li>程序控制块：操作系统对该进程进行管理所涉及到的各种信息\n<ul>\n<li><code>PID</code> ：进程标识符</li>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>程序计数器 PC</li>\n<li>内存指针</li>\n<li>上下文数据</li>\n</ul>\n</li>\n</ol>\n<p>在 <code>Linux</code>  中通过 <code>fork</code>  函数来创建一个子进程，子进程会拷贝父进程的；</p>\n<p>同一个进程共享堆、全局变量、静态变量，但是线程独占栈、程序计数器</p>\n</blockquote>\n<p>线程是进程内部的一个控制序列，其是 <code>CPU</code>  资源调度的基本单位，其是在进程内部运行，本质是在进程的地址空间运行，其可以和其他线程共享该进程的一些资源，比如全局变量、堆空间。但是每个线程也有自己独立的线程 ID，栈空间和程序计数器.</p>\n<h2 id=\"多线程与多进程\"><a class=\"anchor\" href=\"#多线程与多进程\">#</a> 多线程与多进程</h2>\n<blockquote>\n<p>多进程的优点：</p>\n<ul>\n<li>各个进程拥有自己独立的虚拟地址空间，各个程序之间的执行互不干扰，而且子进程的崩溃不会影响父进程，反之父进程崩溃也不会影响子进程</li>\n<li>多个进程可以充分利用 CPU，并行执行程序，不用担心并行执行程序导致的问题</li>\n</ul>\n<p>多线程的缺点：</p>\n<ul>\n<li>由于进程的独立性，不同进程之间数据交换需要进程通信</li>\n<li>创建一个子进程的开销比创建一个子线程的开销大</li>\n<li>线程的切换比进程的切换系统开销会更大【切换页表、切换内核栈和硬件上下文（进程切换之后，新程序的虚拟地址在 TLB 内失效，会导致频繁的访存）】</li>\n</ul>\n<p>多线程的优点：</p>\n<p>多线程的缺点：</p>\n</blockquote>\n<h2 id=\"进程调度算法\"><a class=\"anchor\" href=\"#进程调度算法\">#</a> 进程调度算法</h2>\n<ul>\n<li>先来先服务 <code>FCFS(First Come First Serverd)</code> ：按照请求的顺序进行调度（不利于短作业，不会导致饿死）</li>\n<li>短作业优先 <code>SJF(Shortest Job First)</code> ：按估计运行时间最短的顺序进行调度（不利于长作业，会导致饿死）</li>\n<li>最短剩余时间有优先</li>\n<li>时间片轮转</li>\n<li>优先级调度</li>\n<li>多级反馈队列：在一定程度上减少了频繁的进程切换的开销.</li>\n</ul>\n<h2 id=\"进程状态切换\"><a class=\"anchor\" href=\"#进程状态切换\">#</a> 进程状态切换</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg\" alt=\"\" title=\"进程状态切换\" /></p>\n<h2 id=\"进程间通信ipc方式\"><a class=\"anchor\" href=\"#进程间通信ipc方式\">#</a> 进程间通信 IPC 方式</h2>\n<blockquote>\n<p>两个或多个进程之间产生的数据交互</p>\n</blockquote>\n<ul>\n<li>\n<p>管道：半双工通信，数据只能单向流动.</p>\n<blockquote>\n<p>在内核中开辟一块缓冲区，进程 A 把数据从用户区拷贝到内核缓冲区，进程 B 再从内核缓冲区把数据读走.</p>\n</blockquote>\n<ul>\n<li>\n<p>匿名管道：具有情缘关系的进程之间的通信方式（具有同一个祖先）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> pipefd<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  1. pipefd [0]: 读端 read (管道空时堵塞)</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  2. pipefd [1]: 写端 write (管道满时堵塞)</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>*/</span></pre></td></tr></table></figure></li>\n<li>\n<p>有名管道：不相干的两个进程之间的通信方式</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/stat.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">mkfifo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>path<span class=\"token punctuation\">,</span> mode_t mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    path: 创建的命名管道的全路径名：</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mod: 为指定了文件的读写权限； </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>*/</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>共享内存 <code>(Shared Memory Segment)</code> ：由一个进程创建，多个进程都可以访问的一段内存空间。通过 <code>shmat</code>  可以将共享内存空间关联到指定的进程地址空间中</p>\n</li>\n<li>\n<p>消息队列</p>\n</li>\n<li>\n<p><code>Socket</code>  套接字：适用于不同主机之间的通信，也可以用于同一主机两个进程之间的通信</p>\n</li>\n<li>\n<p>信号 <code>Signal</code></p>\n</li>\n<li>\n<p>信号量</p>\n</li>\n</ul>\n<h2 id=\"进程同步\"><a class=\"anchor\" href=\"#进程同步\">#</a> 进程同步</h2>\n<ul>\n<li>互斥锁 + 条件变量</li>\n<li>信号量</li>\n<li>管程</li>\n</ul>\n<h2 id=\"多线程模型\"><a class=\"anchor\" href=\"#多线程模型\">#</a> 多线程模型</h2>\n<blockquote>\n<ul>\n<li>用户级线程</li>\n</ul>\n</blockquote>\n<h2 id=\"锁机制\"><a class=\"anchor\" href=\"#锁机制\">#</a> 锁机制</h2>\n<ul>\n<li>读写锁</li>\n<li>互斥锁</li>\n<li>条件变量</li>\n<li>自旋锁</li>\n</ul>\n<h2 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h2>\n<p>死锁是两个或两个以上的线程在执行的过程中，去争夺同一个共享资源锁导致的互相等待的一个现象，在没有外部干预的情况下，这些线程会一直处于堵塞状态，无法往下去执行.</p>\n<p>死锁产生的四个条件：</p>\n<blockquote>\n<ol>\n<li>互传条件</li>\n<li>请求与保持条件</li>\n<li>不剥夺条件</li>\n<li>循环等待条件</li>\n</ol>\n</blockquote>\n<h2 id=\"防止死锁的方法\"><a class=\"anchor\" href=\"#防止死锁的方法\">#</a> 防止死锁的方法</h2>\n<ol>\n<li>在第一次执行的时候一次性申请所有的共享资源</li>\n<li>占用部分资源的进程在进一步去申请其他共享资源的时候，如果申请不到，就主动释放它所占有的资源</li>\n</ol>\n<h2 id=\"银行家算法\"><a class=\"anchor\" href=\"#银行家算法\">#</a> 银行家算法</h2>\n<h2 id=\"连续内存分配\"><a class=\"anchor\" href=\"#连续内存分配\">#</a> 连续内存分配</h2>\n<ul>\n<li>\n<p>单一连续分配</p>\n<blockquote>\n<p>内存中只有一道用户程序用户独占整个用户区空间，无外部碎片，有内部碎片；可以使用覆盖技术进行逻辑扩容，不需要采用内存保护</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"单一连续分配\" /></p>\n</li>\n<li>\n<p>固定分区分配（无外部碎片，会产生内部碎片）</p>\n<blockquote>\n<ol>\n<li>分区大小相等（固定）：缺乏灵活性</li>\n<li>分区大小不等（固定）</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png\" alt=\"\" title=\"固定分区分配\" /></p>\n</li>\n<li>\n<p>动态内存分配：不会预先划分内存空间</p>\n<blockquote>\n<ol>\n<li>首次适应算法：每次都从地地址开始查找，找到第一个能满足大小的空闲分区</li>\n<li>最佳适应算法：选择尽可能小的内存分区分配给进程；空闲分区按照容量递增次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能满足要求的空闲分区</li>\n<li>最坏适应算法：每次分配时使用最大的空闲内存区，为了过多的内存碎片；空闲分区安容量递减的次序链接，每次分配内存时按顺序查找空闲分区链，找到第一个能过满足要求的空闲分区</li>\n<li>邻近适应算法： <code>首次适应算法</code> 每次都要从链表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，每次查找时需要进过这些分区，增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决这个问题.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"空闲内存的管理方式\"><a class=\"anchor\" href=\"#空闲内存的管理方式\">#</a> 空闲内存的管理方式</h2>\n<ul>\n<li>空闲链表</li>\n<li>位图：将内存划分为均等的分配单元，每个分配单元对应于位图中的一位，0 表示空闲，1 表示占用；分配单元的大小是一个值得考量的问题，分配单元太小会使得位图占用的空间过大，如果分配单元过大，内造成内部碎片。当需要分配一定大小空间的内存时，需要遍历真个位图，依次检查，时间复杂度较高.</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png\" alt=\"\" /></p>\n<h2 id=\"内存紧缩与交换式碎片整理\"><a class=\"anchor\" href=\"#内存紧缩与交换式碎片整理\">#</a> 内存紧缩与交换式碎片整理</h2>\n<h2 id=\"非连续内存分配\"><a class=\"anchor\" href=\"#非连续内存分配\">#</a> 非连续内存分配</h2>\n<blockquote>\n<ol>\n<li>连续内存空间分配，需要给程序分配连续空间，同时会产生外部碎片，内存利用率不高</li>\n<li>非连续内存分配优点：\n<ul>\n<li>程序的物理地址空间是非连续的，更好的利用内存空间</li>\n<li>允许共享代码与数据</li>\n<li>支持动态加载和动态链接</li>\n</ul>\n</li>\n<li>非连续内存分配缺点：建立虚拟地址空间到物理地址空间的转换</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>分段</p>\n<blockquote>\n<ol>\n<li>分段的寻址方式</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E6%AE%B5%E9%80%89%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分段的寻址方式\" /></p>\n</li>\n<li>\n<p>分页</p>\n<blockquote>\n<ol>\n<li>逻辑页 <code>page</code>  和物理页 <code>frame(帧)</code>  的大小一致</li>\n<li>不是所有的页都有对应的帧</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png\" alt=\"\" title=\"分页寻址方式\" /></p>\n</li>\n<li>\n<p>分段与分页的区别</p>\n<blockquote>\n<ol>\n<li>分页对程序员是透明的，但是分段需要程序员显示的划分每个段</li>\n<li>页的大小不可改变，段的大小可动态变化</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"页表\"><a class=\"anchor\" href=\"#页表\">#</a> 页表</h2>\n<ul>\n<li>\n<p>标志位</p>\n<blockquote>\n<ol>\n<li>访问位：表示当前页之前是否被访问过</li>\n<li>修改位：表示当前页之前是否被修改过</li>\n<li>保护位：表示是否允许对该页做任何类型的操作（读、写、可执行等)</li>\n<li>驻留位：表示该页是在 <code>内存</code> 中还是在 <code>外存</code> 中</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>帧号</p>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt=\"\" title=\"页表结构\" /></p>\n<blockquote>\n<ul>\n<li>由于逻辑空间很大，导致程序对应的页表会很大，无法存储在 CPU 内，所以页表一般放置在内存中，如没有任何其他优化机制，使用分页存储访问一个内存空间需要 2 次访存.</li>\n<li>时间优化：TLB</li>\n<li>空间优化：多级页表、反向页表</li>\n</ul>\n</blockquote>\n<h2 id=\"tlb\"><a class=\"anchor\" href=\"#tlb\">#</a> TLB</h2>\n<blockquote>\n<p><code>TLB(Translation Look-aside Buffer)</code> ：在 CPU 内的 MMU 中，用于缓存近期访问的页帧转换表项；使用相关存储器实现，时间局部性原理；若 TLB 命中则只需要一次访存，若 TLB missing，则需要两次访存.</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/TLB.png\" alt=\"\" title=\"TLB\" /></p>\n<h2 id=\"多级页表\"><a class=\"anchor\" href=\"#多级页表\">#</a> 多级页表</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png\" alt=\"\" title=\"多级页表\" /></p>\n<h2 id=\"反向页表\"><a class=\"anchor\" href=\"#反向页表\">#</a> 反向页表</h2>\n<h2 id=\"分段与分页对比\"><a class=\"anchor\" href=\"#分段与分页对比\">#</a> 分段与分页对比</h2>\n<h2 id=\"覆盖技术\"><a class=\"anchor\" href=\"#覆盖技术\">#</a> 覆盖技术</h2>\n<blockquote>\n<p>需要程序员自己把挣个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</p>\n</blockquote>\n<h2 id=\"交换技术\"><a class=\"anchor\" href=\"#交换技术\">#</a> 交换技术</h2>\n<blockquote>\n<p>以程序作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</p>\n</blockquote>\n<h2 id=\"虚拟技术\"><a class=\"anchor\" href=\"#虚拟技术\">#</a> 虚拟技术</h2>\n<blockquote>\n<p>虚拟技术是把一个物理实体转化为多个逻辑实体</p>\n</blockquote>\n<ul>\n<li>\n<p>时空复用技术</p>\n<blockquote>\n<p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时空复用技术，当每个进程轮流占用 CPU</p>\n</blockquote>\n</li>\n<li>\n<p>空分复用技术</p>\n<blockquote>\n<p>虚拟内存：将物理内存抽象为逻辑地址空间，每个进程都有各自的地址空间.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"虚拟内存\"><a class=\"anchor\" href=\"#虚拟内存\">#</a> 虚拟内存</h2>\n<blockquote>\n<ol>\n<li>将物理空间扩充为更大的逻辑空间</li>\n<li>在装入程序时，不必将其全部装入内存，而只需将当前需要执行的部分页面或段装入内存，就可以让程序开始执行</li>\n<li>在程序执行过程中，如果执行的指令或访问的数据不在内存中（ <code>缺页</code> 或 <code>缺段</code> ），则由处理器通知操作系统将相应的页面或段调入内存，然后继续执行程序</li>\n<li>另一方面，操作系统将内存中暂时不适用的页面或段调出保存到磁盘中，从而腾出更多的空闲空间存放将要装入的程序</li>\n</ol>\n</blockquote>\n<h2 id=\"缺页中断处理过程\"><a class=\"anchor\" href=\"#缺页中断处理过程\">#</a> 缺页中断处理过程</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"页面置换算法\"><a class=\"anchor\" href=\"#页面置换算法\">#</a> 页面置换算法</h2>\n<blockquote>\n<p>当缺页中断发生时，需要调入新的页面而内存已满时，选择内存当中那个物理页面进行替换（更可能减少换入换出的次数）</p>\n</blockquote>\n<ol>\n<li>\n<p>最优页面置换算法：将未来最久不会被访问的页面置换出去（理想情况）</p>\n</li>\n<li>\n<p>先进先出算法</p>\n</li>\n<li>\n<p>最近最久未使用 <code>LRU,Least Recently Used</code></p>\n<ol>\n<li>时钟页面置换算法 <code>CLOCK</code> ：最近未用算法</li>\n</ol>\n</li>\n<li>\n<p>二次机会法</p>\n</li>\n<li>\n<p>最不常用算法 <code>LFU,Least Frequently Used</code></p>\n</li>\n</ol>\n<blockquote>\n<p><code>Belady</code>  现象：分配的物理页面数增加，缺页率反而提高的异常现象（没有考虑进程访问的动态特征导致的， <code>FIFO</code> ）</p>\n</blockquote>\n<h2 id=\"虚拟地址转换位物理地址的过程\"><a class=\"anchor\" href=\"#虚拟地址转换位物理地址的过程\">#</a> 虚拟地址转换位物理地址的过程</h2>\n<h2 id=\"malloc申请内存时操作系统会怎么做\"><a class=\"anchor\" href=\"#malloc申请内存时操作系统会怎么做\">#</a>  <code>malloc</code>  申请内存时操作系统会怎么做？</h2>\n<p><code>malloc</code>  会调用 <code>brk</code>  和 <code>mmap</code>  两个系统调用来实现.</p>\n<h2 id=\"磁盘调度算法\"><a class=\"anchor\" href=\"#磁盘调度算法\">#</a> 磁盘调度算法</h2>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlFNDExRDduSC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT0zZmNhYTQ5NjM0NDM1MzcyM2ExZWMwZWEzZDAxMDQxZQ==\">王道计算机考研 操作系统_哔哩哔哩_bilibili</span></li>\n<li>[2] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXVXNDExZjcybi8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">清华 操作系统原理_哔哩哔哩_bilibili</span></li>\n<li>[3] <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODA4NzI5MjA=\">操作系统常见面试题</span></li>\n<li>[4] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE1OTY1\">这 50 道操作系统面试题，真牛批！</span></li>\n</ul>\n",
            "tags": [
                "面试题",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/C++%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/C++%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "C++面试题",
            "date_published": "2024-03-08T13:53:12.049Z",
            "content_html": "<h1 id=\"c面试题\"><a class=\"anchor\" href=\"#c面试题\">#</a> C++ 面试题</h1>\n<h2 id=\"程序编译过程\"><a class=\"anchor\" href=\"#程序编译过程\">#</a> 程序编译过程</h2>\n<ul>\n<li>\n<p>预处理</p>\n<ol>\n<li>完成宏定义 <code>#define</code>  内容替换</li>\n<li>处理所有的条件预编译指令，如 <code>#if #endif</code></li>\n<li>把 <code>#include</code>  文件内容复制到 <code>.cpp</code>  文件中（递归执行）</li>\n<li>删除所有注释</li>\n</ol>\n</li>\n<li>\n<p>编译：转化为汇编代码，主要工作是检查一些语法规则，代码优化（寻找合适的寻址方式，使用位运算来替代乘法运算，删除多余的指令）</p>\n</li>\n<li>\n<p>汇编：将汇编代码转化为二进制格式的文件（机器码）</p>\n</li>\n<li>\n<p>链接：将多个目标文件以及库文件链接成最终的可执行文件</p>\n<ol>\n<li>\n<p>静态链接：在链接阶段将库文件的函数和数据合并到应用程序中，组成一个最终的可执行文件.</p>\n<blockquote>\n<ul>\n<li>\n<p>运行速度快：可执行程序中具备运行阶段所需要的所以东西</p>\n</li>\n<li>\n<p>空间浪费：可执行程序中有所以目标文件的副本。当多个程序对同一个目标文件有依赖关系时，那么这个目标文件在内存中会有多个副本</p>\n</li>\n<li>\n<p>当其中一个库文件需要修改，整个程序需要重新编译</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>动态链接：在程序运行阶段才把多个目标文件链接成一个完整的程序.</p>\n<blockquote>\n<ul>\n<li>\n<p>运行效率会有所损耗</p>\n</li>\n<li>\n<p>节省空间：共享库</p>\n</li>\n<li>\n<p>更新方便：只需要重新编译修改的目标文件</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"cc内存空间\"><a class=\"anchor\" href=\"#cc内存空间\">#</a> C/C++ 内存空间</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4C.jpg\" alt=\"\" width=\"200px\" /><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png\" alt=\"\" width=\"200px\" /></p>\n<ul>\n<li>栈：用于存储局部变量，由编译器自动管理分配与释放，效率很高，但是内存有限</li>\n<li>堆：动态内存空间，由应用程序去控制。如若程序结束没有释放，则会由操作系统自动回收.</li>\n<li>代码区：存放函数体二进制代码</li>\n<li>全局 / 静态存储区：用于存储全局变量和静态变量。在以前 C 语言中，这部分分为初始化的 <code>.data</code>  和未初始化 <code>.bss</code> . 现在 C++ 中则没有这样的划分，区域内的变量会被默认初始化为 0.</li>\n<li>常量存储区：用于存储常量，不允许修改</li>\n</ul>\n<h2 id=\"堆与栈\"><a class=\"anchor\" href=\"#堆与栈\">#</a> 堆与栈</h2>\n<ul>\n<li>栈内存是由编译器自动管理的，堆可由程序员控制，对于开辟的内存需要主动释放，否则容易产生内存泄漏</li>\n<li>栈的内存增长方向是向着地址空间减小的方向，堆内存的增长方向是朝着地址空间增大的方向.</li>\n<li>栈分配的内存都是连续空间，同时是一个先进后出的数据结构，其不存在内存碎片的问题。堆所分配的内存空间不一定连续，会存在内存碎片的问题</li>\n<li>栈的分配效率要高于堆的分配效率。操作系统内有专门的寄存器用于存储栈的地址和栈顶指针地址。堆的内存分配是调用 C/C++ 的库函数，分配空间时还需要按照不同的算法去搜索足够大的空间进行分配。同时由于内存碎片问题，操作系统会进行内存紧缩的操作，需要额外的系统开销.</li>\n</ul>\n<h2 id=\"函数调用的过程\"><a class=\"anchor\" href=\"#函数调用的过程\">#</a> 函数调用的过程</h2>\n<h2 id=\"计算机内部数据的存储\"><a class=\"anchor\" href=\"#计算机内部数据的存储\">#</a> 计算机内部数据的存储</h2>\n<ul>\n<li>\n<p>整数：通过补码的形式进行存储（整数的补码是本省，负数的补码是取反 + 1）</p>\n</li>\n<li>\n<p><code>float</code>  的存储，遵循 <code>IEEE</code>  规范，占用 32 位（4 字节）.</p>\n<blockquote>\n<ol>\n<li>符号位（1bit）</li>\n<li>指数位（8bit）</li>\n<li>尾数部分（23bit）</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/float%E7%9A%84%E5%AD%98%E5%82%A8.webp\" alt=\"\" title=\"float的存储\" /></p>\n<ul>\n<li>\n<p><code>double</code>  的存储，遵循 <code>IEEE</code>  规范，占用 64 位（8 字节）.</p>\n<blockquote>\n<ol>\n<li>符号位（1bit）</li>\n<li>指数位（11bit）</li>\n<li>尾数部分（52bit）</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/double%E7%9A%84%E5%AD%98%E5%82%A8.jpg\" alt=\"\" title=\"double的存储\" /></p>\n</li>\n</ul>\n<h2 id=\"static\"><a class=\"anchor\" href=\"#static\">#</a> static</h2>\n<ul>\n<li><code>static</code>  修饰局部变量：改变变量的存储位置（由栈区转移到静态存储区），延长了变量的生命周期； <code>static</code>  局部变量只在当前的作用域内有效，在作用外无法访问.</li>\n<li><code>static</code>  修饰全局变量：只能在当前源文件内有效，在其他源文件内无法访问. （无 <code>static</code>  修饰的全局变量可以在其他源文件中使用 extern 申明其他源文件中的全局变量，即可在当前源文件中使用）</li>\n<li><code>static</code>  修饰函数：和 <code>static</code>  用于修饰全局变量具有一样的特性</li>\n<li><code>static</code>  修饰成员变量：静态成员变量，为类所以，可供所以对象共享，不占用实例的存储空间，同时其初始化必须定义外类外部</li>\n<li><code>static</code>  修饰成员函数：静态成员函数，没有隐藏的 <code>this</code>  指针，因此函数体内不能访问该类的非静态成员变量</li>\n<li><code>static</code>  修饰的变量默认初始化为 0</li>\n</ul>\n<h2 id=\"const\"><a class=\"anchor\" href=\"#const\">#</a> const</h2>\n<ul>\n<li><code>const</code>  修饰的变量值不可变修改</li>\n<li><code>const</code>  成员变量：不能在类外初始化，只能通过构造函数初始化列表进行初始化</li>\n<li><code>const</code>  修饰的函数为常函数，不能改变类的成员变量（可以修改被 <code>mutable</code>  修饰的变量）</li>\n<li><code>const</code>  对象不能调用非 <code>const</code>  成员函数（防止类的非常函数对 <code>const</code>  对象的成员变量进行修改）</li>\n</ul>\n<h2 id=\"mutable\"><a class=\"anchor\" href=\"#mutable\">#</a> mutable</h2>\n<blockquote>\n<p><code>mutable</code>  与 <code>const</code>  是相对的，表示一个变量的易变的；被 <code>mutable</code>  修饰是成员变量可以再 <code>const</code>  修饰的函数内被修改（也可以被常对象进行直接修改）</p>\n</blockquote>\n<h2 id=\"explicit\"><a class=\"anchor\" href=\"#explicit\">#</a> explicit</h2>\n<blockquote>\n<p>用于修饰类的构造函数，防止其他对象隐式的转化为该类对象，只能显示的进行类型转化</p>\n</blockquote>\n<h2 id=\"volatile\"><a class=\"anchor\" href=\"#volatile\">#</a> volatile</h2>\n<ul>\n<li>用于修饰变量，表示其值随时可能发送变化，编译器不会对访问该变量的代码进行优化，可以保证访问变量的稳定（从内存中读取）</li>\n<li><code>volatile</code>  指针</li>\n<li>多线程下的 <code>volatile</code> ：当多个线程都需要用到某一个变量时，应该用 <code>volatile</code> ，防止编译器把变量从内存装入 CPU 寄存器中</li>\n</ul>\n<h2 id=\"c三大特性\"><a class=\"anchor\" href=\"#c三大特性\">#</a> C++ 三大特性</h2>\n<ul>\n<li>封装、继承、多态（封装和继承可以实现 <code>代码的重用</code> ，多态可以实现 <code>接口的重用</code> ）\n<ol>\n<li>\n<p>封装：将数据和实现过程包裹起来，隐藏代码的实现细节，通过定义的接口来访问数据成员，使代码模块化. (直接体现面向对象，代码重用，权限控制)</p>\n<ul>\n<li><code>public</code> ：公有权限，类内可以访问，类外也可以访问</li>\n<li><code>protected</code> ：保护权限，类内可以访问，类外不可以访问</li>\n<li><code>private</code> ：私有权限，类内可以访问，类外不可以访问</li>\n</ul>\n</li>\n<li>\n<p>继承：无需重新编写代码而可以直接使用现有类的所以功能，同时可以对现有类进行功能上的扩展，是一个从一般到特殊的过程.</p>\n<ul>\n<li>权限继承：表示基类在子类中的最高权限（破坏继承： <code>friend</code> ，  <code>using</code> ）</li>\n<li>多继承：通过多继承可以得到更多类的数据和方法，实现更大程度的代码复用，当然也存在一些问题，如菱形继承.</li>\n</ul>\n</li>\n<li>\n<p>多态：通过父类指针指向多个派生的子类对象时，调用父类的一个接口，可以实现多种不同的行为即为多态.</p>\n<ul>\n<li>\n<p>被 <code>virtual</code>  修饰的成员函数即为虚函数，如基类的虚函数为空即为纯虚函数，这个类即可为抽象类，不能被实例化，否则就是一个虚类，可被实例化.</p>\n</li>\n<li>\n<p>在编译阶段，虚类内会隐藏的存储一个虚函数表指针的成员变量，指向一张虚函数表，该类的所以对象共用这张虚函数表.</p>\n</li>\n<li>\n<p>派生类继承虚类时，其会复制一份父类的虚函数表，类内的虚函数指针指向这张新的虚函数表，如派生类重写了虚函数则会将对应的虚函数表对应的指针项做一个修改，如果派生类定义了新的虚函数，则会在新的虚函数表后追加新的函数与地址的映射. （如若派生类继承了多个父类，即多继承，那么这个派生类可能存储多个虚函数表指针）</p>\n</li>\n<li>\n<p>虚析构函数：基类中析构函数前使用 <code>virtual</code>  修饰。当基类指针指向派生类对象时，使用基类指针去释放空间时，则会去先调用派生类的析构函数，再去调用基类的析构函数；若不加 <code>virtual</code>  则不会触发动态绑定（多态），只会调用基类的析构函数，导致内存泄漏. (虽然虚构函数名不一样，其实也是一种重写，系统内部对析构函数做了特殊处理，将析构函数名称都改成了 <code>destructor</code> )</p>\n</li>\n<li>\n<p>虚函数地址在运行时绑定（函数地址在运行阶段确定），使用了虚函数表的机制，所以在调用的时候会增加一次内存开销. （虚函数的缺点）</p>\n</li>\n<li>\n<p>协变：基类和派生类虚函数的返回值不同（基类返回基类对象的指针或引用，派生类返回派生类对象的指针或引用），其也是一种多态</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">virtual</span> User <span class=\"token operator\">*</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"return user\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Manager</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">virtual</span> Manager <span class=\"token operator\">*</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"return manager\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    Manager mg<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    User<span class=\"token operator\">*</span> ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>mg<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    ptr<span class=\"token operator\">-></span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"菱形继承\"><a class=\"anchor\" href=\"#菱形继承\">#</a> 菱形继承</h2>\n<h2 id=\"为什么c默认析构函数不是虚函数\"><a class=\"anchor\" href=\"#为什么c默认析构函数不是虚函数\">#</a> 为什么 C++ 默认析构函数不是虚函数</h2>\n<blockquote>\n<p>虚函数需要虚函数表和虚函数表指针，会占用内存空间。如果一个类没有子类，那么就没有必要讲析构函数设置为虚函数</p>\n</blockquote>\n<h2 id=\"重载-重写-重定义\"><a class=\"anchor\" href=\"#重载-重写-重定义\">#</a> 重载、重写、重定义</h2>\n<ul>\n<li>重载：多个同名函数，他们的参数个数或者参数类型不同；（编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就变成了不同的函数），也可以称之为静态多态，函数地址在编译器就已经确定了</li>\n<li>重定义：继承中的同名隐藏，当派生类中有一个函数与基类的函数名相同，不管参数是否相同，只要该函数不为虚函数，发生了重定义.</li>\n<li>重写：派生类中重写了基类的虚函数，其中函数名、参数列表和返回值都相同</li>\n</ul>\n<h2 id=\"final和override\"><a class=\"anchor\" href=\"#final和override\">#</a> final 和 override</h2>\n<ul>\n<li><code>final</code> ：修饰虚函数，表示该虚函数不能再被重写。修饰类表示该类不能被继承</li>\n<li><code>override</code> ：检查派生类虚函数是否重写了基类的某个虚函数，如果没有则编译器报错；</li>\n</ul>\n<h2 id=\"struct-与class\"><a class=\"anchor\" href=\"#struct-与class\">#</a> struct 与 class</h2>\n<ul>\n<li>C++ 中的 <code>struct</code>  默认 <code>public</code>  共有权限， <code>class</code>  默认 <code>private</code>  私有权限</li>\n<li>C 语言中的 <code>struct</code>  只是一个变量的集合体，只可以用于封装数据，而不备面向对象的一些特性</li>\n</ul>\n<h2 id=\"new-和-malloc的区别\"><a class=\"anchor\" href=\"#new-和-malloc的区别\">#</a> new 和 malloc 的区别</h2>\n<p><code>new</code>  和 <code>malloc</code>  都是用于分配内存的，其中 <code>new</code>  是 C++ 中的操作符，可以被重载， <code>malloc</code>  是 C 语言中的库函数，不可以被重载</p>\n<ol>\n<li>参数不同；new 可以自动计算所分配的对象的内存大小，同时返回值为指向该对象的指针. malloc 则需要传入需要分配的内存的字节数，返回一个 <code>void *</code>  指针</li>\n<li>new 分配失败会抛出异常 <code>bac_alloc</code> ，malloc 分配失败会返回 <code>NULL</code></li>\n<li>new 分配的内存在 <code>free store</code> （自由存储区）上，malloc 分配的内存在堆上（其中自由存储区是 C++ 中的一个抽象的概念，new 的底层调用的逻辑是先调用 <code>operator new</code>  分配内存，由系统决定或者用户重载 <code>operator new</code>  决定，其次是调用对象的构造函数，初始化成员变量）</li>\n<li><code>malloc</code>  分配的内存是虚拟内存，而 <code>new</code>  分配的内存是物理内存。因为 new 调用了对象的构造函数，对对象成员进行了初始化（发生了缺页中断，使得虚拟内存映射到了物理内存）</li>\n</ol>\n<h2 id=\"delete-与-free\"><a class=\"anchor\" href=\"#delete-与-free\">#</a> delete 与 free</h2>\n<p><code>delete</code>  和 <code>free</code>  都是用于释放内存的，其中 <code>delete</code>  是 C++ 中的操作符，可以被重载，free 是 C 语言中的库函数，不可以被重载</p>\n<ol>\n<li>参数不同；delete 需要给出释放的对象的类型指针，free 可以是 <code>void *</code>  类型的指针（delete 底层调用的逻辑是先调用对象的析构函数，再调用 <code>operator delete</code>  释放对象所占内存）（free 只需要提供 <code>void *</code>  就可以释放申请的所以内存： <code>malloc</code>  在分配内存时，不仅仅是分配了用户所需要的内存空间的大小，还会在该空间上部分配额外的一部分空间用于存储此次分配的内存的描述信息）</li>\n</ol>\n<blockquote>\n<p>注意： <code>delete</code>  和 <code>free</code>  被调用后，指针也不会指向空，如果没有其他用途，需要把它设置为 <code>nullptr</code> ，否则会出现野指针.</p>\n</blockquote>\n<h2 id=\"free回收的内存是立即返回给操作系统吗\"><a class=\"anchor\" href=\"#free回收的内存是立即返回给操作系统吗\">#</a> free 回收的内存是立即返回给操作系统吗？</h2>\n<ul>\n<li>不是的。被 <code>free</code>  回收的内存会被 <code>ptmalloc</code>  使用双链表保存起来，当用户下一次申请内存空间的时候，会尝试先从这些内存中寻找合适的返回.</li>\n<li>可以避免频繁的系统调用，提高程序效率.</li>\n<li><code>ptmalloc</code>  也会尝试对小块进行合并，避免过多的内存碎片</li>\n</ul>\n<blockquote>\n<p><strong>C++11</strong> is the second major version of C++ and the most important update since C<ins>98. A large number of changes were introduced to both standardize existing practices and improve the abstractions available to the C</ins> programmers.</p>\n</blockquote>\n<h2 id=\"new与delete\"><a class=\"anchor\" href=\"#new与delete\">#</a> new [] 与 delete []</h2>\n<ul>\n<li><code>new[]</code>  会先调用 <code>operateor new[]</code>  分配内存，然后再分配的内存的前几个字节写入数组的大小，然后进行 n 次构造函数</li>\n</ul>\n<h2 id=\"malloc与free实现原理\"><a class=\"anchor\" href=\"#malloc与free实现原理\">#</a> malloc 与 free 实现原理</h2>\n<h2 id=\"c中的几种new\"><a class=\"anchor\" href=\"#c中的几种new\">#</a> C++ 中的几种 new</h2>\n<ul>\n<li><code>new</code> ： <code>plain new</code> ，分配内存失败会抛出异常</li>\n<li><code>nothrow new</code> ：分配内存失败不抛出异常，而是返回 <code>nullptr</code></li>\n<li><code>placement new</code> ：不会分配内存，在已有的内存空间上重新构造对象</li>\n</ul>\n<h2 id=\"c强制类型转换\"><a class=\"anchor\" href=\"#c强制类型转换\">#</a> C++ 强制类型转换</h2>\n<ul>\n<li>\n<p><code>static_cast&lt;T&gt;()</code> ：不进行类型检查，不安全</p>\n<blockquote>\n<ol>\n<li>用于层次结构中基类与派生类间指针的转换</li>\n</ol>\n<p>a. 上行转换（派生类指针转化为基类指针），安全</p>\n<p>b. 下行转化（基类指针转化为派生类指针），不安全</p>\n<ol start=\"2\">\n<li>基本数据类型的转化</li>\n<li>将空指针转化为目标类型的指针</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>dynamic_cast</code> ：专门用于派生类与基类之间的类型转化，基类中必须有虚函数；会进行类型的检查，是一种安全类型转化（转换失败，指针为 <code>nullptr</code> ）</p>\n<blockquote>\n<ol>\n<li>运行时会进行类型的检查</li>\n<li>不能用于内置基本数据类型的转化</li>\n<li>如果转化成功的话会返回指向类的指针或引用，转换失败的话则会返回 <code>NULL</code></li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>reinterpret_cast</code> ：转化过程仅仅是简单的比特位拷贝，不安全</p>\n</li>\n<li>\n<p><code>const_cast&lt;T&gt;()</code> ：用于修改变量的 <code>const</code>  或 <code>volatile</code>  属性，变量类型与转换后的类型一致（只能修改底层 <code>const</code> ）</p>\n</li>\n</ul>\n<h2 id=\"指针与引用\"><a class=\"anchor\" href=\"#指针与引用\">#</a> 指针与引用</h2>\n<ul>\n<li>存储的是一个地址；而引用只是变量的别名.</li>\n<li>指针可不进行初始化，也可以指向空，并且指向可以改变；引用必须初始化，且只可绑定一个变量。这也导致了在使用指针时，往往需要判空操作，而引用是一种安全的指针，一定不为空（引用的底层是通过指针来实现）.</li>\n<li><code>sizeof</code>  指针得到的是指针的大小， <code>sizeof</code>  引用得到的是引用绑定对象的大小</li>\n<li>指针可以是多级的，引用只有一级</li>\n</ul>\n<h2 id=\"常引用\"><a class=\"anchor\" href=\"#常引用\">#</a> 常引用</h2>\n<ul>\n<li>\n<p>保护传递给函数的数据在函数内不背改变.  <code>const 类型&amp; 引用名</code></p>\n</li>\n<li>\n<p>在 C++ 中，临时对象都是 <code>const</code>  类型的，const 类型的对象转换为非 const 类型是非法的.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>string <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>string <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t    <span class=\"token comment\">//  非法</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 非法</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"野指针\"><a class=\"anchor\" href=\"#野指针\">#</a> 野指针</h2>\n<ul>\n<li>野指针：指向已被释放的内存空间或者指向没有访问权限的内存空间</li>\n<li>指针未被初始化、内存释放后未将指针设置为 <code>nullptr</code> 、指针超过了变量的作用范围（越界）都可能导致野指针的产生</li>\n</ul>\n<h2 id=\"c中的顶层const与底层const\"><a class=\"anchor\" href=\"#c中的顶层const与底层const\">#</a> C++ 中的顶层 const 与底层 const</h2>\n<ul>\n<li>\n<p><code>顶层const</code> ： <code>const</code>  修饰的变量本身是一个常量，无法修改；（指的是指针，出现在 <code>*</code>  的右边）</p>\n</li>\n<li>\n<p><code>底层const</code> ： <code>const</code>  修饰的变量所指向的对象是一个常量（出现在 <code>*</code>  左边）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">// 顶层 const</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">auto</span> other b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">//other 类型为 int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/* --------------- */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\t          <span class=\"token comment\">// 底层 const, 常量指针，表示指针所指向的内容无法通过该指针进行修改，但是可以改变指针的指向</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">auto</span> other1 <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span>\t\t          <span class=\"token comment\">//other1 类型为 const int*</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">*</span>other1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\t\t              <span class=\"token comment\">// error! </span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>other1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">;</span>\t\t\t    \t <span class=\"token comment\">// right!</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span> other2 <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span>\t\t  <span class=\"token comment\">//other2 类型为 const int *</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">*</span>other2 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\t\t              <span class=\"token comment\">// error! </span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>other2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">;</span>\t\t\t    \t <span class=\"token comment\">// right!</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* --------------- */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\t         <span class=\"token comment\">// 顶层 const，指针常量，表示指针是一个常量，不可修改指针的指向，但是可以通过指针去修改所指向空间的内容</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">auto</span> other1 <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span>\t\t        <span class=\"token comment\">//other1 类型为 int *</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token operator\">*</span>other1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\t\t            <span class=\"token comment\">// right!</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>other1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">;</span>\t\t   \t\t   <span class=\"token comment\">// right!</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span> other2 <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//other2 的类型为 int* const</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token operator\">*</span>other2 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// right!</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>other2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// error!</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"常量指针与指针常量\"><a class=\"anchor\" href=\"#常量指针与指针常量\">#</a> 常量指针与指针常量</h2>\n<ul>\n<li>常量指针： <code>int const* p = a</code> ，指针的指向可以改变，而不能通过该指针去改变所指向的内容</li>\n<li>指针常量： <code>int *const p = a</code> ，指针的指向不可改变，可以通过指针去改变指向的内容.</li>\n</ul>\n<h2 id=\"数组指针与指针数组\"><a class=\"anchor\" href=\"#数组指针与指针数组\">#</a> 数组指针与指针数组</h2>\n<ul>\n<li>\n<p>数组指针： <code>int (*p)[n]</code> ，指向一个整形的一维数组，这个数组的长度是 n，在执行 <code>p+1</code>  操作时， <code>p</code>  要跨越 n 个整形数据长度</p>\n</li>\n<li>\n<p>指针数组： <code>int *p[n]</code> ， <code>[]</code>  优先级高于 <code>*</code> ，是一个具有 n 个指针类型的数组.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//a 理解成一个一维数组，元素为 a [0], a [1], a [2]， 其中 a [0] 的类型为 (int *), a 与 & amp;a [0] 等价，类型为 int (*p)[4]</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"函数指针\"><a class=\"anchor\" href=\"#函数指针\">#</a> 函数指针</h2>\n<ul>\n<li>\n<p>函数指针的类型是由其返回类型和参数列表共同决定的</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//pf 为一个函数指针</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 区别于 int *pf (const int&amp;, const int&amp;);\tpf 为一个函数声明，函数返回值为 int</span></pre></td></tr></table></figure></li>\n<li>\n<p>函数指针的赋值</p>\n<ol>\n<li><code>指针名=函数名</code></li>\n<li><code>指针名=&amp;函数名</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"宏定义与typedef\"><a class=\"anchor\" href=\"#宏定义与typedef\">#</a> 宏定义与 typedef</h2>\n<ul>\n<li>宏定义主要用于定义常量或者一些书写复杂的内容， <code>typedef</code>  主要用于定义类型的别名</li>\n<li>宏定义在预处理阶段完成，只会进行文本的替换，不进行类型的检查； <code>typedef</code>  在编译阶段完成，会进行类型的检查</li>\n</ul>\n<h2 id=\"const与define\"><a class=\"anchor\" href=\"#const与define\">#</a> const 与 define</h2>\n<h2 id=\"inline内联函数\"><a class=\"anchor\" href=\"#inline内联函数\">#</a> inline 内联函数</h2>\n<ul>\n<li>把 inline 函数体复制到函数调用处（避免了函数调用所需要的压栈和出栈操作，提高了程序运行效率）</li>\n<li>特性类似于宏定义，但 inline 会做类型的检查</li>\n<li>不能包含循环、递归复杂操作</li>\n<li><code>inline</code>  函数有多个返回点，会使用 <code>goto</code>  跳转</li>\n<li>在类中定义的成员函数，除了虚函数，往往会自动转化为内联函数</li>\n<li>缺点：\n<ol>\n<li>代码膨胀，占用代码区的内存空间</li>\n<li>是否内敛由编译器决定，不可控.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"this指针\"><a class=\"anchor\" href=\"#this指针\">#</a> this 指针</h2>\n<ul>\n<li>this 是一个隐含于每一个非静态成员函数中的特殊指针，指向被实例化的对象。当调用对象成员函数时，会将对象的地址赋值给 <code>this</code>  指针，并会隐式的将 <code>this</code>  指针传入</li>\n<li><code>tihs</code>  为一个右值，并由 <code>const</code>  修饰</li>\n</ul>\n<h2 id=\"初始化列表c11\"><a class=\"anchor\" href=\"#初始化列表c11\">#</a> 初始化列表（C++11）</h2>\n<ul>\n<li>通过花括号来进行初始化。直接在变量名后面跟上初始化列表来进行对象的初始化</li>\n</ul>\n<h2 id=\"类成员函数初始化方法\"><a class=\"anchor\" href=\"#类成员函数初始化方法\">#</a> 类成员函数初始化方法</h2>\n<ul>\n<li>\n<p><code>赋值初始化</code> ：在函数体内进行赋值. (其是在所有成员被分配内存之后才进行的，此时会触发成员函数的默认构造函数，同时进入函数体赋值往往会产生临时对象，和拷贝赋值函数)</p>\n</li>\n<li>\n<p><code>列表初始化</code> ：在冒号后使用初始化列表进行初始化.（给数据成员分配内存时进行的，在函数体执行之前）</p>\n<blockquote>\n<p>对于基本数据类型而言，两种在速度方面没有太大的差别，但对于复杂一些的数据类型，列表初始化速度会快于赋值初始化</p>\n<p>什么情况下必须用初始化列表？</p>\n<ul>\n<li>初始化一个引用成员变量时</li>\n<li>初始化一个常量成员时</li>\n<li>当父类没有默认构造函数的时</li>\n<li>当成员变量没有默认构造函数时</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"autoc11\"><a class=\"anchor\" href=\"#autoc11\">#</a>  <code>auto（C++11）</code></h2>\n<ul>\n<li>\n<p><code>auto</code>  可以自动推导变量类型；使用 <code>auto</code>  声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译阶段将 <code>auto</code>  占位符替换成其真正的类型.</p>\n</li>\n<li>\n<p>对于有 <code>const</code>  和 <code>volatile</code>  修饰的变量， <code>auto</code>  只能推断底层 <code>const</code>  或 <code>volatile</code> ，顶层 <code>const</code>  或 <code>volatile</code>  会被忽略，需要自己添加</p>\n</li>\n<li>\n<p>不能在函数的参数中使用，不能用于定义数组，不能用于类的非静态成员的初始化（只能用于类的静态常量成员变量的初始化）</p>\n</li>\n<li>\n<p>不能用于模版参数的类型推导</p>\n<blockquote>\n<p>类的成员变量并不属于类，而属于具体的实例。如果没有创建实例，那么就没有办法进行自动类型推导.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"decltypec11\"><a class=\"anchor\" href=\"#decltypec11\">#</a>  <code>decltype（C++11）</code></h2>\n<blockquote>\n<p>我们希望从表达式（函数返回值）中推断出想要定义的变量的类型，但是却不想用表达式的值去初始化变量，这种情况 <code>auto</code>  显得无力了</p>\n</blockquote>\n<ul>\n<li>\n<p>推断表达式类型作为变量的定义类型</p>\n</li>\n<li>\n<p>推断函数返回值（实际不会调用，仅推断），推导出的对象类型与函数返回值一致</p>\n<blockquote>\n<p>当函数返回的是一个纯右值，需要忽略掉前面的 <code>const</code>  或 <code>volatile</code></p>\n</blockquote>\n</li>\n<li>\n<p>无论是底层 <code>const</code>  或 <code>volatile</code>  还是顶层 <code>const</code>  或 <code>volatile</code>  都会被保留</p>\n</li>\n<li>\n<p>表达式是一个左值，或者被 <code>()</code>  包围，使用 <code>decltype</code>  推导出来是表达式类型的引用（如果有 <code>const</code>  或 <code>volatile</code>  则需要加上）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//b 的类型为 int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c 的类型为 int&amp;，绑定 a 对象</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"范围for循环c11\"><a class=\"anchor\" href=\"#范围for循环c11\">#</a> 范围 for 循环（C++11）</h2>\n<h2 id=\"null与nullptr\"><a class=\"anchor\" href=\"#null与nullptr\">#</a>  <code>NULL</code>  与 <code>nullptr</code></h2>\n<ul>\n<li>\n<p><code>NULL</code>  来自 C 语言，由宏定义实现， <code>nullptr</code>  是 C++11 新增的关键字</p>\n</li>\n<li>\n<p>在 C 语言中 <code>NULL</code>  被定义成 <code>(void *)0</code> ，在 C++ 中则被定义成 <code>0</code> ，故引入 <code>nullptr</code>  替代了 <code>NULL</code></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">__cplusplus</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure></li>\n<li>\n<p>当有一个函数被重载时，且参数都是指针类型时，调用函数时需要明确强制转换成对应类型，否则编译器无法确定需要调用哪一个函数</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tcout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"char* p\"</span> <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tcout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"int* p\"</span> <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tcout<span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"int p\"</span> <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 语句 1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 语句 2</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 语句 3</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 运行结果：</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">// 语句 1：char* p</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 语句 2: 报错，有多个匹配</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">//3：int p</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"lambda表达式\"><a class=\"anchor\" href=\"#lambda表达式\">#</a> lambda 表达式</h2>\n<ul>\n<li>匿名函数。一个 <code>lambda</code>  表达式具有一个返回值、一个参数列表和一个函数体。与函数不同的是， <code>lambda</code>  表达式可以定义在函数体内部，格式为： <code>[capture list](parameter list) opt -&gt;return type &#123;function body&#125;</code> ，不能用默认参数.</li>\n<li><code>capture list</code> ：捕获列表\n<ol>\n<li><code>[]</code> ：不捕获任何变量</li>\n<li><code>[&amp;]</code> ：捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）</li>\n<li><code>[=]</code> ：捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获），拷贝的副本在匿名函数体内部是只读的，不可改变.</li>\n<li><code>[=, &amp;foo]</code> ：按值捕获外部作用域内的所以变量，按引用捕获变量 <code>foo</code></li>\n<li><code>[this]</code> ：捕获当前实例的 <code>this</code>  指针</li>\n</ol>\n</li>\n<li><code>(parameter list)</code> ：参数列表，和普通函数的参数列表一样，如果没有参数列表可以省略不写</li>\n<li><code>opt</code>  选项，不需要可以省略\n<ol>\n<li><code>mutable</code> ：可以修改按值拷贝进来的副本（注意修改的是副本）</li>\n<li><code>exception</code> ：指定函数抛出的异常</li>\n</ol>\n</li>\n<li><code>return type</code> ：一般情况下，不指定 <code>lambda</code>  表达式的返回值，编译器会根据 <code>return</code>  语句自动推导返回值类型，但是 <code>初始化列表不能用于返回值的自动推导</code></li>\n</ul>\n<h2 id=\"左值引用与右值引用\"><a class=\"anchor\" href=\"#左值引用与右值引用\">#</a> 左值引用与右值引用</h2>\n<ul>\n<li>左值引用：对左值的引用（可以出现在等式的左边，也可以出现在等式的右边，是具名的，同时可以取地址， <code>const左值引用</code> 可以引用右值）; 避免对象的拷贝，在一定程度上让程序脱离了危险的指针</li>\n<li>右值引用：右值（只能出现在等式的右边，不能取地址，纯右值 [字面值，返回的非引用的函数调用，后置自增 / 减，算术表达式，逻辑表达式，比较表达式], 将亡值 [C++11 引入，会触发移动构造或者移动赋值，并进行资源转移]）往往是没有名称，在实际开发中我们可能需要对右值进行修改，需要借助右值引用（ <code>类型&amp;&amp; 变量名=右值</code> ）\n<ol>\n<li>移动语义：将一个临时对象（将亡值）的资源转移到另外一个对象中去，可以减少不必要的资源的销毁和开辟，提高运行效率</li>\n<li><code>move()</code> ：将左值强制转化为右值引用，通过右值引用来使用，实现移动语义.</li>\n<li>完美转发</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"大小端存储\"><a class=\"anchor\" href=\"#大小端存储\">#</a> 大小端存储</h2>\n<ul>\n<li>大端存储：高位存储在低字节中</li>\n<li>小端存储：低位存储在低字节中</li>\n</ul>\n<blockquote>\n<p>在 <code>Socket网络编程</code> 中，有主机字节序和网络字节序</p>\n</blockquote>\n<h2 id=\"内存对齐\"><a class=\"anchor\" href=\"#内存对齐\">#</a> 内存对齐</h2>\n<p>理论上计算机对于任何变量的访问都可以从任务位置开始，然而实际上系统会对这些变量的存放做一些限制，通常将某个变量的地址设置为某个数 <code>N</code>  的整数倍。这就是内存对齐.</p>\n<blockquote>\n<p>内存是以字节为基本单位，但是对于处理器往往是按字节块来存取数据。进行内存对齐，主要是为了加快内存的存取速度.</p>\n</blockquote>\n<h2 id=\"内存池\"><a class=\"anchor\" href=\"#内存池\">#</a> 内存池</h2>\n<ul>\n<li>预先申请分配一定数量的内存块留作备用，当有新的内存需求时，就从内存池中分出一部分内存块，对于使用完的内存块将其放回内存池。若内存池不够，在继续申请新的内存. （防止频繁的内存申请与释放所带来的开销，提高分配效率，同时可以避免内存碎片）</li>\n</ul>\n<h2 id=\"stl六大组件\"><a class=\"anchor\" href=\"#stl六大组件\">#</a> STL 六大组件</h2>\n<ul>\n<li>容器、算法、迭代器、适配器、仿函数、空间分配器</li>\n</ul>\n<h2 id=\"为什么stack的pop和top要分离\"><a class=\"anchor\" href=\"#为什么stack的pop和top要分离\">#</a> 为什么 stack 的 pop () 和 top () 要分离</h2>\n<ul>\n<li>通过 <code>pop()</code>  来弹出并返回栈顶值这种方式不安全，可能导致原始数据丢失；pop () 在函数返回时，会发生对象的拷贝，如果弹出对象比较大，同时堆内内存比较紧张，可能无法分配住够的内存会抛出异常，无法正确的返回栈顶元素，但是此时栈顶元素已经弹出.</li>\n<li>通过引用或者指针可以解决这个问题</li>\n</ul>\n<h2 id=\"map-set-multimap-multiset关联容器\"><a class=\"anchor\" href=\"#map-set-multimap-multiset关联容器\">#</a> map、set、multimap、multiset（关联容器）</h2>\n<ul>\n<li>底层实现是 <code>红黑树</code></li>\n<li><code>set</code>  和 <code>multiset</code>  会对元素进行排序， <code>set</code>  不存储重复元素， <code>multiset</code>  可以存储重复元素</li>\n<li><code>map</code>  和 <code>multimap</code>  存储的元素为 k-v 键值对，会更加 key 进行排序， <code>map</code>  中不允许重复 key， <code>multimap</code>  可以重复 key</li>\n</ul>\n<h2 id=\"unordered_set与set\"><a class=\"anchor\" href=\"#unordered_set与set\">#</a> unordered_set 与 set</h2>\n<ul>\n<li><code>unordered_set</code>  内部无序，通过哈希来实现，对于非标准类型需要提供判等函数，插入，查询，删除的时间复杂度都是 <code>O(1)</code> ，但是不稳定，当数据量大冲突大时，时间复杂度最坏退化为 <code>O(n)</code> ； <code>set</code>  内部有序，通过红黑树来实现，对于非标准类型需要提供比较函数，插入，查询，删除的时间复杂度比较稳定 <code>log2(n)</code> .</li>\n</ul>\n<h2 id=\"哈希函数\"><a class=\"anchor\" href=\"#哈希函数\">#</a> 哈希函数</h2>\n<ul>\n<li>平方取中发：去关键字的平方值的中间几位作为哈希地址</li>\n</ul>\n<h2 id=\"哈希冲突\"><a class=\"anchor\" href=\"#哈希冲突\">#</a> 哈希冲突</h2>\n<ul>\n<li>开放地址法（再散列）：线性探测，再平方探测、伪随机探测</li>\n<li>拉链法</li>\n<li>再哈希</li>\n</ul>\n<h2 id=\"vector的扩容机制\"><a class=\"anchor\" href=\"#vector的扩容机制\">#</a> vector 的扩容机制</h2>\n<ul>\n<li><code>vector</code>  是一个动态数组，当插入元素使，若 <code>capacity</code>  和 <code>size</code>  相等，则会发生扩容； <code>vector</code>  扩容并不是在原有空间进行扩充，而是在堆内申请一块更大空间的区域，将原来的数据复制过去，同时释放原有空间。至于这个扩容系数，得看具体的实现，得看取舍（内存和效率的取舍）， <code>GCC</code>  下的扩容系数是 2</li>\n</ul>\n<h2 id=\"vectorclear-swap-shrink_to_fitresizereserve\"><a class=\"anchor\" href=\"#vectorclear-swap-shrink_to_fitresizereserve\">#</a> vector（clear(), swap(), shrink_to_fit(),resize(),reserve()）</h2>\n<ul>\n<li><code>clear()</code> ：清空内容，不释放内存（capacity 不变，size 变成 0）</li>\n<li><code>swap()</code> ：清空内容，释放内存 (capacity，size 均变成 0)</li>\n<li><code>shrink_to_fit()</code> ：可能会释放内存，使 capacity 与 size 适配（capacity 与 size 相等）</li>\n<li><code>resize(n)</code> ：会改变 <code>vector</code>  的 size</li>\n<li><code>reserve()</code> ：不会改变 size，但是可能会改变 capacity. 主要目的是为了优化性能，避免在添加元素时频繁进行内存分配</li>\n</ul>\n<h2 id=\"vector与list\"><a class=\"anchor\" href=\"#vector与list\">#</a> vector 与 list</h2>\n<ul>\n<li><code>vector</code>  的内存空间是连续的，可以在 <code>o(1)</code>  内实现随机存取，但是需要再内部进行插入和删除时，需要 <code>O(n)</code> .</li>\n<li><code>list</code>  是双向链表，内存空间不一定连续，往往是离散的， <code>O(n)</code>  完成随机存取，但是可以 <code>O(1)</code>  实现删除和插入操作</li>\n</ul>\n<h2 id=\"clear的时间复杂度\"><a class=\"anchor\" href=\"#clear的时间复杂度\">#</a> clear 的时间复杂度</h2>\n<ul>\n<li>无论是顺序容器还是关联容器在使用 <code>clear()</code>  时，时间复杂度都是 <code>O(n)</code> ；因为执行 <code>clear()</code>  需要调用元素的析构函数，这个析构函数会逐个进行。不过当存储的数据类型是基本数据类型的时候，不需要虚构，系统可能会做一些优化， <code>vector</code>  容器可以使得复杂度降为常数级.</li>\n</ul>\n<h2 id=\"c智能指针c11\"><a class=\"anchor\" href=\"#c智能指针c11\">#</a> C<ins> 智能指针（C</ins>11）</h2>\n<ul>\n<li>\n<p>智能指针是一个类，用来存储指向动态内存空间的对象指针，负责自动释放动态内存，防止堆内存泄漏.</p>\n</li>\n<li>\n<p><code>auto_ptr</code> ：C<ins>98 引入，由于其不够安全，被 <code>unique_ptr</code>  取代，C</ins>11 废弃；</p>\n</li>\n<li>\n<p><code>unique_ptr</code> ：与 <code>auto_ptr</code>  一样采用独占所有权模式，同一时间只能有一个指针可以指向某个对象，但是 <code>unique_ptr</code>  禁止了拷贝操作， <code>unique_ptr</code>  采用了移动赋值 <code>move()</code>  函数来进行控制权转移.</p>\n</li>\n<li>\n<p><code>shared_ptr</code> ：共享所有权的一个智能指针。允许多个指针指针指向同一个对象，并使用引用计数来管理指向对象的指针（成员函数 <code>use_count()</code>  可获得引用计数），该对象和相关资源会在最后一个引用被销毁时释放</p>\n<ul>\n<li>\n<p><code>shared_ptr</code> ：内部的引用计数是线程安全的，但是对象的读取需要加锁.</p>\n</li>\n<li>\n<p><code>shared_ptr</code>  循环计数问题：创建了两个 <code>shared_ptr</code>  分别指向两个对象，而这两个对象内的一个共享指针分别又指向了对方，造成了循环计数，使得两个对象的空间都无法被释放.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ListNode</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">int</span> _data<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tshared_ptr<span class=\"token operator\">&lt;</span>ListNode<span class=\"token operator\">></span> ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token function\">_data</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token operator\">~</span><span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"~ListNode()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tshared_ptr<span class=\"token operator\">&lt;</span>ListNode<span class=\"token operator\">></span> <span class=\"token function\">node1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tshared_ptr<span class=\"token operator\">&lt;</span>ListNode<span class=\"token operator\">></span> <span class=\"token function\">node2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> node1<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 1</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> node2<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tnode1<span class=\"token operator\">-></span>ptr <span class=\"token operator\">=</span> node2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tnode2<span class=\"token operator\">-></span>ptr <span class=\"token operator\">=</span> node1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> node1<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> node2<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 常用的解决方案是讲成员函数内的 shared_pre 改成弱指针 weak_ptr</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p><code>weak_ptr</code> ：一种不控制对象生命周期的智能指针，不会影响 <code>share_ptr</code>  的引用计数，只是提供一种访问其管理对象的方式</p>\n</li>\n</ul>\n<h2 id=\"内存泄漏\"><a class=\"anchor\" href=\"#内存泄漏\">#</a> 内存泄漏</h2>\n<ul>\n<li>堆内存泄漏（ <code>Heap leak</code> ）</li>\n<li>在释放对象数组时没有使用 <code>delete []</code>  而使用 <code>delete</code></li>\n<li>没有将基类的析构函数定义为虚函数</li>\n<li>缺少拷贝构造函数和拷贝赋值函数</li>\n</ul>\n<blockquote>\n<p>Linux 下内存泄漏检查工具：<strong>Valgrind</strong></p>\n</blockquote>\n<h2 id=\"深拷贝与浅拷贝\"><a class=\"anchor\" href=\"#深拷贝与浅拷贝\">#</a> 深拷贝与浅拷贝</h2>\n<ul>\n<li>浅拷贝：C++ 默认的方式（如果程序员不主动编写拷贝构造函数和赋值构造，编译器将以浅拷贝的方式生成缺省的函数），简单的将成员函数值进行复制. （当成员变量出现指针时，则会导致多个指针指向同一片内存空间，新旧对象共享内存，当其中一个对象释放内存，再调释放其他对象时就会出现问题，同一片内存空间被释放了多次）</li>\n<li>深拷贝：必须显示的提供拷贝构造函数和赋值构造，新旧对象不共享内存</li>\n</ul>\n<h2 id=\"c类默认生成的函数\"><a class=\"anchor\" href=\"#c类默认生成的函数\">#</a> C++ 类默认生成的函数</h2>\n<ul>\n<li>无参构造函数、析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、重载取地址符，均是 <code>public</code></li>\n</ul>\n<h2 id=\"对象复用与零拷贝\"><a class=\"anchor\" href=\"#对象复用与零拷贝\">#</a> 对象复用与零拷贝</h2>\n<h2 id=\"stl内存优化\"><a class=\"anchor\" href=\"#stl内存优化\">#</a> STL 内存优化</h2>\n<h2 id=\"const-2\"><a class=\"anchor\" href=\"#const-2\">#</a>  <code>const</code></h2>\n<ul>\n<li>\n<p>当以编译初始化的方式定义了一个 <code>const</code>  对象时，例如 <code>const int bufsize=512</code> ，编译器将在编译过程中把用到该变量的地方都替换成对应的值。</p>\n</li>\n<li>\n<p><code>const</code>  对象被设定为仅在文件内有效，当多个文件中出现了同名的 <code>const</code>  变量时，其实等同于在不同文件下分别定义了独立的变量；当某一个 <code>const</code>  对象需要再多个文件间共享时，我们需要对于 <code>const</code>  变量不管是声明还是定义都添加 <code>extern</code>  关键字。</p>\n</li>\n</ul>\n<h3 id=\"对常量的引用\"><a class=\"anchor\" href=\"#对常量的引用\">#</a> 对常量的引用</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">double</span> dval <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>r <span class=\"token operator\">=</span> dval<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>等价于</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> dval<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>r <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>系统在内部会将对常数的引用绑定在一个临时对象上，实际并未绑定 <code>dval</code> ；通过这种设计可以防止非法的操作。</p>\n<h2 id=\"顺序容器\"><a class=\"anchor\" href=\"#顺序容器\">#</a> 顺序容器</h2>\n<ul>\n<li><code>vector</code> ：可变长数组。支持快速随机访问。在尾部之外的其他位置插入或者删除元素可能比较慢</li>\n<li><code>deque</code> ：双端队列。支持快速随机访问。在头部或者尾部插入、删除元素速度很快</li>\n<li><code>list</code> ：双向列表。</li>\n<li><code>forward_list</code> ：单向列表。</li>\n<li><code>array</code> ：固定大小数组。支持快速随机访问。不能添加或者删除元素。</li>\n<li><code>string</code> ：与 <code>vector</code>  类似，但专门用于存储字符</li>\n</ul>\n<h2 id=\"指针空值类型\"><a class=\"anchor\" href=\"#指针空值类型\">#</a> 指针空值类型</h2>\n<p>C 与 C<ins> 内定义的 <code>NULL</code>  含义不同；C</ins> 内定义： <code>#define NULL 0</code> , 而 C 内的定义： <code>#define NULL ((void *)0)</code> .C 与 C<ins> 都是强类型语言，从 C 到 C</ins> 语言的类型定义变的更加严格，C++ 内不允许 <code>void( *)</code>  类型的变量隐式转化为其他类型。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 宏定义</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\"><span class=\"token constant\">NULL</span></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">__cplusplus</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span>  <span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure><p><code>nullptr</code>  无法隐式的转化为整形，但是可以隐式匹配指针类型</p>\n<h2 id=\"使用结构化绑定来解包绑定的返回值\"><a class=\"anchor\" href=\"#使用结构化绑定来解包绑定的返回值\">#</a> 使用结构化绑定来解包绑定的返回值</h2>\n<p>结构化绑定是 C++17 新特性，其可以结合语法糖自动推导类型，并可以从组对、元祖和结构体中提取单独的变量（解包）</p>\n<ol>\n<li>\n<p>使用结构化绑定是为了能过更加简单的为绑定的多个变量进行赋值</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//  对 pair 的结构化绑定</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">divide_remainder</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dividend<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> divisor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">divide_remainder</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">//  对 tuple 进行结构化绑定</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>tuple<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>chrono<span class=\"token double-colon punctuation\">::</span>system_clock<span class=\"token double-colon punctuation\">::</span>time_point<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> valid_time<span class=\"token punctuation\">,</span> price<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">stock_info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INTC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//  对自定义结构体进行结构化绑定</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">employee</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> id<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    string name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    string role<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> salary<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>employee<span class=\"token operator\">></span> employees<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">/* 注意：在适当时候使用引用，尽量减少不必要的复制 */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">,</span> salary<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> employees<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Name: \"</span> <span class=\"token operator\">&lt;&lt;</span> name</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>         <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Role: \"</span> <span class=\"token operator\">&lt;&lt;</span> role</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>         <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Salary: \"</span> <span class=\"token operator\">&lt;&lt;</span> salary <span class=\"token operator\">&lt;&lt;</span> <span class=\"token char\">'\\n'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p><code>STL</code>  中的基础数据结构都能通过结构化绑定来直接进行访问</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> size_t<span class=\"token operator\">></span> animal_population<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>species<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> animal_population<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"There are \"</span> <span class=\"token operator\">&lt;&lt;</span> count <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> species</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" on this planet.\\n\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>Node：与 C 的语法特征不同，将复杂结构体作为返回值传回会耗费大量的时间，因为对象需要在返回函数中进行初始化，之后将这个对象拷贝到相应容器中返回给调用端。现代编译器支持<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96\"><strong>返回值优化</strong></a> (RVO, <em>return value optimization</em>) 技术，这项技术可以省略中间副本的拷贝。</p>\n</blockquote>\n<h2 id=\"带初始化的if和switch\"><a class=\"anchor\" href=\"#带初始化的if和switch\">#</a> 带初始化的 if 和 switch</h2>\n<h2 id=\"括号初始化\"><a class=\"anchor\" href=\"#括号初始化\">#</a> 括号初始化</h2>\n<p><code>C++11</code>  引入了新的括号初始化语法 <code>&#123;&#125;</code> ，其不仅允许集合式的初始化，而且还是对常规构造函数的调用。遗憾的是，当与 <code>auto</code>  类型变量结合使用时，这种方式很容易出现错误， <code>c++17</code>  增强了这一系列初始化规则。</p>\n<h2 id=\"参考博文\"><a class=\"anchor\" href=\"#参考博文\">#</a> 参考博文</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NfYmFzZV9qaW4vYXJ0aWNsZS9kZXRhaWxzLzg2MDM2MTg1\">C++ 菱形继承问题和虚继承分析 - CSDN 博客</span></li>\n</ul>\n",
            "tags": [
                "C++",
                "面试题"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "计算机网络面试题",
            "date_published": "2024-03-07T09:23:50.257Z",
            "content_html": "<h2 id=\"tcpip四层模型osi七层模型\"><a class=\"anchor\" href=\"#tcpip四层模型osi七层模型\">#</a> TCP/IP 四层模型，OSI 七层模型</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png\" alt=\"\" /></p>\n<h2 id=\"tcp连接建立三次握手\"><a class=\"anchor\" href=\"#tcp连接建立三次握手\">#</a> TCP 连接建立（三次握手）</h2>\n<ol>\n<li>客户端（client）建立连接， <code>SYN=1</code> ，发送后状态变成 <code>SYN_SEND</code></li>\n<li>服务端（server）收到后，同意建立连接， <code>ACK=1, SYN=1</code> ，发送完成后状态变成 <code>SYN_RCVD</code></li>\n<li>客户端（client）收到后，状态变成 <code>ESTABLISHED</code> ，返回 <code>ACK=1</code>  给服务端；服务端（server）收到后，状态也变成 <code>ESTABLISHED</code> ，连接建立成功.</li>\n</ol>\n<blockquote>\n<p>TCP 连接建立为什么是 3 次，不是两次或者四次？</p>\n<ul>\n<li>TCP 是全双工传输模式，它们双方即是客户端也是服务端，需要建立双向的连接；如果只有两次，无法做到双向连接，而建立连接时，服务端发送确定的同时将 <code>SYN=1</code> ，确认和建立连接的请求合并了，所以也不需要 4 次.</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"\" /></p>\n<h2 id=\"半连接队列和syn-flood攻击\"><a class=\"anchor\" href=\"#半连接队列和syn-flood攻击\">#</a> 半连接队列和 SYN Flood 攻击</h2>\n<ul>\n<li>\n<p>半连接队列</p>\n<blockquote>\n<p>服务端在 <code>LISTEN</code>  状态时，会在内部维护两个队列：</p>\n<ol>\n<li>半连接队列（ <code>SYN队列</code> ）：三次握手未完成的连接（客户端发送 <code>SYN请求</code> ，服务端接收后，便回复 <code>SYN和ACK</code> ，状态由 <code>LISTEN</code>  态变成 <code>SYN_RCVD</code> ，此时这个连接就被推入半连接队列）</li>\n<li>全连接队列（ <code>ACCEPT队列</code> ）：完成三次握手的链接（客户端回复 <code>ACK</code> ，服务端接受后，三次握手完成，将连接从 <code>SYN队列</code> 中推入 <code>ACCEPT队列</code> ）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p><code>SYN Flood</code>  攻击</p>\n<blockquote>\n<p>一种典型的 DDos 攻击，在短时间呢伪造不存在的 IP，向服务端发送大量的 <code>SYN</code>  请求；当服务端发送 <code>SYN+ACK</code>  报文后，不会收到 <code>ACK</code>  回应报文，那么 <code>SYN队列</code> 内的连接就不会出队，久而久之会沾满服务器的 <code>SYN队列</code> ，使得正常用户无法正常访问.</p>\n<p>应对方案：</p>\n<ol>\n<li><code>SYN代理防火墙</code> ：对于每一个 <code>SYN请求</code> 进行代理和回应，并保持半连接；等客户端返回 <code>ACK确认</code> 后，再重新构造 <code>SYN</code>  包到服务器，简历真正的 TCP 连接</li>\n</ol>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/SYN_Flood.png\" alt=\"\" /></p>\n<h2 id=\"tcp连接释放四次挥手\"><a class=\"anchor\" href=\"#tcp连接释放四次挥手\">#</a> TCP 连接释放（四次挥手）</h2>\n<ul>\n<li>客户端（client）连接释放，向服务端发送释放连接请求， <code>FIN=1</code> ，此时客户端没有数据需要发送，状态变成 <code>FIN_WAIT_1</code></li>\n<li>服务端（server）收到后，返回一个确认报文 <code>ACK=1</code> ，服务端状态变成 <code>CLOSE_WAIT</code> （服务端可能还没有发送完数据）</li>\n<li>等到服务端（server）发送完所以数据后，向客户端发送连接释放请求， <code>FIN=1</code> ，服务端状态变成 <code>LAST_ACK</code></li>\n<li>客户端收到 <code>ACK=1</code>  确认之后，状态变成 <code>FIN_WAIT_2</code> ；客户端收到服务端释放连接请求后，向服务端发送 <code>ACK=1</code> ，此时客户端状态变成 <code>TIME_WAIT</code> , 等待 2MSL（报文最大生命周期）的时间，才会进入 <code>CLOSED</code>  状态</li>\n</ul>\n<blockquote>\n<p>为什么 TCP 连接释放不能 3 次？</p>\n<ul>\n<li>因为 <code>FIN=1</code>  和 <code>ACK=1</code>  不能同时发送，服务端在收到客户端 <code>FIN=1</code>  后，数据可能没有发送完成.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"\" /></p>\n<h2 id=\"close_wait与time_wait\"><a class=\"anchor\" href=\"#close_wait与time_wait\">#</a> CLOSE_WAIT 与 TIME_WAIT</h2>\n<ul>\n<li>\n<p><code>CLOSE_WAIT</code>  状态的意义</p>\n<blockquote>\n<p>服务端收到客户端的关闭请求并确认之后，会进入 <code>CLOSE_WAIT</code>  状态。此时服务端可能还有一些数据需要放松，因此不会立马关闭连接，而 <code>CLOSE_WAIT</code>  状态就是为了保证在服务端关闭之前将待发送的数据处理完</p>\n</blockquote>\n</li>\n<li>\n<p><code>TIME_WAIT</code>  状态的意义</p>\n<blockquote>\n<p>客户端在收到客户端的关闭请求并确认之后，会进入 <code>TIME_WAIT</code>  状态</p>\n<ol>\n<li>防止旧连接的数据报。如何客户端最后一次发送 <code>ACK确认</code> 报文之后立马关闭连接，但是此时服务端对应的端口并没有关闭，此时客户端在相同的端口建立新的连接，可能会导致新连接接收到旧连接产生的数据报，导致一些错误</li>\n<li>保证连接的正确关闭。如果客户端的最后一次 <code>ACK确认</code> 报文丢失，由于 TCP 超时重传机制，服务端会重发 <code>FIN报文</code> ；若没有 <code>TIME_WAIT</code>  状态的话，超时重传的 <code>FIN报文</code> 所对应的连接已经关闭，导致服务端没有得到正常的关闭</li>\n</ol>\n<p>为什么等待时间是 <code>2MSL(Maximuxm Segment Lifetime)</code></p>\n<ul>\n<li>保证客户端发送的最后一个 <code>ACK</code>  确认报文能够被服务器正确接收，时服务端可以安全的关闭连接。若最后一个 <code>ACK=1</code>  报文丢失，在 2MSL 内客户端必定察觉，可以重发</li>\n</ul>\n</blockquote>\n<h2 id=\"tcp如何保证传输的可靠性\"><a class=\"anchor\" href=\"#tcp如何保证传输的可靠性\">#</a> TCP 如何保证传输的可靠性</h2>\n<ul>\n<li>校验和：发送放在发送数据时会计算校验和，接收方在接受到数据后同样会检查校验和，如果不一致，那么传输发送了差错</li>\n<li>确认应答、序列号：TCP 对数据报进行了编号，同时接收方在接受了到了后会发送 <code>ack</code>  的确认</li>\n<li>超时重传：如果发送方一段时间没有收到某个报文的 <code>ACK</code>  确认，则会重新发送数据</li>\n<li>连接管理：三次握手和四次挥手保证连接的建立和释放的可靠性</li>\n<li>流量控制：TCP 协议报文包含 16 位的窗口大小，接收方在发送确认的同时会将自身窗口填入，发送方就根据报文中的窗口大小来控制发送速度</li>\n<li>拥塞控制：</li>\n</ul>\n<h2 id=\"tcp的流量控制\"><a class=\"anchor\" href=\"#tcp的流量控制\">#</a> TCP 的流量控制</h2>\n<ul>\n<li>TCP 中的流量控制是通过一个可变的滑动窗口来实现的. TCP 报文段中的窗口大小表示从被确认的字节算起还可以发送的字节数</li>\n<li>发送方的发送窗口内的字节都允许发送，当左部字节已发送并收到确认则窗口右移.</li>\n<li>接受方的接收串口内的字节都允许被接收。当左部字节已经发送确认并收到发送方确认，则窗口右移.</li>\n</ul>\n<blockquote>\n<p>TCP 流量控制是一个控制发送方发送速度，防止发送方发送速度过快导致接收方无法正确接受（缓存满），是一个局部的控制算法</p>\n</blockquote>\n<h2 id=\"tcp-拥塞控制\"><a class=\"anchor\" href=\"#tcp-拥塞控制\">#</a> TCP 拥塞控制</h2>\n<ul>\n<li>拥塞控制的方法：慢开始，拥塞避免，快重传，快恢复</li>\n<li>慢开始：不确定当前的网络状况，从 1 开始按指数逐渐增大拥塞窗口的大小，以此来探测当前网络的状况.</li>\n<li>拥塞避免：拥塞窗口达到阈值时所采用的策略，拥塞窗口的大小线性增大</li>\n<li>当出现了报文超时重传，当前拥塞窗口变成 1，重新执行慢开始，同时阈值减半</li>\n<li>快重传：当收到三个重复的 <code>ACK确认</code> 时执行快重传，拥塞窗口减半，此时阈值设置为当前窗口的大小，进入快恢复</li>\n<li>快恢复：</li>\n</ul>\n<blockquote>\n<p>TCP 拥塞控制同样也是用于控制发送方发送速度，但是出发点是为了缓解整个网络的拥塞，是一个全局的控制算法.</p>\n</blockquote>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E6%8B%A5%E5%A1%9E%E5%8F%91%E9%80%81.png\" alt=\"\" title=\"发生超时重传\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png\" alt=\"\" title=\"快速恢复\" /></p>\n<h2 id=\"tcp重传机制\"><a class=\"anchor\" href=\"#tcp重传机制\">#</a> TCP 重传机制</h2>\n<ul>\n<li>超时重传</li>\n<li>快速重传</li>\n<li>选择确认重传</li>\n</ul>\n<h2 id=\"arq协议\"><a class=\"anchor\" href=\"#arq协议\">#</a> ARQ 协议</h2>\n<blockquote>\n<p>ARQ：自动重传请求；如果发送方在发送后一段时间内没有收到确认，它通常会重新发送.<br />\nARQ 协议有两种：</p>\n<ul>\n<li>停止等待 ARQ</li>\n<li>连续 ARQ 协议</li>\n</ul>\n</blockquote>\n<ul>\n<li>停止等待 ARQ 协议：发送端维护一个超时计数器，发送端每次发送的报文在得到接收方的确认之后才可以发送下一个数据，超过一定时间没有收到发送方的确认，则需要重新发送。对于发送方收到了多个对同一报文的确认直接丢失。接收方对于接收到重复的报文也直接丢失.</li>\n<li>连续 ARQ 协议：发送端会维护一个窗口，窗口内的分组可以连续发送出去而不需要等待接收端的确认。对于按需到达的分组，接收端会发送最后一个正确到达的分组的确认. （提高信道利用率），会出现回退 N 的现象（当发送端发送了 5 条消息，第三条消息丢失了，接收方只能给接收方发送前两个的确认，而不清楚后三条消息的状态，算法会选择吧后面的三条消息全部重传）</li>\n</ul>\n<h2 id=\"tcp与udp的区别\"><a class=\"anchor\" href=\"#tcp与udp的区别\">#</a> TCP 与 UDP 的区别</h2>\n<ul>\n<li>TCP 是面向连接的，提供可靠的数据流传输；UDP 是无连接的，数据传输不可靠</li>\n<li>TCP 是面向字节流的，UDP 面向报文</li>\n<li>TCP 提供了流量控制和拥塞控制，而 UDP 没有</li>\n<li>TCP 一般只支持点到点的通信，UDP 支持一对一，一对多的通信</li>\n<li>TCP 首部长度 20~60 字节，UDP 首部长度只有 8 字节</li>\n</ul>\n<blockquote>\n<p>运行在 TCP 之上的协议： <code>HTTP</code> ， <code>HTTPS</code> ， <code>FTP</code> ， <code>SSH</code> <br />\n 运行在 UDP 之上的协议：DNS， <code>TFTP</code> <br />\nTCP 应用场景：实时性要求低，准确度要求高（文件传输，收发邮件，远程登录）<br />\nUDP 应用场景：实时性要求高，准确度要求低（在线语音 / 视频）</p>\n</blockquote>\n<h2 id=\"tcp中的粘包和拆包\"><a class=\"anchor\" href=\"#tcp中的粘包和拆包\">#</a> TCP 中的粘包和拆包</h2>\n<blockquote>\n<p>一个完整的数据报可能会被 TCP 拆分成多个包进行发送，也可能把多个小的包封装成一个大的数据包发送</p>\n</blockquote>\n<ul>\n<li>\n<p>为什么会产生拆包和粘包</p>\n<blockquote>\n<ol>\n<li>TCP 是基于字节流的</li>\n<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小时，将会发生拆包</li>\n<li>待发送的数据长度大于最大报文长度 <code>MSS</code> （TCP 报文长度 + TCP 首部长度 &gt; MSS），TCP 在传输过程中会发生拆包</li>\n<li>要发送的数据小于 TCP 发送缓冲区大小时，将会发生粘包</li>\n<li>接收端没有及时读取接收端缓存内的数据，将会发生粘包</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>如何解决</p>\n<blockquote>\n<ol>\n<li>在数据尾部增加特殊的字符进行分割</li>\n<li>发送端将每个数据包封装成固定大小</li>\n<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小</li>\n</ol>\n</blockquote>\n<h2 id=\"tcp校验和采用什么算法\"><a class=\"anchor\" href=\"#tcp校验和采用什么算法\">#</a> TCP 校验和采用什么算法</h2>\n<h2 id=\"既然tcp保证了可靠传输为什么应用层还需要做校验\"><a class=\"anchor\" href=\"#既然tcp保证了可靠传输为什么应用层还需要做校验\">#</a> 既然 TCP 保证了可靠传输，为什么应用层还需要做校验？</h2>\n<blockquote>\n<ol>\n<li><code>TCP</code>  的传输确认机制是可靠的，但是 <code>TCP</code>  的数据完整性的效验是不可靠的</li>\n<li><code>TCP</code>  能保证端到端的正确传输，但是交付到应用程序，应用程序是否能做出正确的处理（程序是否有 <code>bug</code> ） <code>TCP</code>  无法保证，需要应用层自己保证</li>\n<li>设备故障，写入缓存的数据丢失</li>\n</ol>\n</blockquote>\n<h2 id=\"浏览器请求一个网址的过程\"><a class=\"anchor\" href=\"#浏览器请求一个网址的过程\">#</a> 浏览器请求一个网址的过程</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png\" alt=\"\" /></p>\n<ul>\n<li>首先通过 <code>DNS</code>  将域名解析为 <code>IP地址</code></li>\n<li>与服务器通过三次握手，建立 TCP 连接</li>\n<li>服务器处理 http 请求，返回 http 响应</li>\n<li>浏览器解析并渲染页面</li>\n<li>TCP 四次挥手断开连接</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/HTTP.png\" alt=\"\" /></p>\n<blockquote>\n<p>这个过程所使用的协议：</p>\n<ul>\n<li>DNS</li>\n<li>TCP</li>\n<li>IP</li>\n<li>OPSF</li>\n<li>ARP</li>\n<li>HTTP</li>\n</ul>\n</blockquote>\n<h2 id=\"http协议中请求的方式\"><a class=\"anchor\" href=\"#http协议中请求的方式\">#</a> http 协议中请求的方式</h2>\n<ul>\n<li><code>GET</code> 、 <code>POST</code> 、 <code>HEAD</code> 、 <code>PUT</code> 、 <code>DELETE</code></li>\n</ul>\n<h2 id=\"常用的服务对应的端口\"><a class=\"anchor\" href=\"#常用的服务对应的端口\">#</a> 常用的服务对应的端口</h2>\n<ul>\n<li><code>FTP</code> ：21</li>\n<li><code>ssh</code> ：22</li>\n<li><code>HTTP</code> ：80</li>\n<li><code>HTTPS</code> ：443</li>\n<li><code>MySQL</code> ：3306</li>\n<li></li>\n</ul>\n<h2 id=\"get与post的区别\"><a class=\"anchor\" href=\"#get与post的区别\">#</a> GET 与 POST 的区别</h2>\n<ul>\n<li>安全性： <code>GET</code>  提交的数据会出现在 URL 内，相对不安全； <code>POST</code>  提交的数据会在报文体内，相对安全</li>\n<li>数据流： <code>GET</code>  传输的数据受限与 URL 的长度，而 <code>POST</code>  没有这种限制</li>\n<li>一般而言 <code>GET</code>  从服务器上获取资源，而 <code>POST</code>  更新服务器上的资源</li>\n</ul>\n<h2 id=\"http响应码\"><a class=\"anchor\" href=\"#http响应码\">#</a> http 响应码</h2>\n<ul>\n<li><code>1××</code> ：提示信息，表示协议处于中间状态</li>\n<li><code>2××</code> ：成功，报文被正确的接收和处理</li>\n<li><code>3××</code> ：重定向，资源位置发生变动，需要客户端重新发送请求（ <code>301</code>  永久性移动， <code>302</code>  临时性移动）</li>\n<li><code>4××</code> ：客户端错误，请求的报文有误，服务器无法处理</li>\n<li><code>5××</code> ：服务端错误</li>\n</ul>\n<h2 id=\"http有哪些常见的字段\"><a class=\"anchor\" href=\"#http有哪些常见的字段\">#</a> http 有哪些常见的字段</h2>\n<ul>\n<li><code>HOST</code> ：服务器域名</li>\n<li><code>Content-Length</code> ：服务器返回响应时，该字段表示回应的数据长度</li>\n<li></li>\n</ul>\n<h2 id=\"如何理解http协议的无连接无状态\"><a class=\"anchor\" href=\"#如何理解http协议的无连接无状态\">#</a> 如何理解 http 协议的 &quot;无连接，无状态&quot;</h2>\n<ul>\n<li>\n<p>无状态：在 http 协议中服务端不会保留客户端的任何信息</p>\n<blockquote>\n<p>浏览器第一次发送请求给服务器时，服务器响应了；如果之后再次发送第二次请求给服务器，它还是会响应，但是服务器并不知道两次请求来着同一个客户端</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"http的长连接与短连接的区别\"><a class=\"anchor\" href=\"#http的长连接与短连接的区别\">#</a> http 的长连接与短连接的区别</h2>\n<ul>\n<li>在早期的 <code>http/1.0</code>  默认使用的是短连接，每次客户端与服务端进行一次 http 操作，就建立一次连接，任务结束就中断连接</li>\n<li>从 <code>http/1.1</code>  起，默认使用的长连接。响应报文中 <code>Connection:keep-alive</code> ， <code>keep-alive</code>  具有一个保持时间.</li>\n</ul>\n<h2 id=\"http10-11-20的区别\"><a class=\"anchor\" href=\"#http10-11-20的区别\">#</a> HTTP/1.0、1.1、2.0 的区别</h2>\n<ul>\n<li><code>HTTP/1.0</code> ：默认短连接，可以设置 <code>Connection:keep-alive</code>  强制长连接</li>\n<li><code>HTTP/1.1</code> ：默认长连接</li>\n<li><code>HTTP/2.0</code> ：采用了多路复用</li>\n</ul>\n<h2 id=\"https协议的流程\"><a class=\"anchor\" href=\"#https协议的流程\">#</a> HTTPS 协议的流程</h2>\n<h2 id=\"http与https的区别\"><a class=\"anchor\" href=\"#http与https的区别\">#</a> http 与 https 的区别</h2>\n<ul>\n<li>\n<p>http 的缺点</p>\n<blockquote>\n<ol>\n<li>明文传输，内容可能被窃听</li>\n<li>通信双方没有身份认证</li>\n<li>无法验证报文的完整性</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>https 的改进</p>\n<blockquote>\n<ol>\n<li>加密：客户端通过 <code>SSL/TLS</code>  将报文内容进行加密，服务端界面（运输层与网络层之间加上 SSL/TLS 网络协议）</li>\n<li>身份认证：通过值得信赖的第三方机构颁布的证书来确认双方的身份.</li>\n<li>完整新保护。通过 MD5 等散列码进行通信内存的校验</li>\n</ol>\n<p>https 主要工作流程</p>\n<ol>\n<li>客户端发起 https 请求，连接到服务端的 443 端口</li>\n<li>服务端将自己的数字证书发送给客户端（）</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"session与cookie\"><a class=\"anchor\" href=\"#session与cookie\">#</a> Session 与 Cookie</h2>\n<ul>\n<li>\n<p><code>cookie</code> ：</p>\n</li>\n<li>\n<p><code>session</code> ：</p>\n<blockquote>\n<p>区别：</p>\n<ol>\n<li><code>Cookie</code>  存储在客户端， <code>Session</code>  存储在服务端</li>\n<li>有效期不同.  <code>Cookie</code>  一般可以设置为长时间保持， <code>Session</code>  一般有效期较短</li>\n</ol>\n<p>关联：</p>\n<ol>\n<li>用户第一次请求服务器时，服务器根据用户提交的信息，创建响应的 <code>Session</code> ，并返回此 <code>Session</code>  的唯一标识 <code>Session ID</code>  给客户端；客户端在接收到服务器返回的 <code>Session ID</code>  后将其保存在 <code>Cookie</code>  中，同时绑定当前的域名.</li>\n<li>当用户第二次请求服务器时，请求会自动判断此域名狭隘是否存在 <code>Cookie</code>  信息，如果存在则自动将 <code>Cookie</code>  信息发送给服务端；服务端会从 <code>Cookie</code>  中获取 <code>Session ID</code>  并查找对应的 <code>Session</code>  信息，如果没有找到，说明用户没有登陆或者登陆失效，如果找到了，说明用户已经登陆可直接执行响应操作.</li>\n</ol>\n<p>分布式环境下 <code>Session</code>  怎么处理？</p>\n<ul>\n<li>可以使用 <code>Redis</code>  等分布式缓存来存储 <code>Session</code>  信息，在多态服务器之间共享</li>\n</ul>\n</blockquote>\n<h2 id=\"dns域名系统\"><a class=\"anchor\" href=\"#dns域名系统\">#</a> DNS 域名系统</h2>\n<blockquote>\n<p>对于人而言记忆一串有意义的字符串要比记忆一组无规律的数字要容易的多；DNS，即为域名系统，是一个由域名到 IP 地址的分布式数据库，可以方便的完成域名到 IP 的转换.</p>\n</blockquote>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/dns.png\" alt=\"\" /></p>\n<ul>\n<li>工作原理\n<ol>\n<li>当用户输入域名时，浏览器先检查自己的缓存是否包含这个域名的映射。如有则解析结束</li>\n<li>检查操作系统缓存中是否（Windows 的 hosts）有该域名的映射</li>\n<li>向本地域名服务器发送解析请求，查找是否有对应的域名映射</li>\n<li>本地域名服务器依次向根域名服务器、顶级域名服务器、权限域名服务器发送请求，直到找到域名的映射</li>\n</ol>\n</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F.png\" alt=\"\" /></p>\n<h2 id=\"arp协议\"><a class=\"anchor\" href=\"#arp协议\">#</a> ARP 协议</h2>\n<blockquote>\n<p>网络层的 IP 报文向下需要封装成帧，需要添加以太网头部，这就需要知道节点的 MAC 地址；ARP 的作用就是完成 IP 地址到 MAC 地址的转化协议</p>\n</blockquote>\n<ul>\n<li>首先每个主机都会维护一张 ARP 列表，用于存储 IP 地址到 MAC 地址的映射</li>\n<li>源主机发送数据时，首先检查 ARP 列表内是否有目的地址的 MAC 地址，如果有，则写入以太网头部，并发送帧。如果没有，主机以广播的形式发送 ARP 数据报，数据报内源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址</li>\n<li>当网络中的主机收到 ARP 数据包时，首先检查报文中的 IP 地址是否是自己，如果不是则丢弃该报文；否则将自己的 MAC 地址写入 ARP 响应报文中，同时将源主机的 IP 地址和 MAC 地址键值对写入自己的 ARP 列表中.</li>\n<li>源主机收到 ARP 响应报文后，将目的主机的 IP 地址和 MAC 地址写入自身的 APR 列表中，并写入以太网头部，发送该帧.</li>\n</ul>\n<h2 id=\"ipv4地址不够如何解决\"><a class=\"anchor\" href=\"#ipv4地址不够如何解决\">#</a> IPV4 地址不够如何解决</h2>\n<ul>\n<li><code>DHCP</code> ：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址.</li>\n<li><code>NAT</code> ：网络地址转换协议.</li>\n<li><code>IPV6</code> ：</li>\n</ul>\n<h2 id=\"为什么既有mac地址又有ip地址\"><a class=\"anchor\" href=\"#为什么既有mac地址又有ip地址\">#</a> 为什么既有 MAC 地址，又有 IP 地址</h2>\n<h2 id=\"icmp协议\"><a class=\"anchor\" href=\"#icmp协议\">#</a> ICMP 协议</h2>\n<blockquote>\n<p>面向无连接，用于传输错误报告控制信息</p>\n</blockquote>\n<ul>\n<li><code>ICMP差错报告报文</code> ：终点不可达、时间超时、改变路由、参数问题</li>\n<li><code>ICMP询问报文</code></li>\n</ul>\n<h2 id=\"对称秘钥加密和非对称秘钥加密\"><a class=\"anchor\" href=\"#对称秘钥加密和非对称秘钥加密\">#</a> 对称秘钥加密和非对称秘钥加密</h2>\n<ul>\n<li>\n<p><code>对称秘钥加密</code></p>\n<blockquote>\n<p>加密和解密使用同一种秘钥，运算速度快，但是无法安全的将秘钥传递给通信方</p>\n</blockquote>\n</li>\n<li>\n<p>非对称加密</p>\n<blockquote>\n<p>加密和解密使用不同的秘钥，运算速度慢</p>\n<p>通信方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信的内容后使用私有密钥解密</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"liunx下网络配置\"><a class=\"anchor\" href=\"#liunx下网络配置\">#</a> Liunx 下网络配置</h2>\n<ul>\n<li><code>ifconfig</code>  或 <code>ip</code></li>\n</ul>\n<h2 id=\"参考博文\"><a class=\"anchor\" href=\"#参考博文\">#</a> 参考博文</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveUFsRXJsQzA5R25qYVZ2d1VvM0FjZw==\">面渣逆袭：计算机网络六十二问，三万字图文详解！速收藏！ (qq.com)</span></li>\n<li>[2] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbnRlcnZpZXdndWlkZS5jbi9ub3Rlcy8wMy1odW50aW5nX2pvYi8wMi1pbnRlcnZpZXcvMDMtMDEtbmV0Lmh0bWw=\">计算机网络 - 01-20 | 阿秀的学习笔记 (interviewguide.cn)</span></li>\n<li>[3] <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVME9URTRNell6TXc9PSZhbXA7bWlkPTIyNDc1MTc5NjkmYW1wO2lkeD0zJmFtcDtzbj1hMGZjODgxMTE0OTJmNTUyOWZlZjE0MDA4YTFiYjQ1MSZhbXA7Y2hrc209ZmJiMTBlZWZjY2M2ODdmOThlZGE2YzhkN2Q3M2UyNTFkOWRjNTk3YmJlY2U0ZTU0ZDUxYjc2MDczOTdiNTI2YzU5NTQ1MjgxNWU3MSZhbXA7c2NlbmU9Mjc=\">2W 字！梳理 50 道经典计算机网络面试题（收藏版） (qq.com)</span></li>\n</ul>\n",
            "tags": [
                "面试题",
                "计算机网络"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"计算机网络\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "计算机网络面试题",
            "date_published": "2024-03-07T09:23:50.257Z",
            "content_html": "<h2 id=\"tcpip四层模型osi七层模型\"><a class=\"anchor\" href=\"#tcpip四层模型osi七层模型\">#</a> TCP/IP 四层模型，OSI 七层模型</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png\" alt=\"\" /></p>\n<h2 id=\"tcp连接建立三次握手\"><a class=\"anchor\" href=\"#tcp连接建立三次握手\">#</a> TCP 连接建立（三次握手）</h2>\n<ol>\n<li>客户端（client）建立连接， <code>SYN=1</code> ，发送后状态变成 <code>SYN_SEND</code></li>\n<li>服务端（server）收到后，同意建立连接， <code>ACK=1, SYN=1</code> ，发送完成后状态变成 <code>SYN_RCVD</code></li>\n<li>客户端（client）收到后，状态变成 <code>ESTABLISHED</code> ，返回 <code>ACK=1</code>  给服务端；服务端（server）收到后，状态也变成 <code>ESTABLISHED</code> ，连接建立成功.</li>\n</ol>\n<blockquote>\n<p>TCP 连接建立为什么是 3 次，不是两次或者四次？</p>\n<ul>\n<li>TCP 是全双工传输模式，它们双方即是客户端也是服务端，需要建立双向的连接；如果只有两次，无法做到双向连接，而建立连接时，服务端发送确定的同时将 <code>SYN=1</code> ，确认和建立连接的请求合并了，所以也不需要 4 次.</li>\n</ul>\n</blockquote>\n<h2 id=\"tcp连接释放四次挥手\"><a class=\"anchor\" href=\"#tcp连接释放四次挥手\">#</a> TCP 连接释放（四次挥手）</h2>\n<ul>\n<li>客户端（client）连接释放，向服务端发送释放连接请求， <code>FIN=1</code> ，此时客户端没有数据需要发送，状态变成 <code>FIN_WAIT_1</code></li>\n<li>服务端（server）收到后，返回一个确认报文 <code>ACK=1</code> ，服务端状态变成 <code>CLOSE_WAIT</code> （服务端可能还没有发送完数据）</li>\n<li>等到服务端（server）发送完所以数据后，向客户端发送连接释放请求， <code>FIN=1</code> ，服务端状态变成 <code>LAST_ACK</code></li>\n<li>客户端收到 <code>ACK=1</code>  确认之后，状态变成 <code>FIN_WAIT_2</code> ；客户端收到服务端释放连接请求后，向服务端发送 <code>ACK=1</code> ，此时客户端状态变成 <code>TIME_WAIT</code> , 等待 2MSL（报文最大生命周期）的时间，才会进入 <code>CLOSED</code>  状态</li>\n</ul>\n<blockquote>\n<p>为什么 TCP 连接释放不能 3 次？</p>\n<ul>\n<li>因为 <code>FIN=1</code>  和 <code>ACK=1</code>  不能同时发送，服务端在收到客户端 <code>FIN=1</code>  后，数据可能没有发送完成.</li>\n</ul>\n<p>为什么要等待 2MSL？</p>\n<ul>\n<li>保证服务端连接的可靠关闭。如若最后一个 <code>ACK=1</code>  报文丢失，在 2MSL 内客户端必定察觉，可以重发</li>\n</ul>\n</blockquote>\n<h2 id=\"tcp如何保证传输的可靠性\"><a class=\"anchor\" href=\"#tcp如何保证传输的可靠性\">#</a> TCP 如何保证传输的可靠性</h2>\n<ul>\n<li>校验和：发送放在发送数据时会计算校验和，接收方在接受到数据后同样会检查校验和，如果不一致，那么传输发送了差错</li>\n<li>确认应答、序列号：TCP 对数据报进行了编号，同时接收方在接受了到了后会发送 <code>ack</code>  的确认</li>\n<li>超时重传：如果发送方一段时间没有收到某个报文的 <code>ACK</code>  确认，则会重新发送数据</li>\n<li>连接管理：三次握手和四次挥手保证连接的建立和释放的可靠性</li>\n<li>流量控制：TCP 协议报文包含 16 位的窗口大小，接收方在发送确认的同时会将自身窗口填入，发送方就根据报文中的窗口大小来控制发送速度</li>\n<li>拥塞控制：</li>\n</ul>\n<h2 id=\"tcp的流量控制\"><a class=\"anchor\" href=\"#tcp的流量控制\">#</a> TCP 的流量控制</h2>\n<ul>\n<li>TCP 中的流量控制是通过一个可变的滑动窗口来实现的. TCP 报文段中的窗口大小表示从被确认的字节算起还可以发送的字节数</li>\n<li>发送方的发送窗口内的字节都允许发送，当左部字节已发送并收到确认则窗口右移.</li>\n<li>接受方的接收串口内的字节都允许被接收。当左部字节已经发送确认并收到发送方确认，则窗口右移.</li>\n</ul>\n<blockquote>\n<p>TCP 流量控制是一个控制发送方发送速度，防止发送方发送速度过快导致接收方无法正确接受（缓存满），是一个局部的控制算法</p>\n</blockquote>\n<h2 id=\"tcp-拥塞控制\"><a class=\"anchor\" href=\"#tcp-拥塞控制\">#</a> TCP 拥塞控制</h2>\n<ul>\n<li>拥塞控制的方法：慢开始，拥塞避免，快重传，快恢复</li>\n<li>慢开始：不确定当前的网络状况，从 1 开始按指数逐渐增大拥塞窗口的大小，以此来探测当前网络的状况.</li>\n<li>拥塞避免：拥塞窗口达到阈值时所采用的策略，拥塞窗口的大小线性增大</li>\n<li>当出现了报文超时，当前拥塞窗口变成 1，重新执行慢开始，同时阈值减半</li>\n<li></li>\n</ul>\n<blockquote>\n<p>TCP 拥塞控制同样也是用于控制发送方发送速度，但是出发点是为了缓解整个网络的拥塞，是一个全局的控制算法.</p>\n</blockquote>\n<h2 id=\"tcp与udp的区别\"><a class=\"anchor\" href=\"#tcp与udp的区别\">#</a> TCP 与 UDP 的区别</h2>\n<ul>\n<li>TCP 是面向连接的，提供可靠的数据流传输；UDP 是非面向连接的，数据传输不可靠</li>\n<li>TCP 是面向字节流的，UDP 面向报文</li>\n<li>TCP 提供了流量控制和拥塞控制，而 UDP 没有</li>\n<li>TCP 一般只支持点到点的通信，UDP 支持一对一，一对多的通信</li>\n</ul>\n<blockquote>\n<p>运行在 TCP 之上的协议： <code>HTTP</code> ， <code>HTTPS</code> ， <code>FTP</code> ， <code>SSH</code> <br />\n 运行在 UDP 之上的协议：DNS</p>\n</blockquote>\n<h2 id=\"浏览器请求一个网址的过程\"><a class=\"anchor\" href=\"#浏览器请求一个网址的过程\">#</a> 浏览器请求一个网址的过程</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png\" alt=\"\" /></p>\n<ul>\n<li>首先通过 <code>DNS</code>  将域名解析为 <code>IP地址</code></li>\n<li>应用层构造 <code>http</code>  报文，传输层添加 <code>TCP头部</code> ，网络层添加 <code>IP</code>  头部，数据链路层添加 <code>以太网头部</code></li>\n<li>数据流进过路由器，交换机最终到达目标服务器，目标服务器同样进过层层解包来获取 <code>http</code>  报文，然后发送确认报文.</li>\n</ul>\n<h2 id=\"http协议中请求的方式\"><a class=\"anchor\" href=\"#http协议中请求的方式\">#</a> http 协议中请求的方式</h2>\n<ul>\n<li><code>GET</code> 、 <code>POST</code> 、 <code>HEAD</code> 、 <code>PUT</code> 、 <code>DELETE</code></li>\n</ul>\n<h2 id=\"get与post的区别\"><a class=\"anchor\" href=\"#get与post的区别\">#</a> GET 与 POST 的区别</h2>\n<ul>\n<li>安全性： <code>GET</code>  提交的数据会出现在 URL 内，相对不安全； <code>POST</code>  提交的数据会在报文体内，相对安全</li>\n<li>数据流： <code>GET</code>  传输的数据受限与 URL 的长度，而 <code>POST</code>  没有这种限制</li>\n<li>一般而言 <code>GET</code>  从服务器上获取资源，而 <code>POST</code>  更新服务器上的资源</li>\n</ul>\n<h2 id=\"http响应码\"><a class=\"anchor\" href=\"#http响应码\">#</a> http 响应码</h2>\n<ul>\n<li><code>200</code> ：</li>\n<li><code>404</code> ：</li>\n<li><code>500</code> ：</li>\n</ul>\n<h2 id=\"http与https的区别\"><a class=\"anchor\" href=\"#http与https的区别\">#</a> http 与 https 的区别</h2>\n<ul>\n<li></li>\n</ul>\n<h2 id=\"session与cookie\"><a class=\"anchor\" href=\"#session与cookie\">#</a> session 与 cookie</h2>\n<h2 id=\"arp协议\"><a class=\"anchor\" href=\"#arp协议\">#</a> ARP 协议</h2>\n<blockquote>\n<p>网络层的 IP 报文向下需要封装成帧，需要添加以太网头部，这就需要知道节点的 MAC 地址；ARP 的作用就是完成 IP 地址到 MAC 地址的转化协议</p>\n</blockquote>\n<ul>\n<li>首先每个主机都会维护一张 ARP 列表，用于存储 IP 地址到 MAC 地址的映射</li>\n<li>源主机发送数据时，首先检查 ARP 列表内是否有目的地址的 MAC 地址，如果有，则写入以太网头部，并发送帧。如果没有，主机以广播的形式发送 ARP 数据报，数据报内源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址</li>\n<li>当网络中的主机收到 ARP 数据包时，首先检查报文中的 IP 地址是否是自己，如果不是则丢弃该报文；否则将自己的 MAC 地址写入 ARP 响应报文中，同时将源主机的 IP 地址和 MAC 地址键值对写入自己的 ARP 列表中.</li>\n<li>源主机收到 ARP 响应报文后，将目的主机的 IP 地址和 MAC 地址写入自身的 APR 列表中，并写入以太网头部，发送该帧.</li>\n</ul>\n",
            "tags": [
                "面试题"
            ]
        }
    ]
}
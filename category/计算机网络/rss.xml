<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>繁華落盡 似水流年 • Posts by &#34;计算机网络&#34; category</title>
        <link>http://example.com</link>
        <description>编程日记 &amp; 随笔</description>
        <language>en</language>
        <pubDate>Thu, 07 Mar 2024 17:23:50 +0800</pubDate>
        <lastBuildDate>Thu, 07 Mar 2024 17:23:50 +0800</lastBuildDate>
        <category>mathematics</category>
        <category>语法</category>
        <category>C++</category>
        <category>VMware</category>
        <category>项目构建工具</category>
        <category>install</category>
        <category>数据库</category>
        <category>STL</category>
        <category>CNN</category>
        <category>Project</category>
        <category>面试题</category>
        <category>日常</category>
        <category>校招</category>
        <item>
            <guid isPermalink="true">http://example.com/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98</guid>
            <title>计算机网络面试题</title>
            <link>http://example.com/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98</link>
            <category>面试题</category>
            <pubDate>Thu, 07 Mar 2024 17:23:50 +0800</pubDate>
            <description><![CDATA[ &lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;tcpip四层模型osi七层模型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcpip四层模型osi七层模型&#34;&gt;#&lt;/a&gt; TCP/IP 四层模型，OSI 七层模型&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcp连接建立三次握手&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp连接建立三次握手&#34;&gt;#&lt;/a&gt; TCP 连接建立（三次握手）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端（client）建立连接， &lt;code&gt;SYN=1&lt;/code&gt; ，发送后状态变成 &lt;code&gt;SYN_SEND&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端（server）收到后，同意建立连接， &lt;code&gt;ACK=1, SYN=1&lt;/code&gt; ，发送完成后状态变成 &lt;code&gt;SYN_RCVD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端（client）收到后，状态变成 &lt;code&gt;ESTABLISHED&lt;/code&gt; ，返回 &lt;code&gt;ACK=1&lt;/code&gt;  给服务端；服务端（server）收到后，状态也变成 &lt;code&gt;ESTABLISHED&lt;/code&gt; ，连接建立成功.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 连接建立为什么是 3 次，不是两次或者四次？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是全双工传输模式，它们双方即是客户端也是服务端，需要建立双向的连接；如果只有两次，无法做到双向连接，而建立连接时，服务端发送确定的同时将 &lt;code&gt;SYN=1&lt;/code&gt; ，确认和建立连接的请求合并了，所以也不需要 4 次.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp连接释放四次挥手&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp连接释放四次挥手&#34;&gt;#&lt;/a&gt; TCP 连接释放（四次挥手）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端（client）连接释放，向服务端发送释放连接请求， &lt;code&gt;FIN=1&lt;/code&gt; ，此时客户端没有数据需要发送，状态变成 &lt;code&gt;FIN_WAIT_1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端（server）收到后，返回一个确认报文 &lt;code&gt;ACK=1&lt;/code&gt; ，服务端状态变成 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; （服务端可能还没有发送完数据）&lt;/li&gt;
&lt;li&gt;等到服务端（server）发送完所以数据后，向客户端发送连接释放请求， &lt;code&gt;FIN=1&lt;/code&gt; ，服务端状态变成 &lt;code&gt;LAST_ACK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端收到 &lt;code&gt;ACK=1&lt;/code&gt;  确认之后，状态变成 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; ；客户端收到服务端释放连接请求后，向服务端发送 &lt;code&gt;ACK=1&lt;/code&gt; ，此时客户端状态变成 &lt;code&gt;TIME_WAIT&lt;/code&gt; , 等待 2MSL（报文最大生命周期）的时间，才会进入 &lt;code&gt;CLOSED&lt;/code&gt;  状态&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么 TCP 连接释放不能 3 次？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 &lt;code&gt;FIN=1&lt;/code&gt;  和 &lt;code&gt;ACK=1&lt;/code&gt;  不能同时发送，服务端在收到客户端 &lt;code&gt;FIN=1&lt;/code&gt;  后，数据可能没有发送完成.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要等待 2MSL？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证服务端连接的可靠关闭。如若最后一个 &lt;code&gt;ACK=1&lt;/code&gt;  报文丢失，在 2MSL 内客户端必定察觉，可以重发&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp如何保证传输的可靠性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp如何保证传输的可靠性&#34;&gt;#&lt;/a&gt; TCP 如何保证传输的可靠性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;校验和：发送放在发送数据时会计算校验和，接收方在接受到数据后同样会检查校验和，如果不一致，那么传输发送了差错&lt;/li&gt;
&lt;li&gt;确认应答、序列号：TCP 对数据报进行了编号，同时接收方在接受了到了后会发送 &lt;code&gt;ack&lt;/code&gt;  的确认&lt;/li&gt;
&lt;li&gt;超时重传：如果发送方一段时间没有收到某个报文的 &lt;code&gt;ACK&lt;/code&gt;  确认，则会重新发送数据&lt;/li&gt;
&lt;li&gt;连接管理：三次握手和四次挥手保证连接的建立和释放的可靠性&lt;/li&gt;
&lt;li&gt;流量控制：TCP 协议报文包含 16 位的窗口大小，接收方在发送确认的同时会将自身窗口填入，发送方就根据报文中的窗口大小来控制发送速度&lt;/li&gt;
&lt;li&gt;拥塞控制：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp的流量控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp的流量控制&#34;&gt;#&lt;/a&gt; TCP 的流量控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP 中的流量控制是通过一个可变的滑动窗口来实现的. TCP 报文段中的窗口大小表示从被确认的字节算起还可以发送的字节数&lt;/li&gt;
&lt;li&gt;发送方的发送窗口内的字节都允许发送，当左部字节已发送并收到确认则窗口右移.&lt;/li&gt;
&lt;li&gt;接受方的接收串口内的字节都允许被接收。当左部字节已经发送确认并收到发送方确认，则窗口右移.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 流量控制是一个控制发送方发送速度，防止发送方发送速度过快导致接收方无法正确接受（缓存满），是一个局部的控制算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp-拥塞控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-拥塞控制&#34;&gt;#&lt;/a&gt; TCP 拥塞控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拥塞控制的方法：慢开始，拥塞避免，快重传，快恢复&lt;/li&gt;
&lt;li&gt;慢开始：不确定当前的网络状况，从 1 开始按指数逐渐增大拥塞窗口的大小，以此来探测当前网络的状况.&lt;/li&gt;
&lt;li&gt;拥塞避免：拥塞窗口达到阈值时所采用的策略，拥塞窗口的大小线性增大&lt;/li&gt;
&lt;li&gt;当出现了报文超时，当前拥塞窗口变成 1，重新执行慢开始，同时阈值减半&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 拥塞控制同样也是用于控制发送方发送速度，但是出发点是为了缓解整个网络的拥塞，是一个全局的控制算法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp与udp的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp与udp的区别&#34;&gt;#&lt;/a&gt; TCP 与 UDP 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是面向连接的，提供可靠的数据流传输；UDP 是非面向连接的，数据传输不可靠&lt;/li&gt;
&lt;li&gt;TCP 是面向字节流的，UDP 面向报文&lt;/li&gt;
&lt;li&gt;TCP 提供了流量控制和拥塞控制，而 UDP 没有&lt;/li&gt;
&lt;li&gt;TCP 一般只支持点到点的通信，UDP 支持一对一，一对多的通信&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;运行在 TCP 之上的协议： &lt;code&gt;HTTP&lt;/code&gt; ， &lt;code&gt;HTTPS&lt;/code&gt; ， &lt;code&gt;FTP&lt;/code&gt; ， &lt;code&gt;SSH&lt;/code&gt; &lt;br /&gt;
 运行在 UDP 之上的协议：DNS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;浏览器请求一个网址的过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#浏览器请求一个网址的过程&#34;&gt;#&lt;/a&gt; 浏览器请求一个网址的过程&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先通过 &lt;code&gt;DNS&lt;/code&gt;  将域名解析为 &lt;code&gt;IP地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用层构造 &lt;code&gt;http&lt;/code&gt;  报文，传输层添加 &lt;code&gt;TCP头部&lt;/code&gt; ，网络层添加 &lt;code&gt;IP&lt;/code&gt;  头部，数据链路层添加 &lt;code&gt;以太网头部&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据流进过路由器，交换机最终到达目标服务器，目标服务器同样进过层层解包来获取 &lt;code&gt;http&lt;/code&gt;  报文，然后发送确认报文.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http协议中请求的方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http协议中请求的方式&#34;&gt;#&lt;/a&gt; http 协议中请求的方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;POST&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;PUT&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get与post的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#get与post的区别&#34;&gt;#&lt;/a&gt; GET 与 POST 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安全性： &lt;code&gt;GET&lt;/code&gt;  提交的数据会出现在 URL 内，相对不安全； &lt;code&gt;POST&lt;/code&gt;  提交的数据会在报文体内，相对安全&lt;/li&gt;
&lt;li&gt;数据流： &lt;code&gt;GET&lt;/code&gt;  传输的数据受限与 URL 的长度，而 &lt;code&gt;POST&lt;/code&gt;  没有这种限制&lt;/li&gt;
&lt;li&gt;一般而言 &lt;code&gt;GET&lt;/code&gt;  从服务器上获取资源，而 &lt;code&gt;POST&lt;/code&gt;  更新服务器上的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http响应码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http响应码&#34;&gt;#&lt;/a&gt; http 响应码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200&lt;/code&gt; ：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404&lt;/code&gt; ：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500&lt;/code&gt; ：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http的长连接与短连接的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http的长连接与短连接的区别&#34;&gt;#&lt;/a&gt; http 的长连接与短连接的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在早期的 &lt;code&gt;http/1.0&lt;/code&gt;  默认使用的是短连接，每次客户端与服务端进行一次 http 操作，就建立一次连接，任务结束就中断连接&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;http/1.1&lt;/code&gt;  起，默认使用的长连接.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http与https的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http与https的区别&#34;&gt;#&lt;/a&gt; http 与 https 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;session与cookie&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#session与cookie&#34;&gt;#&lt;/a&gt; session 与 cookie&lt;/h2&gt;
&lt;h2 id=&#34;dns域名系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dns域名系统&#34;&gt;#&lt;/a&gt; DNS 域名系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于人而言记忆一串有意义的字符串要比记忆一组无规律的数字要容易的多；DNS，即为域名系统，是一个由域名到 IP 地址的分布式数据库，可以方便的完成域名到 IP 的转换.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;工作原理：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arp协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arp协议&#34;&gt;#&lt;/a&gt; ARP 协议&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;网络层的 IP 报文向下需要封装成帧，需要添加以太网头部，这就需要知道节点的 MAC 地址；ARP 的作用就是完成 IP 地址到 MAC 地址的转化协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;首先每个主机都会维护一张 ARP 列表，用于存储 IP 地址到 MAC 地址的映射&lt;/li&gt;
&lt;li&gt;源主机发送数据时，首先检查 ARP 列表内是否有目的地址的 MAC 地址，如果有，则写入以太网头部，并发送帧。如果没有，主机以广播的形式发送 ARP 数据报，数据报内源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址&lt;/li&gt;
&lt;li&gt;当网络中的主机收到 ARP 数据包时，首先检查报文中的 IP 地址是否是自己，如果不是则丢弃该报文；否则将自己的 MAC 地址写入 ARP 响应报文中，同时将源主机的 IP 地址和 MAC 地址键值对写入自己的 ARP 列表中.&lt;/li&gt;
&lt;li&gt;源主机收到 ARP 响应报文后，将目的主机的 IP 地址和 MAC 地址写入自身的 APR 列表中，并写入以太网头部，发送该帧.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>

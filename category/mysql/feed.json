{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"mysql\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0",
            "url": "http://example.com/value/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0",
            "title": "线程池实现",
            "date_published": "2024-03-17T11:27:36.716Z",
            "content_html": "<h2 id=\"什么是线程池线程池的好处\"><a class=\"anchor\" href=\"#什么是线程池线程池的好处\">#</a> 什么是线程池？线程池的好处</h2>\n<blockquote>\n<p>通俗上来说线程池是一个管理线程的池子，它可以容纳多个线程，并对线程可以进行反复的利用，省去了频繁的线程的创建和销毁开销.</p>\n</blockquote>\n<h2 id=\"线程池的核心参数\"><a class=\"anchor\" href=\"#线程池的核心参数\">#</a> 线程池的核心参数</h2>\n<ul>\n<li>\n<p>任务队列：存储需要处理的任务（函数地址）</p>\n<blockquote>\n<ol>\n<li>\n<p>为了管理任务队列，需要线程池提供 API 接口，用于往任务队列中添加任务和删除任务</p>\n</li>\n<li>\n<p>生产者 - 消费者模型</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>工作的线程（消费者线程）：负责去任务队列中取任务</p>\n<blockquote>\n<ol>\n<li>线程池中维护一定数量的工作线程，不停的读取任务队列并且处理任务函数</li>\n<li>如果任务队列为空，工作的线程会堵塞（使用条件变量 / 信号量）</li>\n<li>工作线程堵塞后有新任务产生，生产者线程会唤醒工作的线程</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>管理者线程：主线程</p>\n<blockquote>\n<p>周期性的对任务队列中的任务数量以及工作线程数进行检测，当任务过多时，可以适当的创建一些新的工作线程；当任务过少时，可以适当</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"任务队列\"><a class=\"anchor\" href=\"#任务队列\">#</a> 任务队列</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>*/</span></pre></td></tr></table></figure><h2 id=\"创建线程\"><a class=\"anchor\" href=\"#创建线程\">#</a> 创建线程</h2>\n<pre><code class=\"language-c++\">/* 查看当前线程ID */\ntypedef unsigned long int pthread_t;\npthread_t pthread_self(void);\n/* 创建进程 */\nunion pthread_attr_t\n&#123;\n  char __size[__SIZEOF_PTHREAD_ATTR_T];\n  long int __align;\n&#125;;\ntypedef union pthread_attr_t pthread_attr_t;\nint pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);\n/*\nDescription:\n\tnewthread：传出参数，创建的新线程ID\n\taddr：线程的属性，一般情况使用默认值即可，NULL\n\tstart_routine:函数指针，创建出的子进程的处理函数，也就是在子线程中需要执行的函数\n\targ:作为实参传递到start_routine指针指向的函数内部\nReturn Value:\n\t线程创建成功返回0，否则返回对于的错误码\n*/\n</code></pre>\n<h2 id=\"线程退出\"><a class=\"anchor\" href=\"#线程退出\">#</a> 线程退出</h2>\n<pre><code class=\"language-c++\">void pthread_exit(void *retval);\n/*\nDescription:\n\t只要调用该函数，当前线程立马退出，并且不影响其他线程的运行，不管是在子进程还是主进程中都可以使用\n\tretval:线程退出时携带的数据，当前子线程的主进程会得到该数据。如果不需要，指定为NULL。\n*/\n</code></pre>\n<h2 id=\"线程回收\"><a class=\"anchor\" href=\"#线程回收\">#</a> 线程回收</h2>\n<pre><code class=\"language-c++\">int pthread_join(pthread_t thread, void **retval);\n/*\nDescription:\n\t用于在子进程退出后，主进程回收子进程的内核资源。该函数为一个堵塞函数，如果子进程还在运行，调用该函数就会堵塞，子线程退出函数解除堵塞，并将线程占用的内核资源回收。\n\tthread：子进程的进程ID\n\tretval：二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了pthread_exit()传递出的数据，如果不需要这个参数，可以指定为NULL。\nReturn Value:\n\t线程回收成功返回0，回收失败返回错误码。\n*/\n</code></pre>\n<h2 id=\"线程分离\"><a class=\"anchor\" href=\"#线程分离\">#</a> 线程分离</h2>\n<p>在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 <code>pthread_join()</code> ，只要子线程不退出，主线程就会被一直堵塞，主线程的任务也就不能被执行。</p>\n<pre><code class=\"language-c++\">int pthread_detach(pthread_t thread);\n/*\nDescription:\n\t调用线程分离函数之后，指定的子线程就可以和主线程分离，当子进程退出的时候，其占用的内核资源就会被系统的其他线程接管并回收。线程分离之后，主线程中使用的pthread_join()就回收不到子线程的资源了。\n\tthread：子线程ID\n*/\n</code></pre>\n<h2 id=\"线程取消\"><a class=\"anchor\" href=\"#线程取消\">#</a> 线程取消</h2>\n<pre><code class=\"language-c++\">int pthread_cancel(pthread_t thread);\n/*\nDescription:\n\t在一个线程中杀死另外一个线程。使用这个函数杀死一个线程需要分两步：\n\t1. 在线程A中调用线程取消函数pthread_cancel(),指定杀死线程B。\n\t2. 线程B中执行一次系统调用时才会被杀死，否则仍然存活。\n*/\n</code></pre>\n<h2 id=\"线程id比较\"><a class=\"anchor\" href=\"#线程id比较\">#</a> 线程 ID 比较</h2>\n<pre><code class=\"language-c++\">int pthread_equal(pthread_t t1, pthread_t t2);\n/*\nDescription:\n\tt1,t2为需要比较的两个线程ID。\nReturn Value:\n\t如果两个线程ID相等返回一个非0值，如果不等则返回0\n*/\n</code></pre>\n<h2 id=\"线程同步\"><a class=\"anchor\" href=\"#线程同步\">#</a> 线程同步</h2>\n<h3 id=\"互斥锁\"><a class=\"anchor\" href=\"#互斥锁\">#</a> 互斥锁</h3>\n<p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块。被锁定的代码块，所以线程只能顺序执行。</p>\n<pre><code class=\"language-c++\">pthread_mutex_t mutex;\n/* 初始化互斥锁 */\nint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *attr);\n/*\n\tmutex: 互斥锁变量地址\n\tattr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为NULL\n\t返回0，则初始化成功，否则返回错误码\n*/\n/* 释放互斥锁 */\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n/* 上锁 */\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t这个函数被调用，实现会判断参数mutex互斥锁中的状态是不是锁定状态：\n\t\t- 没有锁定，则这个线程可以加锁成功，这个锁会记录是哪一个线程加锁成功了\n\t\t- 如果被锁定，其他线程加锁就失败了，这些线程都会被堵塞在这把锁上\n\t\t- 当这把锁被解开之后，这些堵塞在锁上的线程就会解除堵塞，并且这些线程通过竞争的方式对这把锁加锁，没抢到锁的进程继续堵塞\n*/\n/* 尝试加锁 */\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t尝试对mutex互斥锁进行加锁：\n\t\t- 若互斥锁没有被锁定，线程加锁成功\n\t\t- 若互斥锁被锁定，调用这个函数加锁的线程，不会被堵塞，加锁失败直接返回错误码\n*/\n\n/* 解锁 */\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n/*\nDescription:\n\t并不是所以的线程都可以对互斥锁解锁，那个线程加的锁，那个线程才可以解锁。\n*/\n</code></pre>\n<h3 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h3>\n<p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。</p>\n<h3 id=\"读写锁\"><a class=\"anchor\" href=\"#读写锁\">#</a> 读写锁</h3>\n<p>读锁是共享的，写锁是独占的；写锁比读锁优先级高；如果临界区涉及大量的读操作，使用读写锁比使用互斥锁效率高，而只有少量的读操作，则互斥锁和读写锁效率差异不大</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pthread_rwlock_t rwlock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">/* 初始化读写锁 */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_init</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>restrict rwlock<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> pthread_rwlockattr_t <span class=\"token operator\">*</span>restrict attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/* 销毁读写锁 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_destroy</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/* 加读锁 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_rdlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">/* 尝试加读锁，加锁失败不堵塞 */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_tryrdlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">/* 加写锁 */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_wrlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* 尝试加写锁，加锁失败不堵塞 */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_trywrlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">/* 解锁（读锁 / 写锁） */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_rwlock_unlock</span><span class=\"token punctuation\">(</span>pthread_rwlock_t <span class=\"token operator\">*</span>rwlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"条件变量\"><a class=\"anchor\" href=\"#条件变量\">#</a> 条件变量</h3>\n<p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型为 <code>pthread_cond_t</code> ，被条件变量堵塞的线程以及线程信息会被记录到这个变量中，以便在解除堵塞时使用。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pthread_cond_t cond<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">/* 初始化 */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_init</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> pthread_condaddr_t <span class=\"token operator\">*</span>restrict attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/* 销毁释放资源 */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_destroy</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">/* 堵塞当前线程 / 进程 */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> pthread_mutex_t <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">timespec</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    time_t tv_sec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">long</span> tv_nsec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_timedwait</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>restrict cond<span class=\"token punctuation\">,</span> pthread_mutex_t <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">timespec</span> <span class=\"token operator\">*</span>restrict abstime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">/* 唤醒堵塞在条件变量上的一个线程 */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">/* 唤醒所以堵塞在条件变量上的线程 */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_cond_broadcast</span><span class=\"token punctuation\">(</span>pthread_cond_t <span class=\"token operator\">*</span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;semaphore.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>sem_t sem<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_init</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pshared<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tsem: 信号量变量地址</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tpshared: 0 表示线程同步；非 0 表示进程同步</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tvalue: 初始化当前信号量拥有的资源数</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_destroy</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">&amp;</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_try_wait</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">/* 产看信号量 sem 当前拥有的资源个数，通过第二个参数传出（返回值也可以） */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_getvalue</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>sval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">sem_post</span><span class=\"token punctuation\">(</span>sem_t <span class=\"token operator\">*</span>sem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "多线程"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "MySQL面试题",
            "date_published": "2024-03-13T06:46:17.113Z",
            "content_html": "<h1 id=\"mysql面试题\"><a class=\"anchor\" href=\"#mysql面试题\">#</a> MySQL 面试题</h1>\n<h2 id=\"关系型数据库和非关系型数据库\"><a class=\"anchor\" href=\"#关系型数据库和非关系型数据库\">#</a> 关系型数据库和非关系型数据库</h2>\n<h2 id=\"myisam和innodb的区别\"><a class=\"anchor\" href=\"#myisam和innodb的区别\">#</a>  <code>MyISAM</code>  和 <code>InnoDB</code>  的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引采用的是非聚簇索引，索引的数据域存储数据的指针，而 <code>InnoDB</code>  主键采用的是聚簇索引，非主键采用非聚簇索引，索引的数据域存储主键的 id.</li>\n<li><code>MyISAM</code>  不支持事务，但是每次查询都是原子操作； <code>Innodb</code>  支持 <code>ACID</code>  的事务，支持事务的四种隔离级别</li>\n<li><code>MyISAM</code>  存储表的总行数； <code>InnoDB</code>  不存储表的总行数</li>\n<li><code>MyISAM</code>  不支持外键约束，而 <code>InnoDB</code>  支持</li>\n<li><code>MyISAM</code>  支持最小粒度所为表级锁； <code>InnoDB</code>  支持行级锁</li>\n</ol>\n<h2 id=\"覆盖索引\"><a class=\"anchor\" href=\"#覆盖索引\">#</a> 覆盖索引</h2>\n<blockquote>\n<p>索引的值包含所需要查询的字段</p>\n</blockquote>\n<h2 id=\"innodb的索引与myisam的所索引的区别\"><a class=\"anchor\" href=\"#innodb的索引与myisam的所索引的区别\">#</a>  <code>InnoDB</code>  的索引与 <code>MyISAM</code>  的所索引的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引文件和数据文件是分离的，使用 B + 树来实现，主键索引和辅助索引实现基本一致（非主键不保证唯一）；叶子节点仅保存数据和数据的地址（非聚簇索引）.</li>\n<li><code>InnoDB</code>  索引分两种，聚簇索引和非聚簇索引，聚簇索引的叶子节点同 时也会存储数据。非聚簇索引的索引数据域保存主键的 id</li>\n</ol>\n<h2 id=\"为什么使用索引\"><a class=\"anchor\" href=\"#为什么使用索引\">#</a> 为什么使用索引</h2>\n<blockquote>\n<p>索引是数据库中用于加速数据访问的一种数据结构</p>\n</blockquote>\n<ul>\n<li>\n<p>在关系型数据库中，通常使用 <code>B-Tree</code>  或哈希表等索引结构</p>\n</li>\n<li>\n<p>索引可以提高查询效率，建立索引的原则如下.</p>\n<blockquote>\n<ol>\n<li>区分度高的列作为索引可以加快查询速度</li>\n<li>经常出现在 <code>where</code>  中的列</li>\n<li>表记录较少索引效果不好，没有必要建立索引</li>\n<li>定义有外键的数据列一定要建立索引</li>\n<li>更新频繁的数据列不适合建立索引</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>索引会降低插入、删除、更新表的速度，因为在执行这些操作时，还需要操作索引文件.</p>\n</li>\n<li>\n<p>索引需要占用物理空间，除了索引表需要占用空间之外，每个索引也需要占用额外的存储空间。同时如果非聚餐索引很多，一旦聚簇索引改变，那么非聚簇索引也需要跟着改变，代价比较大</p>\n</li>\n</ul>\n<blockquote>\n<p>MySQL 中使用较多的是 <code>Hash索引</code> 和 <code>B+树索引</code></p>\n<p>对于哈希索引来说，底层的数据结构就是哈希表，因此对于绝大多数需求为单挑记录的查询的时候，可以选择哈希索引，查询性能高，其余的绝大多数场景使用 B + 树所以</p>\n</blockquote>\n<h2 id=\"聚簇索引和非聚簇索引的区别\"><a class=\"anchor\" href=\"#聚簇索引和非聚簇索引的区别\">#</a> 聚簇索引和非聚簇索引的区别</h2>\n<ul>\n<li>\n<p>聚簇索引：主键索引</p>\n<blockquote>\n<ol>\n<li>将数据存储在索引树的叶子节点上，可以减少一次查询（查询索引树的同时就能获得数据）</li>\n<li>当需要对数据进行修改或删除时，需要更新索引树，增加系统开销（聚簇索引保证顺序，当中间有数据需要插入时，可能引起分页）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>非聚簇索引：二级索引 / 辅助索引</p>\n<blockquote>\n<ol>\n<li>不将数据存储在索引树中，而是存储在数据页中；查询数据时需要两次查询，一次用于查询索引树，获取数据页的地址，在通过数据页的地址来查询数据（如果索引覆盖的话实际上不用回表）</li>\n<li>当需要对数据进行修改或删除时，不需要更新索引树，减少了系统开销</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"唯一索引与普通索引\"><a class=\"anchor\" href=\"#唯一索引与普通索引\">#</a> 唯一索引与普通索引</h2>\n<ul>\n<li>\n<p>区别：唯一索引的索引值必须唯一，但允许有空值（即可以是单列唯一索引也可以是联合唯一索引）；普通索引索引值不一定唯一，且允许有空值.</p>\n<blockquote>\n<p>唯一索引可以保证数据的唯一性</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"联合索引-组合索引-复合索引\"><a class=\"anchor\" href=\"#联合索引-组合索引-复合索引\">#</a> 联合索引、组合索引、复合索引</h2>\n<blockquote>\n<p>组合索引、联合索引、复合索引指代都是一个意思，一个索引包含多个列</p>\n</blockquote>\n<ul>\n<li>\n<p><code>最左前缀匹配</code> ：组合索引的第一个字段必须出现在查询语句中，还不能跳跃，只有这样才能让组合索引生效</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 假设给 username，age 创建了组合索引</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 组合索引生效</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span> <span class=\"token operator\">and</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 特殊情况</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 组合索引失效</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> city <span class=\"token operator\">=</span> <span class=\"token string\">'shenzhen'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">18</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"索引失效的情况\"><a class=\"anchor\" href=\"#索引失效的情况\">#</a> 索引失效的情况</h2>\n<ul>\n<li>\n<p>使用 <code>like</code>  查询并且左边带 <code>%</code></p>\n<blockquote>\n<p>索引往往使用的是 B + 树结构，是一个有序排列的。百分号放在前面进行一个模糊查找时，前面都能匹配，很有可能就无法更具索引的有序性来进行查找了.</p>\n</blockquote>\n</li>\n<li>\n<p>隐式类型转换。索引字段是 <code>int</code> ，而使用字符串类型去查询</p>\n</li>\n<li>\n<p><code>where</code>  条件里面对索引使用运算或者函数</p>\n</li>\n<li>\n<p>使用 <code>or</code>  且存在非索引列</p>\n</li>\n<li>\n<p><code>where</code>  条件中对两列作比较</p>\n</li>\n<li>\n<p>使用 <code>in</code> （和数据量有关系）</p>\n</li>\n<li>\n<p>使用 <code>order by</code></p>\n</li>\n<li>\n<p><code>is null</code> 、 <code>is not null</code> 、 <code>≠</code></p>\n</li>\n</ul>\n<h2 id=\"innodb为什么使用自增id作为主键\"><a class=\"anchor\" href=\"#innodb为什么使用自增id作为主键\">#</a>  <code>InnoDB</code>  为什么使用自增 <code>id</code>  作为主键</h2>\n<ul>\n<li>使用自增 <code>id</code>  作为主键，那么在建立索引时，每次插入新的记录，记录会顺序添加到当前索引的后续位置，直到一页满为至才会开辟一个新的页</li>\n<li>如果使用非自增主键，由于每次插入的主键值比较随机，每次新纪录可能需要插入到现在索引的中间位置，会操作频繁的移动（内部单链表）和分页</li>\n</ul>\n<h2 id=\"b树与b树\"><a class=\"anchor\" href=\"#b树与b树\">#</a> B 树与 B + 树</h2>\n<blockquote>\n<p>查询一个数据时，在数据页内往往使用二分查找</p>\n</blockquote>\n<ul>\n<li>\n<p>B 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>每个节点包含多个关键字和对应的指针，即 B 数的每个节点都会存储数据</li>\n<li>B 树的叶子节点之间是指针相连的，不支持顺序访问</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>B + 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>所以的关键字都存储在叶子节点上，非叶子节点不存储数据，只存储索引和指向孩子节点的指针</li>\n<li>叶子节点通过指针连接起来，形成一个有序的链表，支持顺序访问和范围查找（MySQL 底层实际是一个双向链表）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>MySQL 选择 B + 树作为索引结构的原因</p>\n<blockquote>\n<ol>\n<li>范围查询和顺序访问的性能更高：B + 树的叶子节点通过指针连接成一个双向链表，可以很好的支持数据库的范围查询，同时在连续的数据查询中，B + 树可以利用磁盘的预读特性，提高数据顺序访问性能，嫌少磁盘 I/O</li>\n<li>更少的磁盘 I/O：B + 树的非叶子节点只存储索引和指向孩子的节点指针，不存储数据，相比于 B 树，每个节点可以存储更多的关键字，减少了磁盘 I/O 次数（节点可以存储更多的关键字，可以使得 B + 树高更矮)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> 数据库三大范式</h2>\n<blockquote>\n<p>数据库设计表结构时所遵循的规范，目的是为了减少冗余，提高数据存储和使用的效率</p>\n</blockquote>\n<ul>\n<li>第一范式：数据库表中的每个列都必须是原子性的，不可再分；同时每个表有一个主键.</li>\n<li>第二范式：表中非主键列必须完全依赖于主键，而不是部分依赖于主键. (如果有非主键列部分依赖于主键，需要将改列拆分并且放置于另外一张表中)</li>\n<li>第三范式：表中的非主键列之间不能存在传递依赖关系</li>\n</ul>\n<blockquote>\n<p>在实际的设计，经常也有反范式的现象，通过冗余的数据，来避免跨表的连接查询，以此来提高数据库的查询效率</p>\n</blockquote>\n<h2 id=\"数据库表的连接方式\"><a class=\"anchor\" href=\"#数据库表的连接方式\">#</a> 数据库表的连接方式</h2>\n<ul>\n<li>内连接</li>\n<li>左连接</li>\n<li>右连接</li>\n<li>全连接</li>\n<li>自连接</li>\n</ul>\n<h2 id=\"char与varchar\"><a class=\"anchor\" href=\"#char与varchar\">#</a> char 与 varchar</h2>\n<ul>\n<li>\n<p><code>char</code> ：定长字符类型。如果存储的字符串长度小于指定长度，会使用空格进行填充</p>\n</li>\n<li>\n<p><code>varchar</code> ：变长字符类型。它实际占用的存储空间为字符串的实际空间和用于存储字符串长度信息的空间</p>\n<blockquote>\n<ol>\n<li>存储效率： <code>char</code>  定长，无论字符串的实际长度多少，它占用的存储空间是固定，会浪费一定的空间.  <code>varchar</code>  是变长的，其占用的实际空间会随着字符串的大小而变动，存储效率较高</li>\n<li>查询效率： <code>char</code>  在搜索和排序方面的操作效率要高于 <code>varchar</code>  类型</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql锁的种类\"><a class=\"anchor\" href=\"#mysql锁的种类\">#</a> MySQL 锁的种类</h2>\n<ul>\n<li>\n<p>读写锁（锁的属性）</p>\n<blockquote>\n<ol>\n<li>共享锁 <code>Share Lock</code> ：读锁（ <code>S锁</code> ），当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁。为了支持高并发读取数据.</li>\n<li>排他锁 <code>Exclusive Lock</code> ：写锁（ <code>X锁</code> ），当一个事务为数据加上了写锁之后，其他请求不能再为这条数据加任何锁.</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>锁的粒度</p>\n<blockquote>\n<ol>\n<li>行锁：锁住表中的某一行或多行，粒度小，冲突小</li>\n<li>表锁：锁住整张表，粒度大，容易冲突</li>\n<li>记录数 <code>Record Lock</code> ：是行锁的一种，锁住表中的一条记录（命中的条件字段是一定是唯一索引）</li>\n<li>页锁：一种粒度介于行所和表锁之间的一种锁。每次锁定相邻的一组记录.</li>\n<li>间隙锁 <code>Gap Lock</code> ：属于行锁的一种</li>\n<li>临建锁 <code>Next-Key Lock</code></li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>意向锁</p>\n<blockquote>\n<p>如果当事务 A 加锁成功后设置一个状态告诉后面的人：已经有人对表里的行加了一个排他锁，不能再对整个表加共享锁或排他锁，那么后面需要对整个表加锁的人获取这个状态就知道是不是可以对表加锁，避免对这个索引表的每个节点扫描查看他们是否加锁，这个锁就是意向锁.</p>\n<ul>\n<li>意向共享锁：当一个事务试图对整个表加共享锁时，首先需要获取这个表的意向共享锁</li>\n<li>意向排他锁：当一个事务试图对整个表加排他锁时，首先需要获取这个表的意向排他锁</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql执行计划\"><a class=\"anchor\" href=\"#mysql执行计划\">#</a> MySQL 执行计划</h2>\n<blockquote>\n<p>执行计划： <code>sql</code>  的执行查询的顺序，以及如何使用索引</p>\n<p>在语句前面添加 <code>explain</code>  即可打印执行计划</p>\n</blockquote>\n<ul>\n<li>\n<p>执行计划参数</p>\n<blockquote>\n<ol>\n<li><code>id</code> ：</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql中的死锁\"><a class=\"anchor\" href=\"#mysql中的死锁\">#</a> MySQL 中的死锁</h2>\n<blockquote>\n<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的的一种互相等待的现象.</p>\n<p>产看死锁的命令： <code>show engine innodb status</code> ；可以通过设置 <code>innodblockwait_timeout</code>  来设置曹超时时间或主动回滚死锁中的某个事务.</p>\n</blockquote>\n<h2 id=\"数据库的四大特性acid\"><a class=\"anchor\" href=\"#数据库的四大特性acid\">#</a> 数据库的四大特性 ACID</h2>\n<ul>\n<li>\n<p><code>原子性Atomicity</code> ：当前事务的操作要么执行成功，要么执行失败</p>\n<blockquote>\n<p>由 <code>undo log</code>  日志保证，记录了需要回滚的日子信息，事务回滚时撤销已经执行成功的 <code>sql</code>  语句</p>\n</blockquote>\n</li>\n<li>\n<p><code>一致性Consistency</code></p>\n<blockquote>\n<p>由其他三大特性共同来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>隔离性Isolation</code> ：在事务并发执行时，他们内部的操作不能互相干扰</p>\n<blockquote>\n<p>由 <code>MVCC</code>  来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>持久性Durability</code></p>\n<blockquote>\n<p>由内存 <code>redo log</code>  来保证， <code>mysql</code>  修改数据同时在内存和 <code>redo log</code>  记录这次操作，宕机的时候可以从 <code>redo log</code>  恢复</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"事务隔离级别\"><a class=\"anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h2>\n<blockquote>\n<p><code>InnoDB</code>  中 隔离性是由 MySQL 的各种锁机制以及 <code>MVCC</code>  来实现的</p>\n</blockquote>\n<ul>\n<li>读未提交 <code>read_uncommitted(RU)</code> ：有脏读问题</li>\n<li>读已提交 <code>read_committed(RC)</code> ：有不可重复读的问题</li>\n<li>可重复读 <code>repeatable-read(RR)</code> ：会有幻读的问题</li>\n<li>串行化 <code>serializable</code></li>\n</ul>\n<h2 id=\"数据库并发事务会带来哪些问题\"><a class=\"anchor\" href=\"#数据库并发事务会带来哪些问题\">#</a> 数据库并发事务会带来哪些问题</h2>\n<ul>\n<li>脏读</li>\n<li>不可重复读</li>\n<li>幻读</li>\n<li>丢失修改</li>\n</ul>\n<h2 id=\"mvcc\"><a class=\"anchor\" href=\"#mvcc\">#</a> MVCC</h2>\n<blockquote>\n<p>多版本并发控制：读取数据时通过一种类似于快照的方式将数据保存下来，这样读锁和写锁就不冲突了；不同的事务会看到特定版本的数据（版本链）</p>\n</blockquote>\n<ul>\n<li>\n<p><code>MVCC</code>  只在读已提交和可重复读两个隔离级别下工作. ( <code>read_uncommited</code>  总是读取最新的数据； <code>serializable</code>  会对所以的读操作加锁)</p>\n<blockquote>\n<p>聚簇索引中有两个隐藏的列</p>\n<ol>\n<li><code>trx_id</code> ：存储每次对这条索引记录进行修改的 <code>事务ID</code>  (事务 ID 根据时间顺序依次递增)</li>\n<li><code>roll_pointer</code> ：上一版本的记录地址.（每次对聚簇索引记录有修改操作时，都会把老版本写入 <code>undo</code>  日志中，而这个修改后的新记录的 <code>roll_pointer</code>  则会指向日志中旧版本）</li>\n</ol>\n<p><code>ReadView</code>  是快照读（普通的 <code>select</code>  查询语句）执行时 <code>MVCC</code>  提取数据的依据</p>\n<ol>\n<li><code>m_ids</code> ：当前活跃的事务编号的集合（还未提交的事务集合）</li>\n<li><code>min_trx_id</code> ：最小活跃事务的编号</li>\n<li><code>max_trx_id</code> ：预分配事务的编号，当前最大事务 ID+1</li>\n<li><code>creator_trx_id</code> ： <code>ReadView</code>  创建者的事务编号</li>\n</ol>\n<p><code>当前读</code> ：指执行如下指令对数据进行读取</p>\n<ul>\n<li><code>Insert、Update、Delete、Select ... for Update、Select ... lock in share mode</code></li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%89%88%E6%9C%AC%E9%93%BE.png\" alt=\"\" title=\"版本链\" /></p>\n</li>\n<li>\n<p>读已提交隔离级别下 MVCC 的工作方式：在每一次执行快照读的时候生成 <code>ReadView</code></p>\n<blockquote>\n<p>1. 判断版本链的 <code>trx_id</code>  是否等于 <code>creator_trx_id</code> ，若等于说明对该条记录的更新就是当前事务，则可以访问</p>\n<p>2. 判断版本链的 <code>trx_id</code>  是否小于 <code>min_trx_id</code> ，若小于说明对该记录的处理已经提交，可访问</p>\n<p>3. 判断版本链的 <code>trx_id</code>  是否大于等于 <code>max_trx_id</code> ，如果成立说明对该条记录的操作是在生成 <code>ReadView</code>  之后，不可访问</p>\n<p>4. 判断版本链的 <code>trx_id</code>  是否在 <code>m_idx</code>  中，如果不存在，说明对该条记录的操作已提交，可以访问，若存在，则不可访问</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/ReadView.png\" alt=\"\" title=\"ReadView\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>可重复读级别下 MVCC 的工作方式：仅在第一次执行快照读的时候生成 <code>ReadView</code>  ，从而保证事务内对于一条记录的查询是一致的</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png\" alt=\"\" /></p>\n<blockquote>\n<p>多次连续的快照读， <code>ReadView</code>  会复用，没有幻读问题。但是两次连续的 <code>快照读</code> 之间存在 <code>当前读</code> 时， <code>ReadView</code>  会重新生成，导致产生幻读</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.png\" alt=\"\" /></p>\n</li>\n</ul>\n<h2 id=\"mysql主从同步原理\"><a class=\"anchor\" href=\"#mysql主从同步原理\">#</a> MySQL 主从同步原理</h2>\n<blockquote>\n<p><code>MySQL主从同步</code> 主要涉及到三个线程，主节点 master 上的 <code>binlog dump thread</code> ，从节点 slave 上的 <code>IO thread</code>  和 <code>sql thread</code> . 主节点的 <code>binlog</code>  维护的是主库记录的所以变更记录.</p>\n<ol>\n<li>主节点的 <code>log dump</code>  线程，当 <code>binlog</code>  有变动时， <code>log dump</code>  会读取 <code>binlog</code>  日志变动的内容并发送到从节点</li>\n<li>从节点的 <code>IO thread</code>  接收到 <code>binlog</code>  内容 ，并将其写入 <code>relay log</code>  文件中.</li>\n<li>从节点的 <code>sql thread</code>  读取 <code>realy log</code>  新增的内容并执行，最终保持主从数据库的一致性.</li>\n</ol>\n<p>注：主节点使用 <code>binlog</code>  文件和 <code>position</code>  偏移量来定位主动同步的位置（增量同步）</p>\n<p>由于 MySQL 的默认的主从同步方式是异步 的，主节点把日志发送给从节点后不关系从库是否已经处理，这样会产生一个问题：主节点挂了，从节点处理失败了，那么这时从节点升级为主节点后，就会有一部分日志丢失了，有一下解决方案：</p>\n<ul>\n<li>全同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，需要等待所以的从节点执行完成之后，在将结果返回给客户端. (影响效率)</li>\n<li>半同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，不需要等待所以的从节点执行完成，当收到至少一个从节点的同步完成就将结果返回给客户端.</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "面试题",
                "MySQL"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"mysql\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95",
            "url": "http://example.com/value/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95",
            "title": "MySQL基础语法",
            "date_published": "2024-03-30T01:58:45.307Z",
            "content_html": "<h1 id=\"mysql基础语法\"><a class=\"anchor\" href=\"#mysql基础语法\">#</a> MySQL 基础语法</h1>\n<h2 id=\"create创建数据库\"><a class=\"anchor\" href=\"#create创建数据库\">#</a>  <code>create</code>  创建数据库</h2>\n<p>建数据库基本语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">create</span> <span class=\"token keyword\">database</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">if</span> <span class=\"token operator\">not</span> <span class=\"token keyword\">exists</span><span class=\"token punctuation\">]</span> database_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> charset_name<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">collate</span> collation_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 如果创建的 database_name 已存在，则执行会导致错误。添加 if not exists 可以避免</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># charset_name 可以指定字符集（？）</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># collation_name 指定排列规则（？）</span></pre></td></tr></table></figure><h2 id=\"drop删除数据库\"><a class=\"anchor\" href=\"#drop删除数据库\">#</a>  <code>drop</code>  删除数据库</h2>\n<p>使用普通用户登录 <code>MySQL</code>  服务器，需要特定的权限才可以删除或创建数据库.</p>\n<p>删除数据库基本语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">drop</span> <span class=\"token keyword\">database</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">if</span> <span class=\"token keyword\">exists</span><span class=\"token punctuation\">]</span> database_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"use选择数据库\"><a class=\"anchor\" href=\"#use选择数据库\">#</a>  <code>use</code>  选择数据库</h2>\n<p>选择数据库基础语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">use</span> database_name</pre></td></tr></table></figure><h2 id=\"基本数据类型\"><a class=\"anchor\" href=\"#基本数据类型\">#</a> 基本数据类型</h2>\n<ul>\n<li>\n<p>数值类型</p>\n<blockquote>\n<ol>\n<li><code>tinyint</code> ：1 字节.</li>\n<li><code>smallint</code> ：2 字节</li>\n<li><code>mediumint</code> ：3 字节</li>\n<li><code>int</code> ：4 字节</li>\n<li><code>bigint</code> ：8 字节</li>\n<li><code>float</code> ：4 字节，单精度浮点数</li>\n<li><code>double</code> ：8 字节，双进度浮点数</li>\n<li><code>decimal</code></li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>日期和时间类型</p>\n</li>\n<li>\n<p>字符串类型</p>\n<blockquote>\n<ol>\n<li><code>char</code> ：</li>\n<li><code>varchar</code></li>\n<li></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"create创建数据库表\"><a class=\"anchor\" href=\"#create创建数据库表\">#</a>  <code>create</code>  创建数据库表</h2>\n<p>创建数据库表基本语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> table_name&#123;</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tcoloumn1 datatype<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tcolomun2 datatype<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> charset_name<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">collate</span> collation_name<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">engine</span><span class=\"token operator\">=</span>engine_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>字段属性：</p>\n<ul>\n<li><code>Primary key</code> ：主键</li>\n<li><code>auto_increment</code> ：自增，一般用于主键</li>\n<li><code>not null</code> ：非空，若输入的记录该字段为空，则会报错</li>\n</ul>\n<h2 id=\"drop删除数据库表\"><a class=\"anchor\" href=\"#drop删除数据库表\">#</a>  <code>drop</code>  删除数据库表</h2>\n<p>删除数据库表基本语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">drop</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">if</span> <span class=\"token keyword\">exists</span><span class=\"token punctuation\">]</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"insert插入数据\"><a class=\"anchor\" href=\"#insert插入数据\">#</a>  <code>insert</code>  插入数据</h2>\n<p>插入数据基本语法：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> table_name<span class=\"token punctuation\">(</span>column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span>values1<span class=\"token punctuation\">,</span> values2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token punctuation\">[</span><span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span>values1<span class=\"token punctuation\">,</span> values2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果主键为自增的列，可使用 <code>NULL</code>  占位符替代</p>\n<h2 id=\"delete删除数据\"><a class=\"anchor\" href=\"#delete删除数据\">#</a>  <code>delete</code>  删除数据</h2>\n<h2 id=\"select查询数据\"><a class=\"anchor\" href=\"#select查询数据\">#</a>  <code>select</code>  查询数据</h2>\n<h2 id=\"wherer子句\"><a class=\"anchor\" href=\"#wherer子句\">#</a>  <code>wherer</code>  子句</h2>\n<h2 id=\"update更新\"><a class=\"anchor\" href=\"#update更新\">#</a>  <code>update</code>  更新</h2>\n<h2 id=\"like子句\"><a class=\"anchor\" href=\"#like子句\">#</a>  <code>like</code>  子句</h2>\n<h2 id=\"union\"><a class=\"anchor\" href=\"#union\">#</a>  <code>union</code></h2>\n<h2 id=\"order-by语句\"><a class=\"anchor\" href=\"#order-by语句\">#</a>  <code>order by</code>  语句</h2>\n<h2 id=\"group-by分组\"><a class=\"anchor\" href=\"#group-by分组\">#</a>  <code>group by</code>  分组</h2>\n<h2 id=\"连接\"><a class=\"anchor\" href=\"#连接\">#</a> 连接</h2>\n<h2 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h2>\n<h2 id=\"索引\"><a class=\"anchor\" href=\"#索引\">#</a> 索引</h2>\n<h2 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h2>\n<h2 id=\"参考文章\"><a class=\"anchor\" href=\"#参考文章\">#</a> 参考文章</h2>\n<ul>\n<li>[1] <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9teXNxbC9teXNxbC10dXRvcmlhbC5odG1s\">MySQL 教程 | 菜鸟教程 (runoob.com)</span></li>\n</ul>\n",
            "tags": [
                "数据库",
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/%E6%A0%A1%E6%8B%9B%E4%B8%8E%E9%9D%A2%E8%AF%95/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "MySQL面试题",
            "date_published": "2024-03-13T06:46:17.113Z",
            "content_html": "<h1 id=\"mysql面试题\"><a class=\"anchor\" href=\"#mysql面试题\">#</a> MySQL 面试题</h1>\n<h2 id=\"关系型数据库和非关系型数据库\"><a class=\"anchor\" href=\"#关系型数据库和非关系型数据库\">#</a> 关系型数据库和非关系型数据库</h2>\n<h2 id=\"myisam和innodb的区别\"><a class=\"anchor\" href=\"#myisam和innodb的区别\">#</a>  <code>MyISAM</code>  和 <code>InnoDB</code>  的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引采用的是非聚簇索引，索引的数据域存储数据的指针，而 <code>InnoDB</code>  主键采用的是聚簇索引，非主键采用非聚簇索引，索引的数据域存储主键的 id.</li>\n<li><code>MyISAM</code>  不支持事务，但是每次查询都是原子操作； <code>Innodb</code>  支持 <code>ACID</code>  的事务，支持事务的四种隔离级别</li>\n<li><code>MyISAM</code>  存储表的总行数； <code>InnoDB</code>  不存储表的总行数</li>\n<li><code>MyISAM</code>  不支持外键约束，而 <code>InnoDB</code>  支持</li>\n<li><code>MyISAM</code>  支持最小粒度所为表级锁； <code>InnoDB</code>  支持行级锁</li>\n</ol>\n<h2 id=\"覆盖索引\"><a class=\"anchor\" href=\"#覆盖索引\">#</a> 覆盖索引</h2>\n<blockquote>\n<p>索引的值包含所需要查询的字段</p>\n</blockquote>\n<h2 id=\"innodb的索引与myisam的所索引的区别\"><a class=\"anchor\" href=\"#innodb的索引与myisam的所索引的区别\">#</a>  <code>InnoDB</code>  的索引与 <code>MyISAM</code>  的所索引的区别</h2>\n<ol>\n<li><code>MyISAM</code>  索引文件和数据文件是分离的，使用 B + 树来实现，主键索引和辅助索引实现基本一致（非主键不保证唯一）；叶子节点仅保存数据和数据的地址（非聚簇索引）.</li>\n<li><code>InnoDB</code>  索引分两种，聚簇索引和非聚簇索引，聚簇索引的叶子节点同 时也会存储数据。非聚簇索引的索引数据域保存主键的 id</li>\n</ol>\n<h2 id=\"为什么使用索引\"><a class=\"anchor\" href=\"#为什么使用索引\">#</a> 为什么使用索引</h2>\n<blockquote>\n<p>索引是数据库中用于加速数据访问的一种数据结构</p>\n</blockquote>\n<ul>\n<li>\n<p>在关系型数据库中，通常使用 <code>B-Tree</code>  或哈希表等索引结构</p>\n</li>\n<li>\n<p>索引可以提高查询效率，建立索引的原则如下.</p>\n<blockquote>\n<ol>\n<li>区分度高的列作为索引可以加快查询速度</li>\n<li>经常出现在 <code>where</code>  中的列</li>\n<li>表记录较少索引效果不好，没有必要建立索引</li>\n<li>定义有外键的数据列一定要建立索引</li>\n<li>更新频繁的数据列不适合建立索引</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>索引会降低插入、删除、更新表的速度，因为在执行这些操作时，还需要操作索引文件.</p>\n</li>\n<li>\n<p>索引需要占用物理空间，除了索引表需要占用空间之外，每个索引也需要占用额外的存储空间。同时如果非聚餐索引很多，一旦聚簇索引改变，那么非聚簇索引也需要跟着改变，代价比较大</p>\n</li>\n</ul>\n<blockquote>\n<p>MySQL 中使用较多的是 <code>Hash索引</code> 和 <code>B+树索引</code></p>\n<p>对于哈希索引来说，底层的数据结构就是哈希表，因此对于绝大多数需求为单挑记录的查询的时候，可以选择哈希索引，查询性能高，其余的绝大多数场景使用 B + 树所以</p>\n</blockquote>\n<h2 id=\"聚簇索引和非聚簇索引的区别\"><a class=\"anchor\" href=\"#聚簇索引和非聚簇索引的区别\">#</a> 聚簇索引和非聚簇索引的区别</h2>\n<ul>\n<li>\n<p>聚簇索引：主键索引</p>\n<blockquote>\n<ol>\n<li>将数据存储在索引树的叶子节点上，可以减少一次查询（查询索引树的同时就能获得数据）</li>\n<li>当需要对数据进行修改或删除时，需要更新索引树，增加系统开销（聚簇索引保证顺序，当中间有数据需要插入时，可能引起分页）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>非聚簇索引：二级索引 / 辅助索引</p>\n<blockquote>\n<ol>\n<li>不将数据存储在索引树中，而是存储在数据页中；查询数据时需要两次查询，一次用于查询索引树，获取数据页的地址，在通过数据页的地址来查询数据（如果索引覆盖的话实际上不用回表）</li>\n<li>当需要对数据进行修改或删除时，不需要更新索引树，减少了系统开销</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"唯一索引与普通索引\"><a class=\"anchor\" href=\"#唯一索引与普通索引\">#</a> 唯一索引与普通索引</h2>\n<ul>\n<li>\n<p>区别：唯一索引的索引值必须唯一，但允许有空值（即可以是单列唯一索引也可以是联合唯一索引）；普通索引索引值不一定唯一，且允许有空值.</p>\n<blockquote>\n<p>唯一索引可以保证数据的唯一性</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"联合索引-组合索引-复合索引\"><a class=\"anchor\" href=\"#联合索引-组合索引-复合索引\">#</a> 联合索引、组合索引、复合索引</h2>\n<blockquote>\n<p>组合索引、联合索引、复合索引指代都是一个意思，一个索引包含多个列</p>\n</blockquote>\n<ul>\n<li>\n<p><code>最左前缀匹配</code> ：组合索引的第一个字段必须出现在查询语句中，还不能跳跃，只有这样才能让组合索引生效</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 假设给 username，age 创建了组合索引</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 组合索引生效</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span> <span class=\"token operator\">and</span> username <span class=\"token operator\">=</span> <span class=\"token string\">'xujiahao'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 特殊情况</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 组合索引失效</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> city <span class=\"token operator\">=</span> <span class=\"token string\">'shenzhen'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">18</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"索引失效的情况\"><a class=\"anchor\" href=\"#索引失效的情况\">#</a> 索引失效的情况</h2>\n<ul>\n<li>\n<p>使用 <code>like</code>  查询并且左边带 <code>%</code></p>\n<blockquote>\n<p>索引往往使用的是 B + 树结构，是一个有序排列的。百分号放在前面进行一个模糊查找时，前面都能匹配，很有可能就无法更具索引的有序性来进行查找了.</p>\n</blockquote>\n</li>\n<li>\n<p>隐式类型转换。索引字段是 <code>int</code> ，而使用字符串类型去查询</p>\n</li>\n<li>\n<p><code>where</code>  条件里面对索引使用运算或者函数</p>\n</li>\n<li>\n<p>使用 <code>or</code>  且存在非索引列</p>\n</li>\n<li>\n<p><code>where</code>  条件中对两列作比较</p>\n</li>\n<li>\n<p>使用 <code>in</code> （和数据量有关系）</p>\n</li>\n<li>\n<p>使用 <code>order by</code></p>\n</li>\n<li>\n<p><code>is null</code> 、 <code>is not null</code> 、 <code>≠</code></p>\n</li>\n</ul>\n<h2 id=\"innodb为什么使用自增id作为主键\"><a class=\"anchor\" href=\"#innodb为什么使用自增id作为主键\">#</a>  <code>InnoDB</code>  为什么使用自增 <code>id</code>  作为主键</h2>\n<ul>\n<li>使用自增 <code>id</code>  作为主键，那么在建立索引时，每次插入新的记录，记录会顺序添加到当前索引的后续位置，直到一页满为至才会开辟一个新的页</li>\n<li>如果使用非自增主键，由于每次插入的主键值比较随机，每次新纪录可能需要插入到现在索引的中间位置，会操作频繁的移动（内部单链表）和分页</li>\n</ul>\n<h2 id=\"b树与b树\"><a class=\"anchor\" href=\"#b树与b树\">#</a> B 树与 B + 树</h2>\n<blockquote>\n<p>查询一个数据时，在数据页内往往使用二分查找</p>\n</blockquote>\n<ul>\n<li>\n<p>B 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>每个节点包含多个关键字和对应的指针，即 B 数的每个节点都会存储数据</li>\n<li>B 树的叶子节点之间是指针相连的，不支持顺序访问</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>B + 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>所以的关键字都存储在叶子节点上，非叶子节点不存储数据，只存储索引和指向孩子节点的指针</li>\n<li>叶子节点通过指针连接起来，形成一个有序的链表，支持顺序访问和范围查找（MySQL 底层实际是一个双向链表）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>MySQL 选择 B + 树作为索引结构的原因</p>\n<blockquote>\n<ol>\n<li>范围查询和顺序访问的性能更高：B + 树的叶子节点通过指针连接成一个双向链表，可以很好的支持数据库的范围查询，同时在连续的数据查询中，B + 树可以利用磁盘的预读特性，提高数据顺序访问性能，嫌少磁盘 I/O</li>\n<li>更少的磁盘 I/O：B + 树的非叶子节点只存储索引和指向孩子的节点指针，不存储数据，相比于 B 树，每个节点可以存储更多的关键字，减少了磁盘 I/O 次数（节点可以存储更多的关键字，可以使得 B + 树高更矮)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> 数据库三大范式</h2>\n<blockquote>\n<p>数据库设计表结构时所遵循的规范，目的是为了减少冗余，提高数据存储和使用的效率</p>\n</blockquote>\n<ul>\n<li>第一范式：数据库表中的每个列都必须是原子性的，不可再分；同时每个表有一个主键.</li>\n<li>第二范式：表中非主键列必须完全依赖于主键，而不是部分依赖于主键. (如果有非主键列部分依赖于主键，需要将改列拆分并且放置于另外一张表中)</li>\n<li>第三范式：表中的非主键列之间不能存在传递依赖关系</li>\n</ul>\n<blockquote>\n<p>在实际的设计，经常也有反范式的现象，通过冗余的数据，来避免跨表的连接查询，以此来提高数据库的查询效率</p>\n</blockquote>\n<h2 id=\"数据库表的连接方式\"><a class=\"anchor\" href=\"#数据库表的连接方式\">#</a> 数据库表的连接方式</h2>\n<ul>\n<li>内连接</li>\n<li>左连接</li>\n<li>右连接</li>\n<li>全连接</li>\n<li>自连接</li>\n</ul>\n<h2 id=\"char与varchar\"><a class=\"anchor\" href=\"#char与varchar\">#</a> char 与 varchar</h2>\n<ul>\n<li>\n<p><code>char</code> ：定长字符类型。如果存储的字符串长度小于指定长度，会使用空格进行填充</p>\n</li>\n<li>\n<p><code>varchar</code> ：变长字符类型。它实际占用的存储空间为字符串的实际空间和用于存储字符串长度信息的空间</p>\n<blockquote>\n<ol>\n<li>存储效率： <code>char</code>  定长，无论字符串的实际长度多少，它占用的存储空间是固定，会浪费一定的空间.  <code>varchar</code>  是变长的，其占用的实际空间会随着字符串的大小而变动，存储效率较高</li>\n<li>查询效率： <code>char</code>  在搜索和排序方面的操作效率要高于 <code>varchar</code>  类型</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql锁的种类\"><a class=\"anchor\" href=\"#mysql锁的种类\">#</a> MySQL 锁的种类</h2>\n<ul>\n<li>\n<p>读写锁（锁的属性）</p>\n<blockquote>\n<ol>\n<li>共享锁 <code>Share Lock</code> ：读锁（ <code>S锁</code> ），当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁。为了支持高并发读取数据.</li>\n<li>排他锁 <code>Exclusive Lock</code> ：写锁（ <code>X锁</code> ），当一个事务为数据加上了写锁之后，其他请求不能再为这条数据加任何锁.</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>锁的粒度</p>\n<blockquote>\n<ol>\n<li>行锁：锁住表中的某一行或多行，粒度小，冲突小</li>\n<li>表锁：锁住整张表，粒度大，容易冲突</li>\n<li>记录数 <code>Record Lock</code> ：是行锁的一种，锁住表中的一条记录（命中的条件字段是一定是唯一索引）</li>\n<li>页锁：一种粒度介于行所和表锁之间的一种锁。每次锁定相邻的一组记录.</li>\n<li>间隙锁 <code>Gap Lock</code> ：属于行锁的一种</li>\n<li>临建锁 <code>Next-Key Lock</code></li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>意向锁</p>\n<blockquote>\n<p>如果当事务 A 加锁成功后设置一个状态告诉后面的人：已经有人对表里的行加了一个排他锁，不能再对整个表加共享锁或排他锁，那么后面需要对整个表加锁的人获取这个状态就知道是不是可以对表加锁，避免对这个索引表的每个节点扫描查看他们是否加锁，这个锁就是意向锁.</p>\n<ul>\n<li>意向共享锁：当一个事务试图对整个表加共享锁时，首先需要获取这个表的意向共享锁</li>\n<li>意向排他锁：当一个事务试图对整个表加排他锁时，首先需要获取这个表的意向排他锁</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql执行计划\"><a class=\"anchor\" href=\"#mysql执行计划\">#</a> MySQL 执行计划</h2>\n<blockquote>\n<p>执行计划： <code>sql</code>  的执行查询的顺序，以及如何使用索引</p>\n<p>在语句前面添加 <code>explain</code>  即可打印执行计划</p>\n</blockquote>\n<ul>\n<li>\n<p>执行计划参数</p>\n<blockquote>\n<ol>\n<li><code>id</code> ：</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"mysql中的死锁\"><a class=\"anchor\" href=\"#mysql中的死锁\">#</a> MySQL 中的死锁</h2>\n<blockquote>\n<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的的一种互相等待的现象.</p>\n<p>产看死锁的命令： <code>show engine innodb status</code> ；可以通过设置 <code>innodblockwait_timeout</code>  来设置曹超时时间或主动回滚死锁中的某个事务.</p>\n</blockquote>\n<h2 id=\"数据库的四大特性acid\"><a class=\"anchor\" href=\"#数据库的四大特性acid\">#</a> 数据库的四大特性 ACID</h2>\n<ul>\n<li>\n<p><code>原子性Atomicity</code> ：当前事务的操作要么执行成功，要么执行失败</p>\n<blockquote>\n<p>由 <code>undo log</code>  日志保证，记录了需要回滚的日子信息，事务回滚时撤销已经执行成功的 <code>sql</code>  语句</p>\n</blockquote>\n</li>\n<li>\n<p><code>一致性Consistency</code></p>\n<blockquote>\n<p>由其他三大特性共同来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>隔离性Isolation</code> ：在事务并发执行时，他们内部的操作不能互相干扰</p>\n<blockquote>\n<p>由 <code>MVCC</code>  来保证</p>\n</blockquote>\n</li>\n<li>\n<p><code>持久性Durability</code></p>\n<blockquote>\n<p>由内存 <code>redo log</code>  来保证， <code>mysql</code>  修改数据同时在内存和 <code>redo log</code>  记录这次操作，宕机的时候可以从 <code>redo log</code>  恢复</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"事务隔离级别\"><a class=\"anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h2>\n<blockquote>\n<p><code>InnoDB</code>  中 隔离性是由 MySQL 的各种锁机制以及 <code>MVCC</code>  来实现的</p>\n</blockquote>\n<ul>\n<li>读未提交 <code>read_uncommitted(RU)</code> ：有脏读问题</li>\n<li>读已提交 <code>read_committed(RC)</code> ：有不可重复读的问题</li>\n<li>可重复读 <code>repeatable-read(RR)</code> ：会有幻读的问题</li>\n<li>串行化 <code>serializable</code></li>\n</ul>\n<h2 id=\"数据库并发事务会带来哪些问题\"><a class=\"anchor\" href=\"#数据库并发事务会带来哪些问题\">#</a> 数据库并发事务会带来哪些问题</h2>\n<ul>\n<li>脏读</li>\n<li>不可重复读</li>\n<li>幻读</li>\n<li>丢失修改</li>\n</ul>\n<h2 id=\"mvcc\"><a class=\"anchor\" href=\"#mvcc\">#</a> MVCC</h2>\n<blockquote>\n<p>多版本并发控制：读取数据时通过一种类似于快照的方式将数据保存下来，这样读锁和写锁就不冲突了；不同的事务会看到特定版本的数据（版本链）</p>\n</blockquote>\n<ul>\n<li>\n<p><code>MVCC</code>  只在读已提交和可重复读两个隔离级别下工作. ( <code>read_uncommited</code>  总是读取最新的数据； <code>serializable</code>  会对所以的读操作加锁)</p>\n<blockquote>\n<p>聚簇索引中有两个隐藏的列</p>\n<ol>\n<li><code>trx_id</code> ：存储每次对这条索引记录进行修改的 <code>事务ID</code>  (事务 ID 根据时间顺序依次递增)</li>\n<li><code>roll_pointer</code> ：上一版本的记录地址.（每次对聚簇索引记录有修改操作时，都会把老版本写入 <code>undo</code>  日志中，而这个修改后的新记录的 <code>roll_pointer</code>  则会指向日志中旧版本）</li>\n</ol>\n<p><code>ReadView</code>  是快照读（普通的 <code>select</code>  查询语句）执行时 <code>MVCC</code>  提取数据的依据</p>\n<ol>\n<li><code>m_ids</code> ：当前活跃的事务编号的集合（还未提交的事务集合）</li>\n<li><code>min_trx_id</code> ：最小活跃事务的编号</li>\n<li><code>max_trx_id</code> ：预分配事务的编号，当前最大事务 ID+1</li>\n<li><code>creator_trx_id</code> ： <code>ReadView</code>  创建者的事务编号</li>\n</ol>\n<p><code>当前读</code> ：指执行如下指令对数据进行读取</p>\n<ul>\n<li><code>Insert、Update、Delete、Select ... for Update、Select ... lock in share mode</code></li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%89%88%E6%9C%AC%E9%93%BE.png\" alt=\"\" title=\"版本链\" /></p>\n</li>\n<li>\n<p>读已提交隔离级别下 MVCC 的工作方式：在每一次执行快照读的时候生成 <code>ReadView</code></p>\n<blockquote>\n<p>1. 判断版本链的 <code>trx_id</code>  是否等于 <code>creator_trx_id</code> ，若等于说明对该条记录的更新就是当前事务，则可以访问</p>\n<p>2. 判断版本链的 <code>trx_id</code>  是否小于 <code>min_trx_id</code> ，若小于说明对该记录的处理已经提交，可访问</p>\n<p>3. 判断版本链的 <code>trx_id</code>  是否大于等于 <code>max_trx_id</code> ，如果成立说明对该条记录的操作是在生成 <code>ReadView</code>  之后，不可访问</p>\n<p>4. 判断版本链的 <code>trx_id</code>  是否在 <code>m_idx</code>  中，如果不存在，说明对该条记录的操作已提交，可以访问，若存在，则不可访问</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/ReadView.png\" alt=\"\" title=\"ReadView\" /></p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>可重复读级别下 MVCC 的工作方式：仅在第一次执行快照读的时候生成 <code>ReadView</code>  ，从而保证事务内对于一条记录的查询是一致的</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png\" alt=\"\" /></p>\n<blockquote>\n<p>多次连续的快照读， <code>ReadView</code>  会复用，没有幻读问题。但是两次连续的 <code>快照读</code> 之间存在 <code>当前读</code> 时， <code>ReadView</code>  会重新生成，导致产生幻读</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.png\" alt=\"\" /></p>\n</li>\n</ul>\n<h2 id=\"mysql主从同步原理\"><a class=\"anchor\" href=\"#mysql主从同步原理\">#</a> MySQL 主从同步原理</h2>\n<blockquote>\n<p><code>MySQL主从同步</code> 主要涉及到三个线程，主节点 master 上的 <code>binlog dump thread</code> ，从节点 slave 上的 <code>IO thread</code>  和 <code>sql thread</code> . 主节点的 <code>binlog</code>  维护的是主库记录的所以变更记录.</p>\n<ol>\n<li>主节点的 <code>log dump</code>  线程，当 <code>binlog</code>  有变动时， <code>log dump</code>  会读取 <code>binlog</code>  日志变动的内容并发送到从节点</li>\n<li>从节点的 <code>IO thread</code>  接收到 <code>binlog</code>  内容 ，并将其写入 <code>relay log</code>  文件中.</li>\n<li>从节点的 <code>sql thread</code>  读取 <code>realy log</code>  新增的内容并执行，最终保持主从数据库的一致性.</li>\n</ol>\n<p>注：主节点使用 <code>binlog</code>  文件和 <code>position</code>  偏移量来定位主动同步的位置（增量同步）</p>\n<p>由于 MySQL 的默认的主从同步方式是异步 的，主节点把日志发送给从节点后不关系从库是否已经处理，这样会产生一个问题：主节点挂了，从节点处理失败了，那么这时从节点升级为主节点后，就会有一部分日志丢失了，有一下解决方案：</p>\n<ul>\n<li>全同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，需要等待所以的从节点执行完成之后，在将结果返回给客户端. (影响效率)</li>\n<li>半同步复制：主节点写入 <code>binlog</code>  并将数据同步到从节点时，不需要等待所以的从节点执行完成，当收到至少一个从节点的同步完成就将结果返回给客户端.</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "面试题",
                "MySQL"
            ]
        }
    ]
}
<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>繁華落盡 似水流年 • Posts by &#34;c++11&#34; category</title>
    <link href="http://example.com" />
    <updated>2024-04-02T00:53:23.525Z</updated>
    <category term="mathematics" />
    <category term="语法" />
    <category term="C++" />
    <category term="VMware" />
    <category term="install" />
    <category term="数据库" />
    <category term="STL" />
    <category term="CNN" />
    <category term="Project" />
    <category term="面试题" />
    <category term="日常" />
    <category term="校招" />
    <category term="算法" />
    <category term="Leetcode双周赛" />
    <category term="Algorithm" />
    <category term="Leetcode周赛" />
    <category term="设计模式" />
    <category term="多线程" />
    <category term="池化技术" />
    <category term="MySQL" />
    <category term="操作系统" />
    <category term="计算机网络" />
    <category term="CMake" />
    <category term="线程池" />
    <category term="Go" />
    <category term="Redis" />
    <entry>
        <id>http://example.com/value/CPP/C++11</id>
        <title>操作系统面试题</title>
        <link rel="alternate" href="http://example.com/value/CPP/C++11"/>
        <content type="html">&lt;h1 id=&#34;c11&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c11&#34;&gt;#&lt;/a&gt;  &lt;code&gt;C++11&lt;/code&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C++11&lt;/strong&gt; is the second major version of C++ and the most important update since C&lt;ins&gt;98. A large number of changes were introduced to both standardize existing practices and improve the abstractions available to the C&lt;/ins&gt; programmers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原始字面量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#原始字面量&#34;&gt;#&lt;/a&gt; 原始字面量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;C++11&lt;/code&gt;  中定义原始字面量的方式： &lt;code&gt;R&amp;quot;×××(原始字面量)×××&amp;quot;&lt;/code&gt; ，其中 &lt;code&gt;()&lt;/code&gt;  两边的字符可以省略。原始字面量可以直接表示字符串的实际含义，而不需要额外的转义字符。以下三条语句是等效的：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;string path1 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;D:\\Desktop\\tmp.txt&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;string path2 &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token raw-string string&#34;&gt;R&#34;(D:\Desktop\tmp.txt)&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;指针空值类型nullptr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指针空值类型nullptr&#34;&gt;#&lt;/a&gt; 指针空值类型 &lt;code&gt;nullptr&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt;  是一个空指针类型，在 &lt;code&gt;C++&lt;/code&gt;  中其可以隐式的转化为任何其他类型的空指针类型.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;  在 &lt;code&gt;C++&lt;/code&gt;  中被定义为 0，这一点的设置主要是让目前的 C++ 兼容之前的 C 程序，0 可以隐式转化为其他类型的空指针类型。所以在 &lt;code&gt;C++&lt;/code&gt;  程序中如果想要表达的是空指针，建议使用 &lt;code&gt;nullptr&lt;/code&gt; ，如果使用 &lt;code&gt;NULL&lt;/code&gt;  则可能导致出乎意料的结果.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;常量表达式constexpr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常量表达式constexpr&#34;&gt;#&lt;/a&gt; 常量表达式 &lt;code&gt;constexpr&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;  在 &lt;code&gt;C++&lt;/code&gt;  中有两个语义，变量只读和修饰常量。当 &lt;code&gt;const&lt;/code&gt;  修饰常量时，其值在编译阶段就已经确定，而修饰变量时，则需要等到运行时才确定.  &lt;code&gt;C++&lt;/code&gt;  为了区别这两种语义引入常量表达式 &lt;code&gt;constexpr&lt;/code&gt; ，用于修饰常量，在编译阶段确定其值.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;  可以用于修饰函数（常量表达式函数），可以用于修饰普通函数 / 类成员函数、类的构造函数、模版函数。修饰函数时，需要满足如下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数必须有返回值，并且 &lt;code&gt;return&lt;/code&gt;  返回的表达式必须是常量表达式&lt;/li&gt;
&lt;li&gt;整个函数体中不能出现非常量表达式之外语句&lt;/li&gt;
&lt;li&gt;修饰构造函数时，成员必须初始化，且初始化需要使用初始化列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自动类型推导auto&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#自动类型推导auto&#34;&gt;#&lt;/a&gt; 自动类型推导 &lt;code&gt;auto&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;  可以自动推导变量类型；使用 &lt;code&gt;auto&lt;/code&gt;  声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译阶段将 &lt;code&gt;auto&lt;/code&gt;  占位符替换成其真正的类型.&lt;/li&gt;
&lt;li&gt;对于有 &lt;code&gt;const&lt;/code&gt;  和 &lt;code&gt;volatile&lt;/code&gt;  修饰的变量， &lt;code&gt;auto&lt;/code&gt;  只能推断底层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt; ，顶层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  会被忽略，需要自己添加&lt;/li&gt;
&lt;li&gt;不能在函数的参数中使用，不能用于定义数组，不能用于类的非静态成员的初始化（只能用于类的静态常量成员变量的初始化）&lt;/li&gt;
&lt;li&gt;不能用于模版参数的类型推导&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自动类型推导decltype&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#自动类型推导decltype&#34;&gt;#&lt;/a&gt; 自动类型推导 &lt;code&gt;decltype&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我们希望从表达式（函数返回值）中推断出想要定义的变量的类型，但是却不想用表达式的值去初始化变量，这种情况 &lt;code&gt;auto&lt;/code&gt;  显得无力了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;推断表达式类型作为变量的定义类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推断函数返回值（实际不会调用，仅推断），推导出的对象类型与函数返回值一致&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当函数返回的是一个纯右值，需要忽略掉前面的 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无论是底层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  还是顶层 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  都会被保留&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式是一个左值，或者被 &lt;code&gt;()&lt;/code&gt;  包围，使用 &lt;code&gt;decltype&lt;/code&gt;  推导出来是表达式类型的引用（如果有 &lt;code&gt;const&lt;/code&gt;  或 &lt;code&gt;volatile&lt;/code&gt;  则需要加上）&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; a &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; b &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;token comment&#34;&gt;//b 的类型为 int&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;a&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; c &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; a&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;//c 的类型为 int&amp;amp;，绑定 a 对象&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;返回值类型后置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#返回值类型后置&#34;&gt;#&lt;/a&gt; 返回值类型后置&lt;/h2&gt;
&lt;h2 id=&#34;final&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final&#34;&gt;#&lt;/a&gt;  &lt;code&gt;final&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当用于修饰类时，表示该类不能被继承， &lt;code&gt;final&lt;/code&gt;  卸载类名后面&lt;/li&gt;
&lt;li&gt;当修饰成员函数时，只能修饰虚函数，表示这个虚函数不能被重写， &lt;code&gt;final&lt;/code&gt;  写在函数后&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;override&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#override&#34;&gt;#&lt;/a&gt;  &lt;code&gt;override&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;明确表明派生类中的函数重写了基类的虚函数， &lt;code&gt;override&lt;/code&gt;  写在派生类函数（重写了基类虚函数）后面.&lt;/p&gt;
&lt;h2 id=&#34;函数模版默认模版参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数模版默认模版参数&#34;&gt;#&lt;/a&gt; 函数模版默认模版参数&lt;/h2&gt;
&lt;h2 id=&#34;参考博文&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考博文&#34;&gt;#&lt;/a&gt; 参考博文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdWJpbmd3ZW4uY24vY2F0ZWdvcmllcy9DLw==&#34;&gt;爱编程的大丙 (subingwen.cn)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwLzEx&#34;&gt;C++11 - cppreference.com&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="C++" />
        <updated>2024-04-02T00:53:23.525Z</updated>
    </entry>
</feed>

<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>繁華落盡 似水流年 • Posts by &#34;数据库&#34; category</title>
    <link href="http://example.com" />
    <updated>2024-03-13T06:46:17.113Z</updated>
    <category term="mathematics" />
    <category term="语法" />
    <category term="C++" />
    <category term="VMware" />
    <category term="项目构建工具" />
    <category term="install" />
    <category term="数据库" />
    <category term="STL" />
    <category term="CNN" />
    <category term="Project" />
    <category term="面试题" />
    <category term="日常" />
    <category term="校招" />
    <category term="算法" />
    <category term="Leetcode双周赛" />
    <category term="Algorithm" />
    <category term="Leetcode周赛" />
    <category term="设计模式" />
    <category term="多线程" />
    <entry>
        <id>http://example.com/value/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98</id>
        <title>MySQL面试题</title>
        <link rel="alternate" href="http://example.com/value/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98"/>
        <content type="html">&lt;h1 id=&#34;mysql面试题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql面试题&#34;&gt;#&lt;/a&gt; MySQL 面试题&lt;/h1&gt;
&lt;h2 id=&#34;关系型数据库和非关系型数据库&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关系型数据库和非关系型数据库&#34;&gt;#&lt;/a&gt; 关系型数据库和非关系型数据库&lt;/h2&gt;
&lt;h2 id=&#34;myisam和innodb的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#myisam和innodb的区别&#34;&gt;#&lt;/a&gt;  &lt;code&gt;MyISAM&lt;/code&gt;  和 &lt;code&gt;InnoDB&lt;/code&gt;  的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MyISAM&lt;/code&gt;  索引采用的是非聚簇索引，索引的数据域存储数据的指针，而 &lt;code&gt;InnoDB&lt;/code&gt;  主键采用的是聚簇索引，非主键采用非聚簇索引，索引的数据域存储主键的 id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyISAM&lt;/code&gt;  不支持事务，但是每次查询都是原子操作； &lt;code&gt;Innodb&lt;/code&gt;  支持 &lt;code&gt;ACID&lt;/code&gt;  的事务，支持事务的四种隔离级别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyISAM&lt;/code&gt;  存储表的总行数； &lt;code&gt;InnoDB&lt;/code&gt;  不存储表的总行数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyISAM&lt;/code&gt;  支持的是表级锁，不支持外检约束； &lt;code&gt;InnoDB&lt;/code&gt;  支持行级锁，支持外检约束&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;覆盖索引&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#覆盖索引&#34;&gt;#&lt;/a&gt; 覆盖索引&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;索引的值包含所需要查询的字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;innodb的索引与myisam的所索引的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb的索引与myisam的所索引的区别&#34;&gt;#&lt;/a&gt;  &lt;code&gt;InnoDB&lt;/code&gt;  的索引与 &lt;code&gt;MyISAM&lt;/code&gt;  的所索引的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MyISAM&lt;/code&gt;  索引文件和数据文件是分离的，使用 B + 树来实现，主键索引和辅助索引实现基本一致（非主键不保证唯一）；叶子节点仅保存数据和数据的地址（非聚簇索引）.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InnoDB&lt;/code&gt;  索引分两种，聚簇索引和非聚簇索引，聚簇索引的叶子节点同 时也会存储数据。非聚簇索引的索引数据域保存主键的 id&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么使用索引&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为什么使用索引&#34;&gt;#&lt;/a&gt; 为什么使用索引&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;索引是数据库中用于加速数据访问的一种数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在关系型数据库中，通常使用 &lt;code&gt;B-Tree&lt;/code&gt;  或哈希表等索引结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引可以提高查询效率，建立索引的原则如下.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;区分度高的列作为索引可以加快查询速度&lt;/li&gt;
&lt;li&gt;经常出现在 &lt;code&gt;where&lt;/code&gt;  中的列&lt;/li&gt;
&lt;li&gt;表记录较少索引效果不好，没有必要建立索引&lt;/li&gt;
&lt;li&gt;定义有外键的数据列一定要建立索引&lt;/li&gt;
&lt;li&gt;更新频繁的数据列不适合建立索引&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引会降低插入、删除、更新表的速度，因为在执行这些操作时，还需要操作索引文件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引需要占用物理空间，除了索引表需要占用空间之外，每个索引也需要占用额外的存储空间。同时如果非聚餐索引很多，一旦聚簇索引改变，那么非聚簇索引也需要跟着改变，代价比较大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MySQL 中使用较多的是 &lt;code&gt;Hash索引&lt;/code&gt; 和 &lt;code&gt;B+树索引&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于哈希索引来说，底层的数据结构就是哈希表，因此对于绝大多数需求为单挑记录的查询的时候，可以选择哈希索引，查询性能高，其余的绝大多数场景使用 B + 树所以&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;聚簇索引和非聚簇索引的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#聚簇索引和非聚簇索引的区别&#34;&gt;#&lt;/a&gt; 聚簇索引和非聚簇索引的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚簇索引：主键索引&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;将数据存储在索引树的叶子节点上，可以减少一次查询（查询索引树的同时就能获得数据）&lt;/li&gt;
&lt;li&gt;当需要对数据进行修改或删除时，需要更新索引树，增加系统开销（聚簇索引保证顺序，当中间有数据需要插入时，可能引起分页）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非聚簇索引：二级索引 / 辅助索引&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;不将数据存储在索引树中，而是存储在数据页中；查询数据时需要两次查询，一次用于查询索引树，获取数据页的地址，在通过数据页的地址来查询数据（如果索引覆盖的话实际上不用回表）&lt;/li&gt;
&lt;li&gt;当需要对数据进行修改或删除时，不需要更新索引树，减少了系统开销&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;唯一索引与普通索引&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#唯一索引与普通索引&#34;&gt;#&lt;/a&gt; 唯一索引与普通索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区别：唯一索引的索引值必须唯一，但允许有空值（即可以是单列唯一索引也可以是联合唯一索引）；普通索引索引值不一定唯一，且允许有空值.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一索引可以保证数据的唯一性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;联合索引-组合索引-复合索引&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#联合索引-组合索引-复合索引&#34;&gt;#&lt;/a&gt; 联合索引、组合索引、复合索引&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;组合索引、联合索引、复合索引指代都是一个意思，一个索引包含多个列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;最左前缀匹配&lt;/code&gt; ：组合索引的第一个字段必须出现在查询语句中，还不能跳跃，只有这样才能让组合索引生效&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;figcaption data-lang=&#34;SQL&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 假设给 username，age 创建了组合索引&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 组合索引生效&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; username &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;xujiahao&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; age &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; username &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;xujiahao&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; age &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;24&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; username &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;xujiahao&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;token comment&#34;&gt;// 特殊情况&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 组合索引失效&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; age &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;where&lt;/span&gt; city &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;shenzhen&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;and&lt;/span&gt; age &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;索引失效的情况&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#索引失效的情况&#34;&gt;#&lt;/a&gt; 索引失效的情况&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;like&lt;/code&gt;  查询并且左边带 &lt;code&gt;%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;隐式类型转换。索引字段是 &lt;code&gt;int&lt;/code&gt; ，而使用字符串类型去查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;where&lt;/code&gt;  条件里面对索引使用运算或者函数&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;or&lt;/code&gt;  且存在非索引列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;where&lt;/code&gt;  条件中对两列作比较&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;in&lt;/code&gt; （和数据量有关系）&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;order by&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is null&lt;/code&gt; 、 &lt;code&gt;is not null&lt;/code&gt; 、 &lt;code&gt;≠&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;innodb为什么使用自增id作为主键&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb为什么使用自增id作为主键&#34;&gt;#&lt;/a&gt;  &lt;code&gt;InnoDB&lt;/code&gt;  为什么使用自增 &lt;code&gt;id&lt;/code&gt;  作为主键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用自增 &lt;code&gt;id&lt;/code&gt;  作为主键，那么在建立索引时，每次插入新的记录，记录会顺序添加到当前索引的后续位置，直到一页满为至才会开辟一个新的页&lt;/li&gt;
&lt;li&gt;如果使用非自增主键，由于每次插入的主键值比较随机，每次新纪录可能需要插入到现在索引的中间位置，会操作频繁的移动（内部单链表）和分页&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;b树与b树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#b树与b树&#34;&gt;#&lt;/a&gt; B 树与 B + 树&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;查询一个数据时，在数据页内往往使用二分查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;B 树：一种平衡的多叉搜索树&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每个节点包含多个关键字和对应的指针，即 B 数的每个节点都会存储数据&lt;/li&gt;
&lt;li&gt;B 树的叶子节点之间是指针相连的，不支持顺序访问&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B + 树：一种平衡的多叉搜索树&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;所以的关键字都存储在叶子节点上，非叶子节点不存储数据，只存储索引和指向孩子节点的指针&lt;/li&gt;
&lt;li&gt;叶子节点通过指针连接起来，形成一个有序的链表，支持顺序访问和范围查找（MySQL 底层实际是一个双向链表）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 选择 B + 树作为索引结构的原因&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;范围查询和顺序访问的性能更高：B + 树的叶子节点通过指针连接成一个双向链表，可以很好的支持数据库的范围查询，同时在连续的数据查询中，B + 树可以利用磁盘的预读特性，提高数据顺序访问性能，嫌少磁盘 I/O&lt;/li&gt;
&lt;li&gt;更少的磁盘 I/O：B + 树的非叶子节点只存储索引和指向孩子的节点指针，不存储数据，相比于 B 树，每个节点可以存储更多的关键字，减少了磁盘 I/O 次数（节点可以存储更多的关键字，可以使得 B + 树高更矮)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库三大范式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库三大范式&#34;&gt;#&lt;/a&gt; 数据库三大范式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库设计表结构时所遵循的规范，目的是为了减少冗余，提高数据存储和使用的效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一范式：数据库表中的每个列都必须是原子性的，不可再分；同时每个表有一个主键.&lt;/li&gt;
&lt;li&gt;第二范式：表中非主键列必须完全依赖于主键，而不是部分依赖于主键. (如果有非主键列部分依赖于主键，需要将改列拆分并且放置于另外一张表中)&lt;/li&gt;
&lt;li&gt;第三范式：表中的非主键列之间不能存在传递依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在实际的设计，经常也有反范式的现象，通过冗余的数据，来避免跨表的连接查询，以此来提高数据库的查询效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数据库表的连接方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库表的连接方式&#34;&gt;#&lt;/a&gt; 数据库表的连接方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内连接&lt;/li&gt;
&lt;li&gt;左连接&lt;/li&gt;
&lt;li&gt;右连接&lt;/li&gt;
&lt;li&gt;全连接&lt;/li&gt;
&lt;li&gt;自连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;char与varchar&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#char与varchar&#34;&gt;#&lt;/a&gt; char 与 varchar&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt; ：定长字符类型。如果存储的字符串长度小于指定长度，会使用空格进行填充&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;varchar&lt;/code&gt; ：变长字符类型。它实际占用的存储空间为字符串的实际空间和用于存储字符串长度信息的空间&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;存储效率： &lt;code&gt;char&lt;/code&gt;  定长，无论字符串的实际长度多少，它占用的存储空间是固定，会浪费一定的空间.  &lt;code&gt;varchar&lt;/code&gt;  是变长的，其占用的实际空间会随着字符串的大小而变动，存储效率较高&lt;/li&gt;
&lt;li&gt;查询效率： &lt;code&gt;char&lt;/code&gt;  在搜索和排序方面的操作效率要高于 &lt;code&gt;varchar&lt;/code&gt;  类型&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql锁的种类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql锁的种类&#34;&gt;#&lt;/a&gt; MySQL 锁的种类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读写锁（锁的属性）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;共享锁 &lt;code&gt;Share Lock&lt;/code&gt; ：读锁（ &lt;code&gt;S锁&lt;/code&gt; ），当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁。为了支持高并发读取数据.&lt;/li&gt;
&lt;li&gt;排他锁 &lt;code&gt;Exclusive Lock&lt;/code&gt; ：写锁（ &lt;code&gt;X锁&lt;/code&gt; ），当一个事务为数据加上了写锁之后，其他请求不能再为这条数据加任何锁.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁的粒度&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;行锁：锁住表中的某一行或多行，粒度小，冲突小&lt;/li&gt;
&lt;li&gt;表锁：锁住整张表，粒度大，容易冲突&lt;/li&gt;
&lt;li&gt;记录数 &lt;code&gt;Record Lock&lt;/code&gt; ：是行锁的一种，锁住表中的一条记录（命中的条件字段是一定是唯一索引）&lt;/li&gt;
&lt;li&gt;页锁：一种粒度介于行所和表锁之间的一种锁。每次锁定相邻的一组记录.&lt;/li&gt;
&lt;li&gt;间隙锁 &lt;code&gt;Gap Lock&lt;/code&gt; ：属于行锁的一种&lt;/li&gt;
&lt;li&gt;临建锁 &lt;code&gt;Next-Key Lock&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意向锁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果当事务 A 加锁成功后设置一个状态告诉后面的人：已经有人对表里的行加了一个排他锁，不能再对整个表加共享锁或排他锁，那么后面需要对整个表加锁的人获取这个状态就知道是不是可以对表加锁，避免对这个索引表的每个节点扫描查看他们是否加锁，这个锁就是意向锁.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意向共享锁：当一个事务试图对整个表加共享锁时，首先需要获取这个表的意向共享锁&lt;/li&gt;
&lt;li&gt;意向排他锁：当一个事务试图对整个表加排他锁时，首先需要获取这个表的意向排他锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql执行计划&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql执行计划&#34;&gt;#&lt;/a&gt; MySQL 执行计划&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;执行计划： &lt;code&gt;sql&lt;/code&gt;  的执行查询的顺序，以及如何使用索引&lt;/p&gt;
&lt;p&gt;在语句前面添加 &lt;code&gt;explain&lt;/code&gt;  即可打印执行计划&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行计划参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; ：&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql中的死锁&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql中的死锁&#34;&gt;#&lt;/a&gt; MySQL 中的死锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的的一种互相等待的现象.&lt;/p&gt;
&lt;p&gt;产看死锁的命令： &lt;code&gt;show engine innodb status&lt;/code&gt; ；可以通过设置 &lt;code&gt;innodblockwait_timeout&lt;/code&gt;  来设置曹超时时间或主动回滚死锁中的某个事务.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数据库的四大特性acid&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的四大特性acid&#34;&gt;#&lt;/a&gt; 数据库的四大特性 ACID&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;原子性Atomicity&lt;/code&gt; ：当前事务的操作要么执行成功，要么执行失败&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由 &lt;code&gt;undo log&lt;/code&gt;  日志保证，记录了需要回滚的日子信息，事务回滚时撤销已经执行成功的 &lt;code&gt;sql&lt;/code&gt;  语句&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;一致性Consistency&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由其他三大特性共同来保证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;隔离性Isolation&lt;/code&gt; ：在事务并发执行时，他们内部的操作不能互相干扰&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由 &lt;code&gt;MVCC&lt;/code&gt;  来保证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;持久性Durability&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由内存 &lt;code&gt;redo log&lt;/code&gt;  来保证， &lt;code&gt;mysql&lt;/code&gt;  修改数据同时在内存和 &lt;code&gt;redo log&lt;/code&gt;  记录这次操作，宕机的时候可以从 &lt;code&gt;redo log&lt;/code&gt;  恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事务隔离级别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#事务隔离级别&#34;&gt;#&lt;/a&gt; 事务隔离级别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;  中 隔离性是由 MySQL 的各种锁机制以及 &lt;code&gt;MVCC&lt;/code&gt;  来实现的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 &lt;code&gt;read_uncommitted(RU)&lt;/code&gt; ：有脏读问题&lt;/li&gt;
&lt;li&gt;读已提交 &lt;code&gt;read_committed(RC)&lt;/code&gt; ：有不可重复读的问题&lt;/li&gt;
&lt;li&gt;可重复读 &lt;code&gt;repeatable-read(RR)&lt;/code&gt; ：会有幻读的问题&lt;/li&gt;
&lt;li&gt;串行化 &lt;code&gt;serializable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库并发事务会带来哪些问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库并发事务会带来哪些问题&#34;&gt;#&lt;/a&gt; 数据库并发事务会带来哪些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;脏读&lt;/li&gt;
&lt;li&gt;不可重复读&lt;/li&gt;
&lt;li&gt;幻读&lt;/li&gt;
&lt;li&gt;丢失修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mvcc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt; MVCC&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;多版本并发控制：读取数据时通过一种类似于快照的方式将数据保存下来，这样读锁和写锁就不冲突了；不同的事务会看到特定版本的数据（版本链）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MVCC&lt;/code&gt;  只在读已提交和可重复读两个隔离级别下工作. ( &lt;code&gt;read_uncommited&lt;/code&gt;  总是读取最新的数据； &lt;code&gt;serializable&lt;/code&gt;  会对所以的读操作加锁)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;聚簇索引中有两个隐藏的列&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;trx_id&lt;/code&gt; ：存储每次对这条索引记录进行修改的 &lt;code&gt;事务ID&lt;/code&gt;  (事务 ID 根据时间顺序依次递增)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;roll_pointer&lt;/code&gt; ：上一版本的记录地址.（每次对聚簇索引记录有修改操作时，都会把老版本写入 &lt;code&gt;undo&lt;/code&gt;  日志中，而这个修改后的新记录的 &lt;code&gt;roll_pointer&lt;/code&gt;  则会指向日志中旧版本）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;ReadView&lt;/code&gt;  是快照读（普通的 &lt;code&gt;select&lt;/code&gt;  查询语句）执行时 &lt;code&gt;MVCC&lt;/code&gt;  提取数据的依据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;m_ids&lt;/code&gt; ：当前活跃的事务编号的集合（还未提交的事务集合）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min_trx_id&lt;/code&gt; ：最小活跃事务的编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_trx_id&lt;/code&gt; ：预分配事务的编号，当前最大事务 ID+1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;creator_trx_id&lt;/code&gt; ： &lt;code&gt;ReadView&lt;/code&gt;  创建者的事务编号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;当前读&lt;/code&gt; ：指执行如下指令对数据进行读取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Insert、Update、Delete、Select ... for Update、Select ... lock in share mode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E7%89%88%E6%9C%AC%E9%93%BE.png&#34; alt=&#34;&#34; title=&#34;版本链&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读已提交隔离级别下 MVCC 的工作方式：在每一次执行快照读的时候生成 &lt;code&gt;ReadView&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 判断版本链的 &lt;code&gt;trx_id&lt;/code&gt;  是否等于 &lt;code&gt;creator_trx_id&lt;/code&gt; ，若等于说明对该条记录的更新就是当前事务，则可以访问&lt;/p&gt;
&lt;p&gt;2. 判断版本链的 &lt;code&gt;trx_id&lt;/code&gt;  是否小于 &lt;code&gt;min_trx_id&lt;/code&gt; ，若小于说明对该记录的处理已经提交，可访问&lt;/p&gt;
&lt;p&gt;3. 判断版本链的 &lt;code&gt;trx_id&lt;/code&gt;  是否大于等于 &lt;code&gt;max_trx_id&lt;/code&gt; ，如果成立说明对该条记录的操作是在生成 &lt;code&gt;ReadView&lt;/code&gt;  之后，不可访问&lt;/p&gt;
&lt;p&gt;4. 判断版本链的 &lt;code&gt;trx_id&lt;/code&gt;  是否在 &lt;code&gt;m_idx&lt;/code&gt;  中，如果不存在，说明对该条记录的操作已提交，可以访问，若存在，则不可访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/ReadView.png&#34; alt=&#34;&#34; title=&#34;ReadView&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4MVCC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读级别下 MVCC 的工作方式：仅在第一次执行快照读的时候生成 &lt;code&gt;ReadView&lt;/code&gt;  ，从而保证事务内对于一条记录的查询是一致的&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多次连续的快照读， &lt;code&gt;ReadView&lt;/code&gt;  会复用，没有幻读问题。但是两次连续的 &lt;code&gt;快照读&lt;/code&gt; 之间存在 &lt;code&gt;当前读&lt;/code&gt; 时， &lt;code&gt;ReadView&lt;/code&gt;  会重新生成，导致产生幻读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBMVCC%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql主从同步原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql主从同步原理&#34;&gt;#&lt;/a&gt; MySQL 主从同步原理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;MySQL主从同步&lt;/code&gt; 主要涉及到三个线程，主节点 master 上的 &lt;code&gt;binlog dump thread&lt;/code&gt; ，从节点 slave 上的 &lt;code&gt;IO thread&lt;/code&gt;  和 &lt;code&gt;sql thread&lt;/code&gt; . 主节点的 &lt;code&gt;binlog&lt;/code&gt;  维护的是主库记录的所以变更记录.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主节点的 &lt;code&gt;log dump&lt;/code&gt;  线程，当 &lt;code&gt;binlog&lt;/code&gt;  有变动时， &lt;code&gt;log dump&lt;/code&gt;  会读取 &lt;code&gt;binlog&lt;/code&gt;  日志变动的内容并发送到从节点&lt;/li&gt;
&lt;li&gt;从节点的 &lt;code&gt;IO thread&lt;/code&gt;  接收到 &lt;code&gt;binlog&lt;/code&gt;  内容 ，并将其写入 &lt;code&gt;relay log&lt;/code&gt;  文件中.&lt;/li&gt;
&lt;li&gt;从节点的 &lt;code&gt;sql thread&lt;/code&gt;  读取 &lt;code&gt;realy log&lt;/code&gt;  新增的内容并执行，最终保持主从数据库的一致性.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：主节点使用 &lt;code&gt;binlog&lt;/code&gt;  文件和 &lt;code&gt;position&lt;/code&gt;  偏移量来定位主动同步的位置（增量同步）&lt;/p&gt;
&lt;p&gt;由于 MySQL 的默认的主从同步方式是异步 的，主节点把日志发送给从节点后不关系从库是否已经处理，这样会产生一个问题：主节点挂了，从节点处理失败了，那么这时从节点升级为主节点后，就会有一部分日志丢失了，有一下解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全同步复制：主节点写入 &lt;code&gt;binlog&lt;/code&gt;  并将数据同步到从节点时，需要等待所以的从节点执行完成之后，在将结果返回给客户端. (影响效率)&lt;/li&gt;
&lt;li&gt;半同步复制：主节点写入 &lt;code&gt;binlog&lt;/code&gt;  并将数据同步到从节点时，不需要等待所以的从节点执行完成，当收到至少一个从节点的同步完成就将结果返回给客户端.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
        <category term="面试题" />
        <updated>2024-03-13T06:46:17.113Z</updated>
    </entry>
    <entry>
        <id>http://example.com/value/redis</id>
        <title>redis</title>
        <link rel="alternate" href="http://example.com/value/redis"/>
        <content type="html">&lt;h1 id=&#34;redis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt; Redis&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;redis（Remote dictionary server）是一个开源的基于内存的数据存储系统。它可以用于数据库缓存，消息队列等各种场景，是一种 NoSQL 数据库。早期的互联网公司系统大多是通过 Mysql 这种传统的关系型数据库对外提供服务。随着互联网的快速发展，应用系统的访问量原来远大，数据库的性能瓶颈越来越明显，主要是由于磁盘 IO 所导致的，磁盘 IO 的读写速度与内存相比是非常慢的，如果能把数据存储在内存中，则可以大大数据存储的性能。于是便出现了 redis，这种基于内存的数据存储系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;redis 支持多种数据结构，包括五种基本数据类型和五种高级数据类型。&lt;br /&gt;
五种基本数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串 String&lt;/li&gt;
&lt;li&gt;列表 List&lt;/li&gt;
&lt;li&gt;集合 Set&lt;/li&gt;
&lt;li&gt;有序集合 SortedSet&lt;/li&gt;
&lt;li&gt;哈希 Hash&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;五种高级数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;地理空间&lt;/li&gt;
&lt;li&gt;HyperLogLog&lt;/li&gt;
&lt;li&gt;位图 Bitmap&lt;/li&gt;
&lt;li&gt;位域 Bitfiled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;redis 的使用方式有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLI，命令行界面（Command Line Interface）；通过 Redis-CLI 命令行工具来使用&lt;/li&gt;
&lt;li&gt;API，应用程序接口（Application Programing Interface）；&lt;/li&gt;
&lt;li&gt;GUI，图形用户界面（Graphical User Interface）；通过图形化工具来使用 Redis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;redis 中的数据是以键值对的形式存储的&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# 字符串 String&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;set&lt;/span&gt; key value      		&lt;span class=&#34;token comment&#34;&gt;# 设置键值对（key, value）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;get key 	        	&lt;span class=&#34;token comment&#34;&gt;# 获取 key 对应的 value 值，大小写敏感&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# redis 内默认都是使用字符串来存储数据的，而且是二进制安全的（redis-cli --raw）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;del key			   	    &lt;span class=&#34;token comment&#34;&gt;# 删除 key 对应的（key，value）键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;exists key		    	&lt;span class=&#34;token comment&#34;&gt;# 判断是否存在 key 对应的键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;keys pattern			&lt;span class=&#34;token comment&#34;&gt;# 查看与 pattern 匹配的键，* 表示所以 key&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;flushall		    	&lt;span class=&#34;token comment&#34;&gt;# 清空数据库，即删除所以的键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;clear&lt;/span&gt;			    	&lt;span class=&#34;token comment&#34;&gt;# 清空屏幕&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# 设置一个带过期时间的键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;TTL key			   		&lt;span class=&#34;token comment&#34;&gt;# 查看 key 的过期时间，返回 - 1 表示没有设置过期时间，返回 - 2 表示设置了过期时间同时该键值对已经过期，返回正数表示过期时间&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;expire key seconds		&lt;span class=&#34;token comment&#34;&gt;# 为 key 对应的键值对设置过期时间 seconds&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;setex key seconds value  &lt;span class=&#34;token comment&#34;&gt;# 设置（key，value）键值对的过期时间&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;setnx key value			&lt;span class=&#34;token comment&#34;&gt;# 当键 key 不存在时，插入（key, value）, 否则不插入&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;list 也叫列表，一般用来存储和操作一组有顺序的数据，和数组的概念比较类似&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# lish 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;lpush key value 		&lt;span class=&#34;token comment&#34;&gt;# 往列表 key 的左边插入一个 value 的元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;rpush key value			&lt;span class=&#34;token comment&#34;&gt;# 往列表 key 的右边插入一个 value 的元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;lpush key value1 value2 value3 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.  &lt;span class=&#34;token comment&#34;&gt;# 一次性添加多个元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;lrange key start stop	&lt;span class=&#34;token comment&#34;&gt;# 获取列表 key 左边 [start, stop] 的所以元素索引 0 开始&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;lpop key 			   &lt;span class=&#34;token comment&#34;&gt;# 删除列表 key 最左边的元素，返回删除的元素值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;lpop key count		   &lt;span class=&#34;token comment&#34;&gt;# 删除列表 key 最左边的 count 个元素（版本 &gt;=6.0.2），返回删除的元素值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;llen key			   &lt;span class=&#34;token comment&#34;&gt;# 获取列表 key 的长度&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ltrim key start stop    &lt;span class=&#34;token comment&#34;&gt;# 保留列表 key 从左开始 [stop, stop] 内的元素，范围之外的元素均会被删除（索引均是从 0 开始）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;set 是一种无序集合，它和列表的区别是列表中的元素都是可以重复的，而 set 中的元素不可以重复，而且 set 中的元素并不像列表中的元素那样都是具有顺序的。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# set 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;sadd key member			&lt;span class=&#34;token comment&#34;&gt;# 往无序集合 key 内添加 member 元素，若无序集合 key 内已经存在该 member，则添加失败&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;sadd key memeber1 member2 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.   &lt;span class=&#34;token comment&#34;&gt;# 往无序集合 key 内添加多个元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;smembers key			&lt;span class=&#34;token comment&#34;&gt;# 查看无序集合 key 的元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;sismember key member	 &lt;span class=&#34;token comment&#34;&gt;# 查看 member 是否是无序集合 key 内的元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;srem key memeber		&lt;span class=&#34;token comment&#34;&gt;# 删除无序集合 key 内的 member&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;srem key member1 member2 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.   &lt;span class=&#34;token comment&#34;&gt;# 删除无序集合 key 内的多个元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# 集合运算操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;sortedset 是一种有序集合，又名 zset，其和集合的区别在于有序集合的每个元素都会关联一个浮点类型的分数，然后按照这个分数来对集合中的元素进行从小到大的顺序排序，有序集合的成员是唯一的，但是分数是可以重复的。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# sortedset 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zadd key score1 member1 score2 member2 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.  &lt;span class=&#34;token comment&#34;&gt;# 往有序集合 key 中插入 member1,member2，其对应的分数为 score1, scores2&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zrange key start stop				&lt;span class=&#34;token comment&#34;&gt;# 查看有序集合 key 内 [start, stop] 内的元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zrange key start stop withscores     &lt;span class=&#34;token comment&#34;&gt;# 查看有序集合 key 内 [start, stop] 内的元素和其对应的分数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zscore key member				    &lt;span class=&#34;token comment&#34;&gt;# 获取有序集合 key 内 member 的分数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zrank key member				    &lt;span class=&#34;token comment&#34;&gt;# 获取有序集合 key 内 member 的排名（从小到大排序，分数越小排名越高）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;zrevrank key member				    &lt;span class=&#34;token comment&#34;&gt;# 获取有序集合 key 内 member 的排名（从大到小排序，分数越高排名越高）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;哈希 hash 是一个字符类型的字段和值的映射表，简单来说就是一个键值对的集合，特别适合用来存储对象。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# hash 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hset key field value		&lt;span class=&#34;token comment&#34;&gt;# 往哈希 key 内插入 (field, value) 键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hget key field			    &lt;span class=&#34;token comment&#34;&gt;# 获取哈希 key 内 field 对应的值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hgetall key				   &lt;span class=&#34;token comment&#34;&gt;# 获取哈希 key 内所以的键值对&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hdel key field  		   &lt;span class=&#34;token comment&#34;&gt;# 删除哈希 key 内 field 对应的键值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hexists key field 		    &lt;span class=&#34;token comment&#34;&gt;# 查看哈希 key 内是否存在 field 对应的键值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hkeys key				   &lt;span class=&#34;token comment&#34;&gt;# 获取哈希 key 内所以的键&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hlen key				   &lt;span class=&#34;token comment&#34;&gt;# 获取哈希 key 内所以键值对的数目&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;redis 提供了发布订阅的功能，可以通过 &lt;code&gt;publish&lt;/code&gt;  将消息发布到指定的频道，然后通过 &lt;code&gt;subscribe&lt;/code&gt;  命令来订阅这个频道。但是这样的简单的发布和订阅功能具有一些局限性，比如消息无法持久化，无法记录历史消息等等&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;subscribe channel			&lt;span class=&#34;token comment&#34;&gt;# 订阅频道 channel&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;publish channel message		&lt;span class=&#34;token comment&#34;&gt;# 像频道 channe 发布消息 message&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;消息队列 Stream，是 redis5.0 引入的一个新的数据结构，他是一个轻量级的消息队列，可以实现消息的持久化、记录历史消息等。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# Stream 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xadd key &lt;span class=&#34;token function&#34;&gt;id&lt;/span&gt; field value				&lt;span class=&#34;token comment&#34;&gt;# 往消息队列 key 内添加一条消息（消息的 id，消息的内容 (field, value)）， id 为 *，则 redis 则会自动生成，id 为 (时间戳 - 序号) 的形式；redis 自动生成的 id 保证其为递增，如果手动指定 id 需要自己保证插入消息 id 为递增的&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xlen key						   &lt;span class=&#34;token comment&#34;&gt;# 获取消息队列 key 的消息数目&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xrange key - + 					    &lt;span class=&#34;token comment&#34;&gt;# 获取消息队列 key 内的所以消息信息&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xrange key start end				&lt;span class=&#34;token comment&#34;&gt;# 获取消息队列 key 内 id 在 [start, end] 范围内的消息信息&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xdel key &lt;span class=&#34;token function&#34;&gt;id&lt;/span&gt;						    &lt;span class=&#34;token comment&#34;&gt;# 删除消息队列 key 内 ID 为 id 的消息&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xtrim key maxlen count				&lt;span class=&#34;token comment&#34;&gt;# 删除消息队列 kye 内的消息，直到消息队列长度为 count（可能比 count 多）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;xread &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;count count_num&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;block milliseconds&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; streams key &lt;span class=&#34;token function&#34;&gt;id&lt;/span&gt;   &lt;span class=&#34;token comment&#34;&gt;# 读取消息队列可以内 count_num 条消息，ID&gt;id，若没有则堵塞 milliseconds 毫秒，如果 id 为 $, 表示获取当前时刻之后的 count_num 条消息&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;地理空间 &lt;code&gt;Genspatial&lt;/code&gt;  是 redis3.2 版本的新特性，它提供了一种存储空间位置信息的数据结构，同时支持对地理位置进行的各种计算操作。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# 地理空间 genspatial&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;geoadd key longitude latitude member 	&lt;span class=&#34;token comment&#34;&gt;# 往空间地理位置 key 内添加名称为 member 的地理位置信息（经度，纬度）&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;geopos key member					  &lt;span class=&#34;token comment&#34;&gt;# 获取空间地理位置 key 内 member 的位置信息 &lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;geodist key member1 member2 &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;km&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;			   &lt;span class=&#34;token comment&#34;&gt;# 获取空间地理位置 key 内 member1 与 member2 之间的距离，默认为 m&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;  是一种用来做基数统计的算法，它并不是 redis 特有的算法。基数：集合中元素数目（去重之后）。它的原理是使用随机算法来计算，通过牺牲一定的精度来换取更小的内存消耗。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# hyperloglog 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pfadd key element1 element2 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.        &lt;span class=&#34;token comment&#34;&gt;# 往基数容器 key 内添加 element1，element2... 元素&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pfcount key							&lt;span class=&#34;token comment&#34;&gt;# 获取基数容器 key 内元素的数目&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;pfmerge destkey sourcekey1 sourcekey2  &lt;span class=&#34;token comment&#34;&gt;# 合并多个基数容器，最终存放于 destkey 基数容器内&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;位图是字符串类型的扩展，可以使用一个 string 类型来模拟一个 Bit 数组，数组的下标就是偏移量，值只有 0 和 1，也支持一些位运算，比如与、或、非和异或等等。他们的运用非常广泛，比如用来记录用户的签到情况，在线状态，点赞状态。&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;# bitmap 操作&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;setbit key offset value				&lt;span class=&#34;token comment&#34;&gt;# 设置位图 key 偏移量为 offset 的位置为 value (0/1)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;getbit key offset				    &lt;span class=&#34;token comment&#34;&gt;# 获取位图 key 偏移量为 offset 的位置的值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;set&lt;/span&gt; key value					   &lt;span class=&#34;token comment&#34;&gt;# 位图本质是 string，可以通过设置 string 的方法来设置位图，value 转化为二进制即为对应位图的值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;bitcount key 					   &lt;span class=&#34;token comment&#34;&gt;# 获取位图 key 内 1 的个数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;bitpos key bit					   &lt;span class=&#34;token comment&#34;&gt;# 获取位图 key 内第一次出现 bit 的下标 (0 开始)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;位域能够将很多小的整数存储到一个较大的位图中，这样就可以更加高效的使用内存&lt;/p&gt;
&lt;p&gt;redis 支持事务，也就是可以在一次请求中执行多个命令；redis 中的事务主要通过 &lt;code&gt;multi&lt;/code&gt;  和 &lt;code&gt;exec&lt;/code&gt;  这两个命令来实现的； &lt;code&gt;multi&lt;/code&gt;  命令用来开启一个事务，事务开启之后所以的命令都会被放进一个队列中，最后通过一个 &lt;code&gt;exec&lt;/code&gt;  命令来执行所以的命令。redis 中是事务和 mysql 或者 oracle 中的数据库的事务不太一样，在关系型数据库中，事务一般是一个原子操作，要么全部执行成功，要么全部执行失败；而在 redis 中，事务并不能保证所以命令都会执行成功，它的执行结果取决于事务中的命令，但是 redis 可以保证如下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发送 &lt;code&gt;exec&lt;/code&gt;  命令之前，所以的命令都会被放入到一个队列中缓存起来，不会立即执行&lt;/li&gt;
&lt;li&gt;在收到 &lt;code&gt;exec&lt;/code&gt;  命令之后事务开始执行，事务中的任何一个命令执行失败其他命令依然会被执行（不会以为其中的命令执行失败而影响后续的命令的执行）&lt;/li&gt;
&lt;li&gt;在事务的执行过程中，其他客户端提交的命令请求并不会被插入到执行命令序列中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持久化的 redis 一个非常重要的功能，因为 redis 是一个基于内存的数据库，如果没有持久化的话，那么一旦服务器重启或者断点，那么之前的所以数据都会丢失，这对于一个数据库来说是非常致命的。redis 中的持久化主要由两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 方式（redis databse），在指定的时间间隔内，将内存中的数据快照写入磁盘，他是某一时间点上数据的完整副本&lt;/li&gt;
&lt;li&gt;AOF 方式（Append-Only File），追加文件，每次在执行写命令的时候，不仅将命令写入到内存中，还会将命令写入到一个追加的文件中，这个文件就是 AOF 文件，它会以日志的形式来记录每一个写操作，当 redis 重启的时候，就会通过重新执行 AOF 文件中的命令来在内存中重建整个数据库的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主从复制是指将一台服务器（主节点）的数据复制到其他 redis 服务器中（从节点）。一个主节点可以有多个从节点，而每个从节点只可以有一个主节点，数据的复制是单向的，只能由主节点到从节点；一般来说主节点负责写操作，从节点负责读操作，主节点会将自己的数据变化通过异步的方式发送给从节点，从节点接收到主节点的数据之后，更新自己的数据，这样就达到的了数据一致性的目的。&lt;/p&gt;
&lt;p&gt;面试问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  是多线程还是单线程？
&lt;ul&gt;
&lt;li&gt;在早期的 &lt;code&gt;redis&lt;/code&gt;  版本中， &lt;code&gt;redis&lt;/code&gt;  的网络 &lt;code&gt;I/O&lt;/code&gt;  和键值对的读写操作是由单线程来处理的；在回来的版本，在网络 &lt;code&gt;I/O&lt;/code&gt;  模块使用了多线程，但是对于键值对的操作仍然使用的是单线程（故无论是早期版本的 &lt;code&gt;redis&lt;/code&gt;  还是当前版本的 &lt;code&gt;redis&lt;/code&gt;  均是并发安全的）；当然对于一个 &lt;code&gt;redis&lt;/code&gt;  的数据持久化，集群同步等问题都是使用多线程来完成，需要额外的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  为什么速度快？
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  的一种基于内存的数据存储系统，相比于涉及到磁盘操作的 &lt;code&gt;mysql&lt;/code&gt;  等其他数据库而言，对于内存的操作会更快。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  对于键值对的读写操作是单线程的，不需要额外线程切换的开销&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  底层通过哈希对数据进行映射，可以实现线性的存储与访问；同时在访问冲突大时，使用渐进式的 &lt;code&gt;rehash&lt;/code&gt;  机制来进行重新映射&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt;  内部维护了一个缓存时间戳，避免的频繁的系统调用而导致的额外开销。（ &lt;code&gt;redis&lt;/code&gt;  获取系统的毫秒时间戳并不会频繁的调用 &lt;code&gt;time()&lt;/code&gt;  这样的系统调用， &lt;code&gt;redis&lt;/code&gt;  会对时间戳进行缓存，同时通过额外的线程来对时间戳进行更新）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="数据库" />
        <updated>2023-10-03T08:18:31.023Z</updated>
    </entry>
</feed>

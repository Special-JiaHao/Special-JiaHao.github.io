{
    "version": "https://jsonfeed.org/version/1",
    "title": "繁華落盡 似水流年 • All posts by \"数据库\" category",
    "description": "编程日记 & 随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/value/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "url": "http://example.com/value/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98",
            "title": "MySQL面试题",
            "date_published": "2024-03-13T06:46:17.113Z",
            "content_html": "<h1 id=\"mysql面试题\"><a class=\"anchor\" href=\"#mysql面试题\">#</a> MySQL 面试题</h1>\n<h2 id=\"关系型数据库和非关系型数据库\"><a class=\"anchor\" href=\"#关系型数据库和非关系型数据库\">#</a> 关系型数据库和非关系型数据库</h2>\n<h2 id=\"为什么使用索引\"><a class=\"anchor\" href=\"#为什么使用索引\">#</a> 为什么使用索引</h2>\n<blockquote>\n<p>索引是数据库中用于加速数据访问的一种数据结构</p>\n</blockquote>\n<ul>\n<li>在关系型数据库中，通常使用 <code>B-Tree</code>  或哈希表等索引结构</li>\n<li>在建立索引时，选择区分度也高的列作为索引可以提高查询效率。但是索引也需要考虑其存储空间和更新代价的问题，太多的索引会导致资源浪费</li>\n</ul>\n<h2 id=\"b树与b树\"><a class=\"anchor\" href=\"#b树与b树\">#</a> B 树与 B + 树</h2>\n<ul>\n<li>\n<p>B 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>每个节点包含多个关键字和对应的指针，即 B 数的每个节点都会存储数据</li>\n<li>B 树的叶子节点之间是指针相连的，不支持顺序访问</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>B + 树：一种平衡的多叉搜索树</p>\n<blockquote>\n<ol>\n<li>所以的关键字都存储在叶子节点上，非叶子节点不存储数据，只存储索引和指向孩子节点的指针</li>\n<li>叶子节点通过指针连接起来，形成一个有序的链表，支持顺序访问和范围查找（MySQL 底层实际是一个双向链表）</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>MySQL 选择 B + 树作为索引结构的原因</p>\n<blockquote>\n<ol>\n<li>范围查询和顺序访问的性能更高：B + 树的叶子节点通过指针连接成一个双向链表，可以很好的支持数据库的范围查询，同时在连续的数据查询中，B + 树可以利用磁盘的预读特性，提高数据顺序访问性能，嫌少磁盘 I/O</li>\n<li>更少的磁盘 I/O：B + 树的非叶子节点只存储索引和指向孩子的节点指针，不存储数据，相比于 B 树，每个节点可以存储更多的关键字，减少了磁盘 I/O 次数（节点可以存储更多的关键字，可以使得 B + 树高更矮)</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"数据库三大范式\"><a class=\"anchor\" href=\"#数据库三大范式\">#</a> 数据库三大范式</h2>\n<blockquote>\n<p>数据库设计表结构时所遵循的规范，目的是为了减少冗余，提高数据存储和使用的效率</p>\n</blockquote>\n<ul>\n<li>第一范式：数据库表中的每个列都必须是原子性的，不可再分；同时每个表有一个主键.</li>\n<li>第二范式：表中非主键列必须完全依赖于主键，而不是部分依赖于主键. (如果有非主键列部分依赖于主键，需要将改列拆分并且放置于另外一张表中)</li>\n<li>第三范式：表中的非主键列之间不能存在传递依赖关系</li>\n</ul>\n<blockquote>\n<p>在实际的设计，经常也有反范式的现象，通过冗余的数据，来避免跨表的连接查询，以此来提高数据库的查询效率</p>\n</blockquote>\n<h2 id=\"数据库表的连接方式\"><a class=\"anchor\" href=\"#数据库表的连接方式\">#</a> 数据库表的连接方式</h2>\n<ul>\n<li>内连接</li>\n<li>左连接</li>\n<li>右连接</li>\n<li>全连接</li>\n<li>自连接</li>\n</ul>\n<h2 id=\"char与varchar\"><a class=\"anchor\" href=\"#char与varchar\">#</a> char 与 varchar</h2>\n<ul>\n<li>\n<p><code>char</code> ：定长字符类型。如果存储的字符串长度小于指定长度，会使用空格进行填充</p>\n</li>\n<li>\n<p><code>varchar</code> ：变长字符类型。它实际占用的存储空间为字符串的实际空间和用于存储字符串长度信息的空间</p>\n<blockquote>\n<ol>\n<li>存储效率： <code>char</code>  定长，无论字符串的实际长度多少，它占用的存储空间是固定，会浪费一定的空间.  <code>varchar</code>  是变长的，其占用的实际空间会随着字符串的大小而变动，存储效率较高</li>\n<li>查询效率： <code>char</code>  在搜索和排序方面的操作效率要高于 <code>varchar</code>  类型</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"聚簇索引和非聚簇索引的区别\"><a class=\"anchor\" href=\"#聚簇索引和非聚簇索引的区别\">#</a> 聚簇索引和非聚簇索引的区别</h2>\n<ul>\n<li>\n<p>聚簇索引：主键索引</p>\n<blockquote>\n<ol>\n<li>将数据存储在索引树的叶子节点上，可以减少一次查询（查询索引树的同时就能获得数据）</li>\n<li>当需要对数据进行修改或删除时，需要更新索引树，增加系统开销</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>非聚簇索引：二级索引 / 辅助索引</p>\n<blockquote>\n<ol>\n<li></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"数据库的四大特性acid\"><a class=\"anchor\" href=\"#数据库的四大特性acid\">#</a> 数据库的四大特性 ACID</h2>\n<ul>\n<li><code>原子性Atomicity</code> ：当前事务的操作要么执行成功，要么执行失败</li>\n<li><code>一致性Consistency</code></li>\n<li><code>隔离性Isolation</code> ：在事务并发执行时，他们内部的操作不能互相干扰</li>\n<li><code>持久性Durability</code></li>\n</ul>\n<h2 id=\"事务隔离级别\"><a class=\"anchor\" href=\"#事务隔离级别\">#</a> 事务隔离级别</h2>\n<blockquote>\n<p><code>InnoDB</code>  中 隔离性是由 MySQL 的各种锁机制以及 <code>MVCC</code>  来实现的</p>\n</blockquote>\n<ul>\n<li>读未提交 <code>read_uncommitted</code> ：有脏读问题</li>\n<li>读已提交 <code>read_committed</code> ：有不可重复读的问题</li>\n<li>可重复度 <code>repeatable-read</code> ：</li>\n<li>串行化 <code>serializable</code></li>\n</ul>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "http://example.com/value/redis",
            "url": "http://example.com/value/redis",
            "title": "redis",
            "date_published": "2023-10-03T08:18:31.023Z",
            "content_html": "<h1 id=\"redis\"><a class=\"anchor\" href=\"#redis\">#</a> Redis</h1>\n<blockquote>\n<p>redis（Remote dictionary server）是一个开源的基于内存的数据存储系统。它可以用于数据库缓存，消息队列等各种场景，是一种 NoSQL 数据库。早期的互联网公司系统大多是通过 Mysql 这种传统的关系型数据库对外提供服务。随着互联网的快速发展，应用系统的访问量原来远大，数据库的性能瓶颈越来越明显，主要是由于磁盘 IO 所导致的，磁盘 IO 的读写速度与内存相比是非常慢的，如果能把数据存储在内存中，则可以大大数据存储的性能。于是便出现了 redis，这种基于内存的数据存储系统。</p>\n</blockquote>\n<p>redis 支持多种数据结构，包括五种基本数据类型和五种高级数据类型。<br />\n五种基本数据类型：</p>\n<ul>\n<li>字符串 String</li>\n<li>列表 List</li>\n<li>集合 Set</li>\n<li>有序集合 SortedSet</li>\n<li>哈希 Hash</li>\n</ul>\n<p>五种高级数据类型：</p>\n<ul>\n<li>消息队列</li>\n<li>地理空间</li>\n<li>HyperLogLog</li>\n<li>位图 Bitmap</li>\n<li>位域 Bitfiled</li>\n</ul>\n<p>redis 的使用方式有三种：</p>\n<ul>\n<li>CLI，命令行界面（Command Line Interface）；通过 Redis-CLI 命令行工具来使用</li>\n<li>API，应用程序接口（Application Programing Interface）；</li>\n<li>GUI，图形用户界面（Graphical User Interface）；通过图形化工具来使用 Redis</li>\n</ul>\n<p>redis 中的数据是以键值对的形式存储的</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 字符串 String</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">set</span> key value      \t\t<span class=\"token comment\"># 设置键值对（key, value）</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>get key \t        \t<span class=\"token comment\"># 获取 key 对应的 value 值，大小写敏感</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># redis 内默认都是使用字符串来存储数据的，而且是二进制安全的（redis-cli --raw）</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>del key\t\t\t   \t    <span class=\"token comment\"># 删除 key 对应的（key，value）键值对</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>exists key\t\t    \t<span class=\"token comment\"># 判断是否存在 key 对应的键值对</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>keys pattern\t\t\t<span class=\"token comment\"># 查看与 pattern 匹配的键，* 表示所以 key</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>flushall\t\t    \t<span class=\"token comment\"># 清空数据库，即删除所以的键值对</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">clear</span>\t\t\t    \t<span class=\"token comment\"># 清空屏幕</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 设置一个带过期时间的键值对</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>TTL key\t\t\t   \t\t<span class=\"token comment\"># 查看 key 的过期时间，返回 - 1 表示没有设置过期时间，返回 - 2 表示设置了过期时间同时该键值对已经过期，返回正数表示过期时间</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>expire key seconds\t\t<span class=\"token comment\"># 为 key 对应的键值对设置过期时间 seconds</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>setex key seconds value  <span class=\"token comment\"># 设置（key，value）键值对的过期时间</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>setnx key value\t\t\t<span class=\"token comment\"># 当键 key 不存在时，插入（key, value）, 否则不插入</span></pre></td></tr></table></figure><p>list 也叫列表，一般用来存储和操作一组有顺序的数据，和数组的概念比较类似</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># lish 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lpush key value \t\t<span class=\"token comment\"># 往列表 key 的左边插入一个 value 的元素</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>rpush key value\t\t\t<span class=\"token comment\"># 往列表 key 的右边插入一个 value 的元素</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lpush key value1 value2 value3 <span class=\"token punctuation\">..</span>.  <span class=\"token comment\"># 一次性添加多个元素</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>lrange key start stop\t<span class=\"token comment\"># 获取列表 key 左边 [start, stop] 的所以元素索引 0 开始</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lpop key \t\t\t   <span class=\"token comment\"># 删除列表 key 最左边的元素，返回删除的元素值</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>lpop key count\t\t   <span class=\"token comment\"># 删除列表 key 最左边的 count 个元素（版本 >=6.0.2），返回删除的元素值</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>llen key\t\t\t   <span class=\"token comment\"># 获取列表 key 的长度</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>ltrim key start stop    <span class=\"token comment\"># 保留列表 key 从左开始 [stop, stop] 内的元素，范围之外的元素均会被删除（索引均是从 0 开始）</span></pre></td></tr></table></figure><p>set 是一种无序集合，它和列表的区别是列表中的元素都是可以重复的，而 set 中的元素不可以重复，而且 set 中的元素并不像列表中的元素那样都是具有顺序的。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># set 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>sadd key member\t\t\t<span class=\"token comment\"># 往无序集合 key 内添加 member 元素，若无序集合 key 内已经存在该 member，则添加失败</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>sadd key memeber1 member2 <span class=\"token punctuation\">..</span>.   <span class=\"token comment\"># 往无序集合 key 内添加多个元素</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>smembers key\t\t\t<span class=\"token comment\"># 查看无序集合 key 的元素</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>sismember key member\t <span class=\"token comment\"># 查看 member 是否是无序集合 key 内的元素</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>srem key memeber\t\t<span class=\"token comment\"># 删除无序集合 key 内的 member</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>srem key member1 member2 <span class=\"token punctuation\">..</span>.   <span class=\"token comment\"># 删除无序集合 key 内的多个元素</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 集合运算操作</span></pre></td></tr></table></figure><p>sortedset 是一种有序集合，又名 zset，其和集合的区别在于有序集合的每个元素都会关联一个浮点类型的分数，然后按照这个分数来对集合中的元素进行从小到大的顺序排序，有序集合的成员是唯一的，但是分数是可以重复的。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># sortedset 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>zadd key score1 member1 score2 member2 <span class=\"token punctuation\">..</span>.  <span class=\"token comment\"># 往有序集合 key 中插入 member1,member2，其对应的分数为 score1, scores2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>zrange key start stop\t\t\t\t<span class=\"token comment\"># 查看有序集合 key 内 [start, stop] 内的元素</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>zrange key start stop withscores     <span class=\"token comment\"># 查看有序集合 key 内 [start, stop] 内的元素和其对应的分数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>zscore key member\t\t\t\t    <span class=\"token comment\"># 获取有序集合 key 内 member 的分数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>zrank key member\t\t\t\t    <span class=\"token comment\"># 获取有序集合 key 内 member 的排名（从小到大排序，分数越小排名越高）</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>zrevrank key member\t\t\t\t    <span class=\"token comment\"># 获取有序集合 key 内 member 的排名（从大到小排序，分数越高排名越高）</span></pre></td></tr></table></figure><p>哈希 hash 是一个字符类型的字段和值的映射表，简单来说就是一个键值对的集合，特别适合用来存储对象。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># hash 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hset key field value\t\t<span class=\"token comment\"># 往哈希 key 内插入 (field, value) 键值对</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>hget key field\t\t\t    <span class=\"token comment\"># 获取哈希 key 内 field 对应的值</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>hgetall key\t\t\t\t   <span class=\"token comment\"># 获取哈希 key 内所以的键值对</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>hdel key field  \t\t   <span class=\"token comment\"># 删除哈希 key 内 field 对应的键值</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>hexists key field \t\t    <span class=\"token comment\"># 查看哈希 key 内是否存在 field 对应的键值</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>hkeys key\t\t\t\t   <span class=\"token comment\"># 获取哈希 key 内所以的键</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>hlen key\t\t\t\t   <span class=\"token comment\"># 获取哈希 key 内所以键值对的数目</span></pre></td></tr></table></figure><p>redis 提供了发布订阅的功能，可以通过 <code>publish</code>  将消息发布到指定的频道，然后通过 <code>subscribe</code>  命令来订阅这个频道。但是这样的简单的发布和订阅功能具有一些局限性，比如消息无法持久化，无法记录历史消息等等</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>subscribe channel\t\t\t<span class=\"token comment\"># 订阅频道 channel</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>publish channel message\t\t<span class=\"token comment\"># 像频道 channe 发布消息 message</span></pre></td></tr></table></figure><p>消息队列 Stream，是 redis5.0 引入的一个新的数据结构，他是一个轻量级的消息队列，可以实现消息的持久化、记录历史消息等。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># Stream 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>xadd key <span class=\"token function\">id</span> field value\t\t\t\t<span class=\"token comment\"># 往消息队列 key 内添加一条消息（消息的 id，消息的内容 (field, value)）， id 为 *，则 redis 则会自动生成，id 为 (时间戳 - 序号) 的形式；redis 自动生成的 id 保证其为递增，如果手动指定 id 需要自己保证插入消息 id 为递增的</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>xlen key\t\t\t\t\t\t   <span class=\"token comment\"># 获取消息队列 key 的消息数目</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>xrange key - + \t\t\t\t\t    <span class=\"token comment\"># 获取消息队列 key 内的所以消息信息</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>xrange key start end\t\t\t\t<span class=\"token comment\"># 获取消息队列 key 内 id 在 [start, end] 范围内的消息信息</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>xdel key <span class=\"token function\">id</span>\t\t\t\t\t\t    <span class=\"token comment\"># 删除消息队列 key 内 ID 为 id 的消息</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>xtrim key maxlen count\t\t\t\t<span class=\"token comment\"># 删除消息队列 kye 内的消息，直到消息队列长度为 count（可能比 count 多）</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>xread <span class=\"token punctuation\">[</span>count count_num<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>block milliseconds<span class=\"token punctuation\">]</span> streams key <span class=\"token function\">id</span>   <span class=\"token comment\"># 读取消息队列可以内 count_num 条消息，ID>id，若没有则堵塞 milliseconds 毫秒，如果 id 为 $, 表示获取当前时刻之后的 count_num 条消息</span></pre></td></tr></table></figure><p>地理空间 <code>Genspatial</code>  是 redis3.2 版本的新特性，它提供了一种存储空间位置信息的数据结构，同时支持对地理位置进行的各种计算操作。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 地理空间 genspatial</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>geoadd key longitude latitude member \t<span class=\"token comment\"># 往空间地理位置 key 内添加名称为 member 的地理位置信息（经度，纬度）</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>geopos key member\t\t\t\t\t  <span class=\"token comment\"># 获取空间地理位置 key 内 member 的位置信息 </span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>geodist key member1 member2 <span class=\"token punctuation\">[</span>km<span class=\"token punctuation\">]</span>\t\t\t   <span class=\"token comment\"># 获取空间地理位置 key 内 member1 与 member2 之间的距离，默认为 m</span></pre></td></tr></table></figure><p><code>HyperLogLog</code>  是一种用来做基数统计的算法，它并不是 redis 特有的算法。基数：集合中元素数目（去重之后）。它的原理是使用随机算法来计算，通过牺牲一定的精度来换取更小的内存消耗。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># hyperloglog 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pfadd key element1 element2 <span class=\"token punctuation\">..</span>.        <span class=\"token comment\"># 往基数容器 key 内添加 element1，element2... 元素</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pfcount key\t\t\t\t\t\t\t<span class=\"token comment\"># 获取基数容器 key 内元素的数目</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>pfmerge destkey sourcekey1 sourcekey2  <span class=\"token comment\"># 合并多个基数容器，最终存放于 destkey 基数容器内</span></pre></td></tr></table></figure><p>位图是字符串类型的扩展，可以使用一个 string 类型来模拟一个 Bit 数组，数组的下标就是偏移量，值只有 0 和 1，也支持一些位运算，比如与、或、非和异或等等。他们的运用非常广泛，比如用来记录用户的签到情况，在线状态，点赞状态。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># bitmap 操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>setbit key offset value\t\t\t\t<span class=\"token comment\"># 设置位图 key 偏移量为 offset 的位置为 value (0/1)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>getbit key offset\t\t\t\t    <span class=\"token comment\"># 获取位图 key 偏移量为 offset 的位置的值</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">set</span> key value\t\t\t\t\t   <span class=\"token comment\"># 位图本质是 string，可以通过设置 string 的方法来设置位图，value 转化为二进制即为对应位图的值</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bitcount key \t\t\t\t\t   <span class=\"token comment\"># 获取位图 key 内 1 的个数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>bitpos key bit\t\t\t\t\t   <span class=\"token comment\"># 获取位图 key 内第一次出现 bit 的下标 (0 开始)</span></pre></td></tr></table></figure><p>位域能够将很多小的整数存储到一个较大的位图中，这样就可以更加高效的使用内存</p>\n<p>redis 支持事务，也就是可以在一次请求中执行多个命令；redis 中的事务主要通过 <code>multi</code>  和 <code>exec</code>  这两个命令来实现的； <code>multi</code>  命令用来开启一个事务，事务开启之后所以的命令都会被放进一个队列中，最后通过一个 <code>exec</code>  命令来执行所以的命令。redis 中是事务和 mysql 或者 oracle 中的数据库的事务不太一样，在关系型数据库中，事务一般是一个原子操作，要么全部执行成功，要么全部执行失败；而在 redis 中，事务并不能保证所以命令都会执行成功，它的执行结果取决于事务中的命令，但是 redis 可以保证如下三点：</p>\n<ul>\n<li>在发送 <code>exec</code>  命令之前，所以的命令都会被放入到一个队列中缓存起来，不会立即执行</li>\n<li>在收到 <code>exec</code>  命令之后事务开始执行，事务中的任何一个命令执行失败其他命令依然会被执行（不会以为其中的命令执行失败而影响后续的命令的执行）</li>\n<li>在事务的执行过程中，其他客户端提交的命令请求并不会被插入到执行命令序列中</li>\n</ul>\n<p>持久化的 redis 一个非常重要的功能，因为 redis 是一个基于内存的数据库，如果没有持久化的话，那么一旦服务器重启或者断点，那么之前的所以数据都会丢失，这对于一个数据库来说是非常致命的。redis 中的持久化主要由两种方式：</p>\n<ul>\n<li>RDB 方式（redis databse），在指定的时间间隔内，将内存中的数据快照写入磁盘，他是某一时间点上数据的完整副本</li>\n<li>AOF 方式（Append-Only File），追加文件，每次在执行写命令的时候，不仅将命令写入到内存中，还会将命令写入到一个追加的文件中，这个文件就是 AOF 文件，它会以日志的形式来记录每一个写操作，当 redis 重启的时候，就会通过重新执行 AOF 文件中的命令来在内存中重建整个数据库的内容</li>\n</ul>\n<p>主从复制是指将一台服务器（主节点）的数据复制到其他 redis 服务器中（从节点）。一个主节点可以有多个从节点，而每个从节点只可以有一个主节点，数据的复制是单向的，只能由主节点到从节点；一般来说主节点负责写操作，从节点负责读操作，主节点会将自己的数据变化通过异步的方式发送给从节点，从节点接收到主节点的数据之后，更新自己的数据，这样就达到的了数据一致性的目的。</p>\n<p>面试问题：</p>\n<ol>\n<li><code>redis</code>  是多线程还是单线程？\n<ul>\n<li>在早期的 <code>redis</code>  版本中， <code>redis</code>  的网络 <code>I/O</code>  和键值对的读写操作是由单线程来处理的；在回来的版本，在网络 <code>I/O</code>  模块使用了多线程，但是对于键值对的操作仍然使用的是单线程（故无论是早期版本的 <code>redis</code>  还是当前版本的 <code>redis</code>  均是并发安全的）；当然对于一个 <code>redis</code>  的数据持久化，集群同步等问题都是使用多线程来完成，需要额外的开销</li>\n</ul>\n</li>\n<li><code>redis</code>  为什么速度快？\n<ul>\n<li><code>redis</code>  的一种基于内存的数据存储系统，相比于涉及到磁盘操作的 <code>mysql</code>  等其他数据库而言，对于内存的操作会更快。</li>\n<li><code>redis</code>  对于键值对的读写操作是单线程的，不需要额外线程切换的开销</li>\n<li><code>redis</code>  底层通过哈希对数据进行映射，可以实现线性的存储与访问；同时在访问冲突大时，使用渐进式的 <code>rehash</code>  机制来进行重新映射</li>\n<li><code>redis</code>  内部维护了一个缓存时间戳，避免的频繁的系统调用而导致的额外开销。（ <code>redis</code>  获取系统的毫秒时间戳并不会频繁的调用 <code>time()</code>  这样的系统调用， <code>redis</code>  会对时间戳进行缓存，同时通过额外的线程来对时间戳进行更新）</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "数据库"
            ]
        }
    ]
}
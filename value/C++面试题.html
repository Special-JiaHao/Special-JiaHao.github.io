<!-- build time:Thu Mar 21 2024 15:10:35 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="繁華落盡 似水流年" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="繁華落盡 似水流年" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="繁華落盡 似水流年" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="面试题"><link rel="canonical" href="http://example.com/value/C++%E9%9D%A2%E8%AF%95%E9%A2%98.html"><title>C++面试题 - C++ | Value's Blog = 繁華落盡 似水流年 = 寄予厚望 还请善待</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++面试题</h1><div class="meta"><span class="item" title="Created: 2024-03-08 21:53:12"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-03-08T21:53:12+08:00">2024-03-08</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>14k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>12 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Value's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://raw.githubusercontent.com/Special-JiaHao/images/main/cpp-interview-questions.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CPP/" itemprop="item" rel="index" title="In C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://example.com/value/C++%E9%9D%A2%E8%AF%95%E9%A2%98"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Value"><meta itemprop="description" content="寄予厚望 还请善待, 编程日记 & 随笔"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="繁華落盡 似水流年"></span><div class="body md" itemprop="articleBody"><h1 id="c面试题"><a class="anchor" href="#c面试题">#</a> C++ 面试题</h1><h2 id="程序编译过程"><a class="anchor" href="#程序编译过程">#</a> 程序编译过程</h2><ul><li><p>预处理</p><ol><li>完成宏定义 <code>#define</code> 内容替换</li><li>处理所有的条件预编译指令，如 <code>#if #endif</code></li><li>把 <code>#include</code> 文件内容复制到 <code>.cpp</code> 文件中（递归执行）</li><li>删除所有注释</li></ol></li><li><p>编译：转化为汇编代码，主要工作是检查一些语法规则，代码优化（寻找合适的寻址方式，使用位运算来替代乘法运算，删除多余的指令）</p></li><li><p>汇编：将汇编代码转化为二进制格式的文件（机器码）</p></li><li><p>链接：将多个目标文件以及库文件链接成最终的可执行文件</p><ol><li><p>静态链接：在链接阶段将库文件的函数和数据合并到应用程序中，组成一个最终的可执行文件.</p><blockquote><ul><li><p>运行速度快：可执行程序中具备运行阶段所需要的所以东西</p></li><li><p>空间浪费：可执行程序中有所以目标文件的副本。当多个程序对同一个目标文件有依赖关系时，那么这个目标文件在内存中会有多个副本</p></li><li><p>当其中一个库文件需要修改，整个程序需要重新编译</p></li></ul></blockquote></li><li><p>动态链接：在程序运行阶段才把多个目标文件链接成一个完整的程序.</p><blockquote><ul><li><p>运行效率会有所损耗</p></li><li><p>节省空间：共享库</p></li><li><p>更新方便：只需要重新编译修改的目标文件</p></li></ul></blockquote></li></ol></li></ul><h2 id="cc内存空间"><a class="anchor" href="#cc内存空间">#</a> C/C++ 内存空间</h2><p><img data-src="https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4C.jpg" alt="" width="200px"><img data-src="https://raw.githubusercontent.com/Special-JiaHao/images/main/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt="" width="200px"></p><ul><li>栈：用于存储局部变量，由编译器自动管理分配与释放，效率很高，但是内存有限</li><li>堆：动态内存空间，由应用程序去控制。如若程序结束没有释放，则会由操作系统自动回收.</li><li>代码区：存放函数体二进制代码</li><li>全局 / 静态存储区：用于存储全局变量和静态变量。在以前 C 语言中，这部分分为初始化的 <code>.data</code> 和未初始化 <code>.bss</code> . 现在 C++ 中则没有这样的划分，区域内的变量会被默认初始化为 0.</li><li>常量存储区：用于存储常量，不允许修改</li></ul><h2 id="堆与栈"><a class="anchor" href="#堆与栈">#</a> 堆与栈</h2><ul><li>栈内存是由编译器自动管理的，堆可由程序员控制，对于开辟的内存需要主动释放，否则容易产生内存泄漏</li><li>栈的内存增长方向是向着地址空间减小的方向，堆内存的增长方向是朝着地址空间增大的方向.</li><li>栈分配的内存都是连续空间，同时是一个先进后出的数据结构，其不存在内存碎片的问题。堆所分配的内存空间不一定连续，会存在内存碎片的问题</li><li>栈的分配效率要高于堆的分配效率。操作系统内有专门的寄存器用于存储栈的地址和栈顶指针地址。堆的内存分配是调用 C/C++ 的库函数，分配空间时还需要按照不同的算法去搜索足够大的空间进行分配。同时由于内存碎片问题，操作系统会进行内存紧缩的操作，需要额外的系统开销.</li></ul><h2 id="函数调用的过程"><a class="anchor" href="#函数调用的过程">#</a> 函数调用的过程</h2><h2 id="static"><a class="anchor" href="#static">#</a> static</h2><ul><li>在函数中申明变量时，被 <code>static</code> 修饰的变量只会被初始化一次，改变了变量的存储位置（原来存储在栈区，现在存储在静态 / 全局存储区），延长了变量的生命周期</li><li>被 <code>static</code> 修饰的变量默认初始化为 0</li><li><code>static</code> 修饰全局变量<ol><li>全局变量：既可以在源文件中使用，也可以在其他文件中使用（使用 <code>extern</code> 修饰）</li><li>静态全局变量：只能在源文件中使用，使得全局变量的作用域变小</li></ol></li><li><code>static</code> 所修饰的成员变量为所以对象共享，不占用具体实例的空间.</li><li>静态成员变量必须在类外定义，定义时不加 <code>static</code> 关键字</li><li>静态成员函数没有隐藏的 <code>this</code> 指针，不能访问非静态成员</li><li>访问静态成员变量的方法：<ol><li>静态成员变量为 <code>public</code> （对象，类，匿名对象）</li><li>静态成员变量为 <code>private</code> （对象的静态成员函数，类的静态成员函数，匿名对象的静态成员函数）</li></ol></li></ul><h2 id="const"><a class="anchor" href="#const">#</a> const</h2><ul><li><code>const</code> 修饰变量时表示其为一个常量或想阻止一个变量被改变</li><li><code>const</code> 在类外定义变量时，必须初始化，并之后无法更改</li><li><code>const</code> 成员变量：不能在类外初始化，只能通过构造函数初始化列表进行初始化</li><li><code>const</code> 对象不能调用非 <code>const</code> 成员函数</li><li><code>const</code> 修饰的函数为常函数，不能改变类的成员变量</li></ul><h2 id="mutable"><a class="anchor" href="#mutable">#</a> mutable</h2><ul><li><code>mutable</code> 与 <code>const</code> 是相对的，表示一个变量的易变的；被 <code>mutable</code> 修饰是成员变量可以再 <code>const</code> 修饰的函数内被修改（也可以被常对象进行直接修改）</li></ul><h2 id="explicit"><a class="anchor" href="#explicit">#</a> explicit</h2><ul><li>用于修饰类的构造函数，被修饰的构造函数的类不能发生隐式的类型转化，只能以显示的类型转化</li></ul><h2 id="volatile"><a class="anchor" href="#volatile">#</a> volatile</h2><ul><li>用于修饰变量，表示其值随时可能发送变化，编译器不会对访问该变量的代码进行优化，可以保证访问变量的稳定（从内存中读取）</li><li><code>volatile</code> 指针</li><li>多线程下的 <code>volatile</code> ：当多个线程都需要用到某一个变量时，应该用 <code>volatile</code> ，防止编译器把变量从内存装入 CPU 寄存器中</li></ul><h2 id="c三大特性"><a class="anchor" href="#c三大特性">#</a> C++ 三大特性</h2><ul><li>封装、继承、多态（封装和继承可以实现 <code>代码的重用</code> ，多态可以实现 <code>接口的重用</code> ）<ol><li>封装：将数据和实现过程包裹起来，隐藏代码的实现细节，通过定义的接口来访问数据成员，使代码模块化. (直接体现面向对象，代码重用，权限控制)<ul><li><code>public</code> ：公有权限，类内可以访问，类外也可以访问</li><li><code>protected</code> ：保护权限，类内可以访问，类外不可以访问</li><li><code>private</code> ：私有权限，类内可以访问，类外不可以访问</li></ul></li><li>继承：无需重新编写代码而可以直接使用现有类的所以功能，同时可以对现有类进行功能上的扩展，是一个从一般到特殊的过程.<ul><li>权限继承：表示基类在子类中的最高权限（破坏继承： <code>friend</code> ， <code>using</code> ）</li><li>多继承</li></ul></li><li>多态：一个接口有多种形态；多态是在不同继承关系的类对象，可以通过父类指针去指向子类对象，通过父类指针调用同一函数，可以产生了不同的行为.（父类的指针可以具有多种形态，称之为多态）（用父类型别的指针指向其子类的实例，然后通过父类指针调用实际的子类的成员函数）<ul><li>虚函数（函数地址在运行阶段确定）（每个包含虚函数的类实例化出的对象除了成员变量之外，最前面会存储虚函数表指针；当发生继承时，派生类的虚表和父类一致，若子类中自身包含虚函数，则会添加到后面，若子类虚函数重写了父类的虚函数，则虚表中的地址也会发生响应的改变）</li><li>编译器在编译阶段会为类（含义虚函数的类）生成虚函数表</li><li>协变：基类和派生类虚函数的返回值不同（基类返回基类对象的指针或引用，派生类返回派生类对象的指针或引用）</li><li>虚析构函数：基类中析构函数前使用 <code>virtual</code> 修饰。当基类指针指向派生类对象时，使用基类指针去释放空间时，则会去先调用派生类的析构函数，再去调用基类的析构函数；若不加 <code>virtual</code> 则不会触发动态绑定（多态），只会调用基类的析构函数，导致内存泄漏. (虽然虚构函数名不一样，其实也是一种重写，系统内部对析构函数做了特殊处理，将析构函数名称都改成了 <code>destructor</code> )</li><li>虚函数地址在运行时绑定，使用了虚函数表的机制，所以在调用的时候会增加一次内存开销.</li></ul></li></ol></li></ul><h2 id="为什么c默认析构函数不是虚函数"><a class="anchor" href="#为什么c默认析构函数不是虚函数">#</a> 为什么 C++ 默认析构函数不是虚函数</h2><ul><li>虚函数需要虚函数表和虚函数表指针，会占用内存空间。如果一个类没有子类，那么就没有必要讲析构函数设置为虚函数</li></ul><h2 id="重载-重写-重定义"><a class="anchor" href="#重载-重写-重定义">#</a> 重载、重写、重定义</h2><ul><li>重载：多个同名函数，他们的参数个数或者参数类型不同；（编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就变成了不同的函数），也可以称之为静态多态，函数地址在编译器就已经确定了</li><li>重定义：继承中的同名隐藏，当派生类中有一个函数与基类的函数名相同，不管参数是否相同，只要该函数不为虚函数，发生了重定义.</li><li>重写：派生类中重写了基类的虚函数，其中函数名、参数列表和返回值都相同</li></ul><h2 id="final和override"><a class="anchor" href="#final和override">#</a> final 和 override</h2><ul><li><code>final</code> ：修饰虚函数，表示该虚函数不能再被重写</li><li><code>override</code> ：检查派生类虚函数是否重写了基类的某个虚函数，如果没有则编译器报错；</li></ul><h2 id="struct-与class"><a class="anchor" href="#struct-与class">#</a> struct 与 class</h2><ul><li>C++ 中的 <code>struct</code> 默认 <code>public</code> 共有权限， <code>class</code> 默认 <code>private</code> 私有权限</li><li>C 语言中的 <code>struct</code> 只是一个变量的集合体，只可以用于封装数据</li></ul><h2 id="new-和-malloc的区别"><a class="anchor" href="#new-和-malloc的区别">#</a> new 和 malloc 的区别</h2><p><code>new</code> 和 <code>malloc</code> 都是用于分配内存的，其中 <code>new</code> 是 C++ 中的操作符，可以被重载， <code>malloc</code> 是 C 语言中的库函数，不可以被重载</p><ol><li>参数不同；new 可以自动计算所分配的对象的内存大小，同时返回值为指向该对象的指针. malloc 则需要传入需要分配的内存的字节数，返回一个 <code>void *</code> 指针</li><li>new 分配失败会抛出异常 <code>bac_alloc</code> ，malloc 分配失败会返回 <code>NULL</code></li><li>new 分配的内存在 <code>free store</code> （自由存储区）上，malloc 分配的内存在堆上（其中自由存储区是 C++ 中的一个抽象的概念，new 的底层调用的逻辑是先调用 <code>operator new</code> 分配内存，由系统决定或者用户重载 <code>operator new</code> 决定，其次是调用对象的构造函数，初始化成员变量）</li><li><code>malloc</code> 分配的内存是虚拟内存，而 <code>new</code> 分配的内存是物理内存。因为 new 调用了对象的构造函数，对对象成员进行了初始化（发生了缺页中断，使得虚拟内存映射到了物理内存）</li></ol><h2 id="delete-与-free"><a class="anchor" href="#delete-与-free">#</a> delete 与 free</h2><p><code>delete</code> 和 <code>free</code> 都是用于释放内存的，其中 <code>delete</code> 是 C++ 中的操作符，可以被重载，free 是 C 语言中的库函数，不可以被重载</p><ol><li>参数不同；delete 需要给出释放的对象的类型指针，free 可以是 <code>void *</code> 类型的指针（delete 底层调用的逻辑是先调用对象的析构函数，再调用 <code>operator delete</code> 释放对象所占内存）（free 只需要提供 <code>void *</code> 就可以释放申请的所以内存： <code>malloc</code> 在分配内存时，不仅仅是分配了用户所需要的内存空间的大小，还会在该空间上部分配额外的一部分空间用于存储此次分配的内存的描述信息）</li></ol><blockquote><p>注意： <code>delete</code> 和 <code>free</code> 被调用后，指针也不会指向空，如果没有其他用途，需要把它设置为 <code>nullptr</code> ，否则会出现野指针.</p></blockquote><h2 id="free回收的内存是立即返回给操作系统吗"><a class="anchor" href="#free回收的内存是立即返回给操作系统吗">#</a> free 回收的内存是立即返回给操作系统吗？</h2><ul><li>不是的。被 <code>free</code> 回收的内存会被 <code>ptmalloc</code> 使用双链表保存起来，当用户下一次申请内存空间的时候，会尝试先从这些内存中寻找合适的返回.</li><li>可以避免频繁的系统调用，提高程序效率.</li><li><code>ptmalloc</code> 也会尝试对小块进行合并，避免过多的内存碎片</li></ul><blockquote><p><strong>C++11</strong> is the second major version of C++ and the most important update since C<ins>98. A large number of changes were introduced to both standardize existing practices and improve the abstractions available to the C</ins> programmers.</p></blockquote><h2 id="new与delete"><a class="anchor" href="#new与delete">#</a> new [] 与 delete []</h2><ul><li><code>new[]</code> 会先调用 <code>operateor new[]</code> 分配内存，然后再分配的内存的前几个字节写入数组的大小，然后进行 n 次构造函数</li></ul><h2 id="malloc与free实现原理"><a class="anchor" href="#malloc与free实现原理">#</a> malloc 与 free 实现原理</h2><h2 id="c中的几种new"><a class="anchor" href="#c中的几种new">#</a> C++ 中的几种 new</h2><ul><li><code>new</code> ： <code>plain new</code> ，分配内存失败会抛出异常</li><li><code>nothrow new</code> ：分配内存失败不抛出异常，而是返回 <code>nullptr</code></li><li><code>placement new</code> ：不会分配内存，在已有的内存空间上重新构造对象</li></ul><h2 id="c强制类型转换"><a class="anchor" href="#c强制类型转换">#</a> C++ 强制类型转换</h2><ul><li><p><code>static_cast&lt;T&gt;()</code> ：不进行类型检查，不安全</p><ol><li><p>用于层次结构中基类与派生类间指针的转换</p><p>a. 上行转换（派生类指针转化为基类指针），安全</p><p>b. 下行转化（基类指针转化为派生类指针），不安全</p></li><li><p>基本数据类型的转化</p></li><li><p>将空指针转化为目标类型的指针</p></li></ol></li><li><p><code>dynamic_cast</code> ：运行时处理（动态类型转换），只能针对指针或引用，专门用于派生类与基类之间的转换，会进行类型的检查，较安全（转换失败，指针为 <code>nullptr</code> ，和多态一起使用）</p></li><li><p><code>reinterpret_cast</code> ：转化过程仅仅是简单的比特位拷贝，不安全</p></li><li><p><code>const_cast&lt;T&gt;()</code> ：用于修改变量的 <code>const</code> 或 <code>volatile</code> 属性，变量类型与转换后的类型一致（只能修改底层 <code>const</code> ）</p></li></ul><h2 id="指针与引用"><a class="anchor" href="#指针与引用">#</a> 指针与引用</h2><ul><li>存储的是一个地址；而引用只是变量的别名.</li><li>指针可不进行初始化，也可以指向空，并且指向可以改变；引用必须初始化，且只可绑定一个变量。这也导致了在使用指针时，往往需要判空操作，而引用是一种安全的指针，一定不为空（引用的底层是通过指针来实现）.</li><li><code>sizeof</code> 指针得到的是指针的大小， <code>sizeof</code> 引用得到的是引用绑定对象的大小</li><li>指针可以是多级的，引用只有一级</li></ul><h2 id="常引用"><a class="anchor" href="#常引用">#</a> 常引用</h2><ul><li><p>保护传递给函数的数据在函数内不背改变. <code>const 类型&amp; 引用名</code></p></li><li><p>在 C++ 中，临时对象都是 <code>const</code> 类型的，const 类型的对象转换为非 const 类型是非法的.</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>string <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">bar</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	    <span class="token comment">//  非法</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">var</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 非法</span></pre></td></tr></table></figure></li></ul><h2 id="将引用作为函数返回值"><a class="anchor" href="#将引用作为函数返回值">#</a> 将引用作为函数返回值</h2><ul><li>好处：在内存中不会产生返回值副本</li></ul><blockquote><p>注意：不能返回局部变量的引用，不能返回函数内部 new 的内存空间的引用（无法释放）</p></blockquote><h2 id="野指针"><a class="anchor" href="#野指针">#</a> 野指针</h2><ul><li>野指针：指向已被释放的内存空间或者指向没有访问权限的内存空间</li><li>指针未被初始化、内存释放后未将指针设置为 <code>nullptr</code> 、指针超过了变量的作用范围（越界）都可能导致野指针的产生</li></ul><h2 id="c中的顶层const与底层const"><a class="anchor" href="#c中的顶层const与底层const">#</a> C++ 中的顶层 const 与底层 const</h2><ul><li><code>顶层const</code> ： <code>const</code> 修饰的变量本身是一个常量，无法修改；（指的是指针，出现在 <code>*</code> 的右边）</li><li><code>底层const</code> ： <code>const</code> 修饰的变量所指向的对象是一个常量（出现在 <code>*</code> 左边）</li></ul><blockquote><p>使用 <code>const_cast</code> 时，只能改变运算对象的 <code>底层const</code></p></blockquote><h2 id="常量指针与指针常量"><a class="anchor" href="#常量指针与指针常量">#</a> 常量指针与指针常量</h2><ul><li>常量指针： <code>int const* p = a</code> ，指针的指向可以改变，而不能通过该指针去改变所指向的内容</li><li>指针常量： <code>int *const p = a</code> ，指针的指向不可改变，可以通过指针去改变指向的内容.</li></ul><h2 id="数组指针与指针数组"><a class="anchor" href="#数组指针与指针数组">#</a> 数组指针与指针数组</h2><ul><li><p>数组指针： <code>int (*p)[n]</code> ，指向一个整形的一维数组，这个数组的长度是 n，在执行 <code>p+1</code> 操作时， <code>p</code> 要跨越 n 个整形数据长度</p></li><li><p>指针数组： <code>int *p[n]</code> ， <code>[]</code> 优先级高于 <code>*</code> ，是一个具有 n 个指针类型的数组.</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//a 理解成一个一维数组，元素为 a [0], a [1], a [2]， 其中 a [0] 的类型为 (int *), a 与 & amp;a [0] 等价，类型为 int (*p)[4]</span></pre></td></tr></table></figure></li></ul><h2 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h2><ul><li><p>函数指针的类型是由其返回类型和参数列表共同决定的</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//pf 为一个函数指针</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 区别于 int *pf (const int&amp;, const int&amp;);	pf 为一个函数声明，函数返回值为 int</span></pre></td></tr></table></figure></li><li><p>函数指针的赋值</p><ol><li><code>指针名=函数名</code></li><li><code>指针名=&amp;函数名</code></li></ol></li></ul><h2 id="宏定义与typedef"><a class="anchor" href="#宏定义与typedef">#</a> 宏定义与 typedef</h2><ul><li>宏定义主要用于定义常量或者一些书写复杂的内容， <code>typedef</code> 主要用于定义类型的别名</li><li>宏定义在预处理阶段完成，只会进行文本的替换，不进行类型的检查； <code>typedef</code> 在编译阶段完成，会进行类型的检查</li></ul><h2 id="const与define"><a class="anchor" href="#const与define">#</a> const 与 define</h2><h2 id="inline内联函数"><a class="anchor" href="#inline内联函数">#</a> inline 内联函数</h2><ul><li>把 inline 函数体复制到函数调用处（避免了函数调用所需要的压栈和出栈操作，提高了程序运行效率）</li><li>特性类似于宏定义，但 inline 会做类型的检查</li><li>不能包含循环、递归复杂操作</li><li><code>inline</code> 函数有多个返回点，会使用 <code>goto</code> 跳转</li><li>在类中定义的成员函数，除了虚函数，往往会自动转化为内联函数</li><li>缺点：<ol><li>代码膨胀，占用代码区的内存空间</li><li>是否内敛由编译器决定，不可控.</li></ol></li></ul><h2 id="this指针"><a class="anchor" href="#this指针">#</a> this 指针</h2><ul><li>this 是一个隐含于每一个非静态成员函数中的特殊指针，指向被实例化的对象。当调用对象成员函数时，会将对象的地址赋值给 <code>this</code> 指针，并会隐式的将 <code>this</code> 指针传入</li><li><code>tihs</code> 为一个右值，并由 <code>const</code> 修饰</li></ul><h2 id="初始化列表c11"><a class="anchor" href="#初始化列表c11">#</a> 初始化列表（C++11）</h2><ul><li>通过花括号来进行初始化。直接在变量名后面跟上初始化列表来进行对象的初始化</li></ul><h2 id="类成员函数初始化方法"><a class="anchor" href="#类成员函数初始化方法">#</a> 类成员函数初始化方法</h2><ul><li><p><code>赋值初始化</code> ：在函数体内进行赋值. (其是在所有成员被分配内存之后才进行的，此时会触发成员函数的默认构造函数，同时进入函数体赋值往往会产生临时对象，和拷贝赋值函数)</p></li><li><p><code>列表初始化</code> ：在冒号后使用初始化列表进行初始化.（给数据成员分配内存时进行的，在函数体执行之前）</p><blockquote><p>对于基本数据类型而言，两种在速度方面没有太大的差别，但对于复杂一些的数据类型，列表初始化速度会快于赋值初始化</p><p>什么情况下必须用初始化列表？</p><ul><li>初始化一个引用成员变量时</li><li>初始化一个常量成员时</li><li>当父类没有默认构造函数的时</li><li>当成员变量没有默认构造函数时</li></ul></blockquote></li></ul><h2 id="using定义别名"><a class="anchor" href="#using定义别名">#</a> using 定义别名</h2><h2 id="autoc11"><a class="anchor" href="#autoc11">#</a> auto（C++11）</h2><ul><li>类型推导，通过变量值编译器自动的进行类型的推导，相当于一个占位符（使用 <code>auto</code> 时，必须进行变量的初始化）</li><li>对于有 <code>const</code> 和 <code>volatile</code> 修饰的变量， <code>auto</code> 只能推断底层 <code>const</code> 或 <code>volatile</code> ，顶层 <code>const</code> 或 <code>volatile</code> 会被忽略，需要自己添加</li><li>不能在函数的参数中使用，不能用于定义数组，不能用于类的非静态成员</li></ul><h2 id="decltypec11"><a class="anchor" href="#decltypec11">#</a> decltype（C++11）</h2><blockquote><p>我们希望从表达式（函数返回值）中推断出想要定义的变量的类型，但是却不想用表达式的值去初始化变量，这种情况 <code>auto</code> 显得无力了</p></blockquote><ul><li>推断表达式类型作为变量的定义类型</li><li>推断函数返回值（实际不会调用，仅推断）</li><li>无论是底层 <code>const</code> 或 <code>volatile</code> 还是顶层 <code>const</code> 或 <code>volatile</code> 都会被保留</li></ul><h2 id="范围for循环c11"><a class="anchor" href="#范围for循环c11">#</a> 范围 for 循环（C++11）</h2><h2 id="null与nullptr"><a class="anchor" href="#null与nullptr">#</a> NULL 与 nullptr</h2><ul><li><p><code>NULL</code> 来自 C 语言，由宏定义实现， <code>nullptr</code> 是 C++11 新增的关键字</p></li><li><p>在 C 语言中 <code>NULL</code> 被定义成 <code>(void *)0</code> ，在 C++ 中则被定义成 <code>0</code> ，故引入 <code>nullptr</code> 替代了 <code>NULL</code></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure></li><li><p>当有一个函数被重载时，且参数都是指针类型时，调用函数时需要明确强制转换成对应类型，否则编译器无法确定需要调用哪一个函数</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	cout<span class="token operator">&lt;&lt;</span> <span class="token string">"char* p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	cout<span class="token operator">&lt;&lt;</span> <span class="token string">"int* p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	cout<span class="token operator">&lt;&lt;</span> <span class="token string">"int p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 语句 1</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 语句 2</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 语句 3</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 运行结果：</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 语句 1：char* p</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 语句 2: 报错，有多个匹配</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">//3：int p</span></pre></td></tr></table></figure></li></ul><h2 id="lambda表达式"><a class="anchor" href="#lambda表达式">#</a> lambda 表达式</h2><ul><li>匿名函数。一个 <code>lambda</code> 表达式具有一个返回值、一个参数列表和一个函数体。与函数不同的是， <code>lambda</code> 表达式可以定义在函数体内部，格式为： <code>[capture list](parameter list)-&gt;return type &#123;function body&#125;</code> ，不能用默认参数.</li><li><code>capture list</code> ：捕获列表<ol><li><code>[]</code> ：不捕获任何变量</li><li><code>[&amp;]</code> ：捕获外部作用域中的所有变量，并作为引用在函数体内使用（按引用捕获）</li><li><code>[=]</code> ：捕获外部作用域中的所有变量，并作为副本在函数体内使用（按值捕获）</li><li></li></ol></li></ul><h2 id="左值引用与右值引用"><a class="anchor" href="#左值引用与右值引用">#</a> 左值引用与右值引用</h2><ul><li>左值引用：对左值的引用（可以出现在等式的左边，也可以出现在等式的右边，是具名的，同时可以取地址， <code>const左值引用</code> 可以引用右值）; 避免对象的拷贝，在一定程度上让程序脱离了危险的指针</li><li>右值引用：右值（只能出现在等式的右边，不能取地址，纯右值 [字面值，返回的非引用的函数调用，后置自增 / 减，算术表达式，逻辑表达式，比较表达式], 将亡值 [C++11 引入，会触发移动构造或者移动赋值，并进行资源转移]）往往是没有名称，在实际开发中我们可能需要对右值进行修改，需要借助右值引用（ <code>类型&amp;&amp; 变量名=右值</code> ）<ol><li>移动语义：将一个临时对象（将亡值）的资源转移到另外一个对象中去，可以减少不必要的资源的销毁和开辟，提高运行效率</li><li><code>move()</code> ：将左值强制转化为右值引用，通过右值引用来使用，实现移动语义.</li><li>完美转发</li></ol></li></ul><h2 id="大小端存储"><a class="anchor" href="#大小端存储">#</a> 大小端存储</h2><ul><li>大端存储：高位存储在低字节中</li><li>小端存储：低位存储在低字节中</li></ul><blockquote><p>在 <code>Socket网络编程</code> 中，有主机字节序和网络字节序</p></blockquote><h2 id="内存对齐"><a class="anchor" href="#内存对齐">#</a> 内存对齐</h2><blockquote><p>实际的内存读取时，是一组一组来读取的，一组内存在 n 个字节</p></blockquote><ul><li>加快内存的获取速度</li></ul><h2 id="内存池"><a class="anchor" href="#内存池">#</a> 内存池</h2><ul><li>预先申请分配一定数量的内存块留作备用，当有新的内存需求时，就从内存池中分出一部分内存块，对于使用完的内存块将其放回内存池。若内存池不够，在继续申请新的内存. （防止频繁的内存申请与释放所带来的开销，提高分配效率，同时可以避免内存碎片）</li></ul><h2 id="stl六大组件"><a class="anchor" href="#stl六大组件">#</a> STL 六大组件</h2><ul><li>容器、算法、迭代器、适配器、仿函数、空间分配器</li></ul><h2 id="为什么stack的pop和top要分离"><a class="anchor" href="#为什么stack的pop和top要分离">#</a> 为什么 stack 的 pop () 和 top () 要分离</h2><ul><li>通过 <code>pop()</code> 来弹出并返回栈顶值这种方式不安全，可能导致原始数据丢失；pop () 在函数返回时，会发生对象的拷贝，如果弹出对象比较大，同时堆内内存比较紧张，可能无法分配住够的内存会抛出异常，无法正确的返回栈顶元素，但是此时栈顶元素已经弹出.</li><li>通过引用或者指针可以解决这个问题</li></ul><h2 id="map-set-multimap-multiset关联容器"><a class="anchor" href="#map-set-multimap-multiset关联容器">#</a> map、set、multimap、multiset（关联容器）</h2><ul><li>底层实现是 <code>红黑树</code></li><li><code>set</code> 和 <code>multiset</code> 会对元素进行排序， <code>set</code> 不存储重复元素， <code>multiset</code> 可以存储重复元素</li><li><code>map</code> 和 <code>multimap</code> 存储的元素为 k-v 键值对，会更加 key 进行排序， <code>map</code> 中不允许重复 key， <code>multimap</code> 可以重复 key</li></ul><h2 id="unordered_set与set"><a class="anchor" href="#unordered_set与set">#</a> unordered_set 与 set</h2><ul><li><code>unordered_set</code> 内部无序，通过哈希来实现，对于非标准类型需要提供判等函数，插入，查询，删除的时间复杂度都是 <code>O(1)</code> ，但是不稳定，当数据量大冲突大时，时间复杂度最坏退化为 <code>O(n)</code> ； <code>set</code> 内部有序，通过红黑树来实现，对于非标准类型需要提供比较函数，插入，查询，删除的时间复杂度比较稳定 <code>log2(n)</code> .</li></ul><h2 id="哈希函数"><a class="anchor" href="#哈希函数">#</a> 哈希函数</h2><ul><li>平方取中发：去关键字的平方值的中间几位作为哈希地址</li></ul><h2 id="哈希冲突"><a class="anchor" href="#哈希冲突">#</a> 哈希冲突</h2><ul><li>开放地址法（再散列）：线性探测，再平方探测、伪随机探测</li><li>拉链法</li><li>再哈希</li></ul><h2 id="vector的扩容机制"><a class="anchor" href="#vector的扩容机制">#</a> vector 的扩容机制</h2><ul><li><code>vector</code> 是一个动态数组，当插入元素使，若 <code>capacity</code> 和 <code>size</code> 相等，则会发生扩容； <code>vector</code> 扩容并不是在原有空间进行扩充，而是在堆内申请一块更大空间的区域，将原来的数据复制过去，同时释放原有空间。至于这个扩容系数，得看具体的实现，得看取舍（内存和效率的取舍）， <code>GCC</code> 下的扩容系数是 2</li></ul><h2 id="vectorclear-swap-shrink_to_fitresizereserve"><a class="anchor" href="#vectorclear-swap-shrink_to_fitresizereserve">#</a> vector（clear(), swap(), shrink_to_fit(),resize(),reserve()）</h2><ul><li><code>clear()</code> ：清空内容，不释放内存（capacity 不变，size 变成 0）</li><li><code>swap()</code> ：清空内容，释放内存 (capacity，size 均变成 0)</li><li><code>shrink_to_fit()</code> ：可能会释放内存，使 capacity 与 size 适配（capacity 与 size 相等）</li><li><code>resize(n)</code> ：会改变 <code>vector</code> 的 size</li><li><code>reserve()</code> ：不会改变 size，但是可能会改变 capacity. 主要目的是为了优化性能，避免在添加元素时频繁进行内存分配</li></ul><h2 id="vector与list"><a class="anchor" href="#vector与list">#</a> vector 与 list</h2><ul><li><code>vector</code> 的内存空间是连续的，可以在 <code>o(1)</code> 内实现随机存取，但是需要再内部进行插入和删除时，需要 <code>O(n)</code> .</li><li><code>list</code> 是双向链表，内存空间不一定连续，往往是离散的， <code>O(n)</code> 完成随机存取，但是可以 <code>O(1)</code> 实现删除和插入操作</li></ul><h2 id="clear的时间复杂度"><a class="anchor" href="#clear的时间复杂度">#</a> clear 的时间复杂度</h2><ul><li>无论是顺序容器还是关联容器在使用 <code>clear()</code> 时，时间复杂度都是 <code>O(n)</code> ；因为执行 <code>clear()</code> 需要调用元素的析构函数，这个析构函数会逐个进行。不过当存储的数据类型是基本数据类型的时候，不需要虚构，系统可能会做一些优化， <code>vector</code> 容器可以使得复杂度降为常数级.</li></ul><h2 id="c智能指针c11"><a class="anchor" href="#c智能指针c11">#</a> C<ins> 智能指针（C</ins>11）</h2><ul><li><p>智能指针是一个类，用来存储指向动态内存空间的对象指针，负责自动释放动态内存，防止堆内存泄漏.</p></li><li><p><code>auto_ptr</code> ：C<ins>98 引入，由于其不够安全，被 <code>unique_ptr</code> 取代，C</ins>11 废弃；</p></li><li><p><code>unique_ptr</code> ：与 <code>auto_ptr</code> 一样采用所有权模式，同一时间只能有一个指针可以指向某个对象，但是 <code>unique_ptr</code> 禁止了拷贝操作， <code>unique_ptr</code> 采用了移动赋值 <code>move()</code> 函数来进行控制权转移.</p></li><li><p><code>share_ptr</code> ：共享所有权的一个智能指针。允许多个指针指针指向同一个对象，并使用引用计数来管理指向对象的指针（成员函数 <code>use_count()</code> 可获得引用计数），该对象和相关资源会在最后一个引用被销毁时释放</p><ul><li><p><code>share_ptr</code> ：内部的引用计数是线程安全的，但是对象的读取需要加锁.</p></li><li><p><code>shared_ptr</code> 循环计数问题：创建了两个 <code>shared_ptr</code> 分别指向两个对象，而这两个对象内的一个共享指针分别又指向了对方，造成了循环计数，使得两个对象的空间都无法被释放.</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">ListNode</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> _data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> <span class="token function">node1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> <span class="token function">node2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> node1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> node2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	node1<span class="token operator">-></span>ptr <span class="token operator">=</span> node2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	node2<span class="token operator">-></span>ptr <span class="token operator">=</span> node1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> node1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 2</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> node2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 2</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 常用的解决方案是讲成员函数内的 shared_pre 改成弱指针 weak_ptr</span></pre></td></tr></table></figure></li></ul></li><li><p><code>weak_ptr</code> ：一种不控制对象生命周期的智能指针，不会影响 <code>share_ptr</code> 的引用计数，只是提供一种访问其管理对象的方式</p></li></ul><h2 id="内存泄漏"><a class="anchor" href="#内存泄漏">#</a> 内存泄漏</h2><ul><li>堆内存泄漏（ <code>Heap leak</code> ）</li><li>在释放对象数组时没有使用 <code>delete []</code> 而使用 <code>delete</code></li><li>没有将基类的析构函数定义为虚函数</li><li>缺少拷贝构造函数和拷贝赋值函数</li></ul><blockquote><p>Linux 下内存泄漏检查工具：<strong>Valgrind</strong></p></blockquote><h2 id="深拷贝与浅拷贝"><a class="anchor" href="#深拷贝与浅拷贝">#</a> 深拷贝与浅拷贝</h2><ul><li>浅拷贝：C++ 默认的方式（如果程序员不主动编写拷贝构造函数和赋值构造，编译器将以浅拷贝的方式生成缺省的函数），简单的将成员函数值进行复制. （当成员变量出现指针时，则会导致多个指针指向同一片内存空间，新旧对象共享内存，当其中一个对象释放内存，再调释放其他对象时就会出现问题，同一片内存空间被释放了多次）</li><li>深拷贝：必须显示的提供拷贝构造函数和赋值构造，新旧对象不共享内存</li></ul><h2 id="c类默认生成的函数"><a class="anchor" href="#c类默认生成的函数">#</a> C++ 类默认生成的函数</h2><ul><li>无参构造函数、析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、重载取地址符，均是 <code>public</code></li></ul><h2 id="对象复用与零拷贝"><a class="anchor" href="#对象复用与零拷贝">#</a> 对象复用与零拷贝</h2><h2 id="stl内存优化"><a class="anchor" href="#stl内存优化">#</a> STL 内存优化</h2><h2 id="const-2"><a class="anchor" href="#const-2">#</a> <code>const</code></h2><ul><li><p>当以编译初始化的方式定义了一个 <code>const</code> 对象时，例如 <code>const int bufsize=512</code> ，编译器将在编译过程中把用到该变量的地方都替换成对应的值。</p></li><li><p><code>const</code> 对象被设定为仅在文件内有效，当多个文件中出现了同名的 <code>const</code> 变量时，其实等同于在不同文件下分别定义了独立的变量；当某一个 <code>const</code> 对象需要再多个文件间共享时，我们需要对于 <code>const</code> 变量不管是声明还是定义都添加 <code>extern</code> 关键字。</p></li></ul><h3 id="对常量的引用"><a class="anchor" href="#对常量的引用">#</a> 对常量的引用</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> dval<span class="token punctuation">;</span></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> dval<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr></table></figure><p>系统在内部会将对常数的引用绑定在一个临时对象上，实际并未绑定 <code>dval</code> ；通过这种设计可以防止非法的操作。</p><h2 id="顺序容器"><a class="anchor" href="#顺序容器">#</a> 顺序容器</h2><ul><li><code>vector</code> ：可变长数组。支持快速随机访问。在尾部之外的其他位置插入或者删除元素可能比较慢</li><li><code>deque</code> ：双端队列。支持快速随机访问。在头部或者尾部插入、删除元素速度很快</li><li><code>list</code> ：双向列表。</li><li><code>forward_list</code> ：单向列表。</li><li><code>array</code> ：固定大小数组。支持快速随机访问。不能添加或者删除元素。</li><li><code>string</code> ：与 <code>vector</code> 类似，但专门用于存储字符</li></ul><h2 id="原始字面量"><a class="anchor" href="#原始字面量">#</a> 原始字面量</h2><p><strong>定义方式</strong>：<em>R×××(原始字符串)×××</em></p><p>其中 <code>()</code> 两侧的字符串 <code>×××</code> 可以省略，原始字面量 <code>R</code> 可以直接表示字符串的实际含义（不进行转义）</p><h2 id="指针空值类型"><a class="anchor" href="#指针空值类型">#</a> 指针空值类型</h2><p>C 与 C<ins> 内定义的 <code>NULL</code> 含义不同；C</ins> 内定义： <code>#define NULL 0</code> , 而 C 内的定义： <code>#define NULL ((void *)0)</code> .C 与 C<ins> 都是强类型语言，从 C 到 C</ins> 语言的类型定义变的更加严格，C++ 内不允许 <code>void( *)</code> 类型的变量隐式转化为其他类型。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 宏定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure><p><code>nullptr</code> 无法隐式的转化为整形，但是可以隐式匹配指针类型</p><h2 id="constexpr"><a class="anchor" href="#constexpr">#</a> constexpr</h2><p>const 的双重语义：<em>变量只读</em>和<em>修饰常量</em></p><p>c++ 程序从编写完成到执行分为四个阶段：<em>预处理</em>、<em>编译</em>、<em>汇编</em>和<em>链接</em>。非常量表达式只能在运行阶段计算出结果，但常量表达式计算发生程序编译阶段，这可以大大提高程序的执行效率。</p><p>为了提高 C++ 程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用 <code>constexpr</code> 修饰函数返回值，这种函数被称作常量表达式函数，这写函数主要包括一下几种：普通函数、类成员函数、类构造函数、模版函数。</p><ol><li>函数必须要用返回值，并且 <code>return</code> 返回的表达式必须是常量表达式</li><li>函数在使用之前，必须有对应的定义语句</li><li>整个函数的函数体中，不能出现非常量表达式之外的语句（ <code>using, typedef, static_assert, return</code> 语句除外）</li></ol><p>C++11 语法中， <code>constexpr</code> 可以修饰模版函数，但由于模版中类型的不确定性，因此模版函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。如果 <code>constexpr</code> 修饰的模版函数实例化结果不满足常量表达式函数的要求，则 <code>constexpr</code> 会被自动忽略，即该函数就等同于一个普通函数</p><h2 id="auto"><a class="anchor" href="#auto">#</a> auto</h2><p><code>auto</code> 可以自动推导变量类型；使用 <code>auto</code> 声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译阶段将 <code>auto</code> 占位符替换成其真正的类型。</p><ul><li>当变量不是指针或者引用类型时，推导的结果中不会保留 <code>const和、volatile</code> 关键字</li><li>当变量是指针或者引用类型时，推导的结果中会保留 <code>const和、volatile</code> 关键字</li></ul><h3 id="auto的限制"><a class="anchor" href="#auto的限制">#</a> auto 的限制</h3><ul><li>不能作为函数参数使用。因为只有在函数被调用的时候才会给函数参数传递实参， <code>auto</code> 要求必须给修饰的变量赋值。</li><li>不能用于类的非静态成员变量的初始化（类的非静态成员不属于类，而属于对象，只有对象被创建出来之后，才能给非静态成员变量赋值）</li><li>不能使用 <code>auto</code> 关键字定义数组</li><li>无法使用 <code>auto</code> 推导出模版</li></ul><h2 id="使用结构化绑定来解包绑定的返回值"><a class="anchor" href="#使用结构化绑定来解包绑定的返回值">#</a> 使用结构化绑定来解包绑定的返回值</h2><p>结构化绑定是 C++17 新特性，其可以结合语法糖自动推导类型，并可以从组对、元祖和结构体中提取单独的变量（解包）</p><ol><li><p>使用结构化绑定是为了能过更加简单的为绑定的多个变量进行赋值</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//  对 pair 的结构化绑定</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token keyword">int</span> dividend<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">auto</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">//  对 tuple 进行结构化绑定</span></pre></td></tr><tr><td data-num="5"></td><td><pre>std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span>time_point<span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> valid_time<span class="token punctuation">,</span> price<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">stock_info</span><span class="token punctuation">(</span><span class="token string">"INTC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//  对自定义结构体进行结构化绑定</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">employee</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">unsigned</span> id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    string name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    string role<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">unsigned</span> salary<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>employee<span class="token operator">></span> employees<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">/* 注意：在适当时候使用引用，尽量减少不必要的复制 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary<span class="token punctuation">]</span> <span class="token operator">:</span> employees<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span> name</pre></td></tr><tr><td data-num="18"></td><td><pre>         <span class="token operator">&lt;&lt;</span> <span class="token string">"Role: "</span> <span class="token operator">&lt;&lt;</span> role</pre></td></tr><tr><td data-num="19"></td><td><pre>         <span class="token operator">&lt;&lt;</span> <span class="token string">"Salary: "</span> <span class="token operator">&lt;&lt;</span> salary <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p><code>STL</code> 中的基础数据结构都能通过结构化绑定来直接进行访问</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> animal_population<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>species<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> animal_population<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"There are "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> species</pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token operator">&lt;&lt;</span> <span class="token string">" on this planet.\n"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><blockquote><p>Node：与 C 的语法特征不同，将复杂结构体作为返回值传回会耗费大量的时间，因为对象需要在返回函数中进行初始化，之后将这个对象拷贝到相应容器中返回给调用端。现代编译器支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><strong>返回值优化</strong></a> (RVO, <em>return value optimization</em>) 技术，这项技术可以省略中间副本的拷贝。</p></blockquote><h2 id="带初始化的if和switch"><a class="anchor" href="#带初始化的if和switch">#</a> 带初始化的 if 和 switch</h2><h2 id="括号初始化"><a class="anchor" href="#括号初始化">#</a> 括号初始化</h2><p><code>C++11</code> 引入了新的括号初始化语法 <code>&#123;&#125;</code> ，其不仅允许集合式的初始化，而且还是对常规构造函数的调用。遗憾的是，当与 <code>auto</code> 类型变量结合使用时，这种方式很容易出现错误， <code>c++17</code> 增强了这一系列初始化规则。</p><div class="tags"><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="ic i-tag"></i> 面试题</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-03-18 18:10:07" itemprop="dateModified" datetime="2024-03-18T18:10:07+08:00">2024-03-18</time> </span><span id="value/C++面试题.html" class="item leancloud_visitors" data-flag-title="C++面试题" title="Views"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">Views</span> <span class="leancloud-visitors-count"></span> <span class="text">times</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="Value WeChat Pay"><p>WeChat Pay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Value <i class="ic i-at"><em>@</em></i>繁華落盡 似水流年</li><li class="link"><strong>Post link: </strong><a href="http://example.com/value/C++%E9%9D%A2%E8%AF%95%E9%A2%98" title="C++面试题">http://example.com/value/C++面试题</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Special-JiaHao&#x2F;images&#x2F;main&#x2F;computing-network.png" title="计算机网络面试题"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>计算机网络面试题</h3></a></div><div class="item right"><a href="/value/daily/March%202024" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;dogefs.s3.ladydaily.com&#x2F;~&#x2F;source&#x2F;unsplash&#x2F;photo-1558470598-a5dda9640f68?q&#x3D;80&amp;w&#x3D;2071&amp;auto&#x3D;format&amp;fit&#x3D;crop&amp;ixlib&#x3D;rb-4.0.3&amp;ixid&#x3D;M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" title="March 2024"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> daily - March</span><h3>March 2024</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">C++ 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">程序编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cc%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.</span> <span class="toc-text">C&#x2F;C++ 内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">堆与栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">函数调用的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.5.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">1.6.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable"><span class="toc-number">1.7.</span> <span class="toc-text">mutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">1.8.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.9.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.10.</span> <span class="toc-text">C++ 三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88c%E9%BB%98%E8%AE%A4%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">为什么 C++ 默认析构函数不是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99-%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.12.</span> <span class="toc-text">重载、重写、重定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%92%8Coverride"><span class="toc-number">1.13.</span> <span class="toc-text">final 和 override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E4%B8%8Eclass"><span class="toc-number">1.14.</span> <span class="toc-text">struct 与 class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%92%8C-malloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">new 和 malloc 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-%E4%B8%8E-free"><span class="toc-number">1.16.</span> <span class="toc-text">delete 与 free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97"><span class="toc-number">1.17.</span> <span class="toc-text">free 回收的内存是立即返回给操作系统吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E4%B8%8Edelete"><span class="toc-number">1.18.</span> <span class="toc-text">new [] 与 delete []</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E4%B8%8Efree%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.19.</span> <span class="toc-text">malloc 与 free 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dnew"><span class="toc-number">1.20.</span> <span class="toc-text">C++ 中的几种 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.21.</span> <span class="toc-text">C++ 强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.22.</span> <span class="toc-text">指针与引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">1.23.</span> <span class="toc-text">常引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.24.</span> <span class="toc-text">将引用作为函数返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.25.</span> <span class="toc-text">野指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E9%A1%B6%E5%B1%82const%E4%B8%8E%E5%BA%95%E5%B1%82const"><span class="toc-number">1.26.</span> <span class="toc-text">C++ 中的顶层 const 与底层 const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">1.27.</span> <span class="toc-text">常量指针与指针常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">1.28.</span> <span class="toc-text">数组指针与指针数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.29.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8Etypedef"><span class="toc-number">1.30.</span> <span class="toc-text">宏定义与 typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E4%B8%8Edefine"><span class="toc-number">1.31.</span> <span class="toc-text">const 与 define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.32.</span> <span class="toc-text">inline 内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.33.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8c11"><span class="toc-number">1.34.</span> <span class="toc-text">初始化列表（C++11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.35.</span> <span class="toc-text">类成员函数初始化方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-number">1.36.</span> <span class="toc-text">using 定义别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autoc11"><span class="toc-number">1.37.</span> <span class="toc-text">auto（C++11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltypec11"><span class="toc-number">1.38.</span> <span class="toc-text">decltype（C++11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AFc11"><span class="toc-number">1.39.</span> <span class="toc-text">范围 for 循环（C++11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E4%B8%8Enullptr"><span class="toc-number">1.40.</span> <span class="toc-text">NULL 与 nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.41.</span> <span class="toc-text">lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.42.</span> <span class="toc-text">左值引用与右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.43.</span> <span class="toc-text">大小端存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.44.</span> <span class="toc-text">内存对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">1.45.</span> <span class="toc-text">内存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.46.</span> <span class="toc-text">STL 六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88stack%E7%9A%84pop%E5%92%8Ctop%E8%A6%81%E5%88%86%E7%A6%BB"><span class="toc-number">1.47.</span> <span class="toc-text">为什么 stack 的 pop () 和 top () 要分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-set-multimap-multiset%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">1.48.</span> <span class="toc-text">map、set、multimap、multiset（关联容器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered_set%E4%B8%8Eset"><span class="toc-number">1.49.</span> <span class="toc-text">unordered_set 与 set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.50.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.51.</span> <span class="toc-text">哈希冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.52.</span> <span class="toc-text">vector 的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vectorclear-swap-shrink_to_fitresizereserve"><span class="toc-number">1.53.</span> <span class="toc-text">vector（clear(), swap(), shrink_to_fit(),resize(),reserve()）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E4%B8%8Elist"><span class="toc-number">1.54.</span> <span class="toc-text">vector 与 list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clear%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.55.</span> <span class="toc-text">clear 的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c11"><span class="toc-number">1.56.</span> <span class="toc-text">C 智能指针（C11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.57.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.58.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E7%B1%BB%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.59.</span> <span class="toc-text">C++ 类默认生成的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.60.</span> <span class="toc-text">对象复用与零拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.61.</span> <span class="toc-text">STL 内存优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-2"><span class="toc-number">1.62.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B8%B8%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.62.1.</span> <span class="toc-text">对常量的引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.63.</span> <span class="toc-text">顺序容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.64.</span> <span class="toc-text">原始字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.65.</span> <span class="toc-text">指针空值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr"><span class="toc-number">1.66.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">1.67.</span> <span class="toc-text">auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.67.1.</span> <span class="toc-text">auto 的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.68.</span> <span class="toc-text">使用结构化绑定来解包绑定的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84if%E5%92%8Cswitch"><span class="toc-number">1.69.</span> <span class="toc-text">带初始化的 if 和 switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.70.</span> <span class="toc-text">括号初始化</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/value/%E9%87%91%E5%B1%B1%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F" rel="bookmark" title="金山会议室预约系统">金山会议室预约系统</a></li><li class="active"><a href="/value/C++%E9%9D%A2%E8%AF%95%E9%A2%98" rel="bookmark" title="C++面试题">C++面试题</a></li><li><a href="/value/%E7%BE%8E%E5%9B%A2%E6%A0%A1%E6%8B%9B" rel="bookmark" title="美团校招">美团校招</a></li><li><a href="/value/%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="bookmark" title="多线程与线程池">多线程与线程池</a></li><li><a href="/value/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0" rel="bookmark" title="数据库连接池">数据库连接池</a></li><li><a href="/value/%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B" rel="bookmark" title="腾讯校招">腾讯校招</a></li><li><a href="/value/%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2%E6%A0%A1%E6%8B%9B" rel="bookmark" title="蚂蚁集团校招">蚂蚁集团校招</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Value" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Value</p><div class="description" itemprop="description">编程日记 & 随笔</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">24</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NwZWNpYWwtSmlhSGFv" title="https:&#x2F;&#x2F;github.com&#x2F;Special-JiaHao"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTIwNDE4OTkzODk=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;2041899389"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDMzNDE3NDUwP3NwbV9pZF9mcm9tPTMzMy4zMzcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;433417450?spm_id_from&#x3D;333.337.0.0"><i class="ic i-bilibili"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmpoMTU3NzA5QDE2My5jb20=" title="mailto:jh157709@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/value/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/value/daily/March%202024" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/daily-March/" title="In daily - March">daily - March</a></div><span><a href="/value/daily/March%202024" title="March 2024">March 2024</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Machine-Learning/" title="In Machine Learning">Machine Learning</a> <i class="ic i-angle-right"></i> <a href="/categories/Machine-Learning/Mathematical-methods/" title="In Mathematical methods">Mathematical methods</a></div><span><a href="/value/least%20squares%20method" title="最小二乘法">最小二乘法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Tools/" title="In Tools">Tools</a></div><span><a href="/value/cmake" title="cmake">cmake</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="In 数据库">数据库</a></div><span><a href="/value/redis" title="redis">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C-STL/" title="In C++ - STL">C++ - STL</a></div><span><a href="/value/stl_list" title="STL List">STL List</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ns3/" title="In ns3">ns3</a></div><span><a href="/value/ns3%20install" title="ns3 install">ns3 install</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPP/" title="In C++">C++</a></div><span><a href="/value/%E7%BE%8E%E5%9B%A2%E6%A0%A1%E6%8B%9B" title="美团校招">美团校招</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unix/" title="In Unix">Unix</a></div><span><a href="/value/Unix%20programing" title="UNIX网络编程">UNIX网络编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Leetcode/" title="In Leetcode">Leetcode</a></div><span><a href="/value/Leetcode/%E7%AC%AC%20126%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3" title="第 126 场双周赛">第 126 场双周赛</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Markdown/" title="In Markdown">Markdown</a></div><span><a href="/value/Markdown%20grammar" title="Markdown语法">Markdown语法</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Value @ Value's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">112k words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">1:42</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"value/C++面试题.html",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->